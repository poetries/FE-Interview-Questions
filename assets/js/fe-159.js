(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{1175:function(e,n,o){"use strict";o.r(n);var t=o(51),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"一、promise基础用法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#一、promise基础用法"}},[e._v("#")]),e._v(" 一、Promise基础用法")]),e._v(" "),o("h3",{attrs:{id:"_1-1-基本用法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-基本用法"}},[e._v("#")]),e._v(" 1.1 基本用法")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("new Promise(function(resolve, reject) {\n    //待处理的异步逻辑\n    //处理结束后，调用resolve或reject方法\n})\n")])])]),o("blockquote",[o("ul",[o("li",[e._v("新建一个"),o("code",[e._v("promise")]),e._v("很简单，只需要"),o("code",[e._v("new")]),e._v("一个"),o("code",[e._v("promise")]),e._v("对象即可。所以"),o("code",[e._v("promise")]),e._v("本质上就是一个函数，它接受一个函数作为参数，并且会返回"),o("code",[e._v("promise")]),e._v("对象，这就给链式调用提供了基础")]),e._v(" "),o("li",[e._v("其实"),o("code",[e._v("Promise")]),e._v("函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态：")])])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("pending")]),e._v(": 初始状态，位履行或拒绝")]),e._v(" "),o("li",[o("code",[e._v("fulfilled")]),e._v(": 意味着操作成功完成")]),e._v(" "),o("li",[o("code",[e._v("rejected")]),e._v(": 意味着操作失败")])]),e._v(" "),o("blockquote",[o("p",[o("code",[e._v("pending")]),e._v(" 状态的 "),o("code",[e._v("Promise")]),e._v("对象可能以 "),o("code",[e._v("fulfilled")]),e._v("状态返回了一个值，也可能被某种理由（异常信息）拒绝（"),o("code",[e._v("reject")]),e._v("）了。当其中任一种情况出现时，"),o("code",[e._v("Promise")]),e._v(" 对象的 "),o("code",[e._v("then")]),e._v(" 方法绑定的处理方法（handlers）就会被调用，then方法分别指定了"),o("code",[e._v("resolve")]),e._v("方法和"),o("code",[e._v("reject")]),e._v("方法的回调函数")])]),e._v(" "),o("p",[o("img",{attrs:{src:"https://mengera88.github.io/images/promises.png",alt:"img"}})]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("var promise = new Promise(function(resolve, reject) {\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\npromise.then(function(value) {\n  // 如果调用了resolve方法，执行此函数\n}, function(value) {\n  // 如果调用了reject方法，执行此函数\n});\n")])])]),o("blockquote",[o("p",[e._v("上述代码很清晰的展示了"),o("code",[e._v("promise")]),e._v("对象运行的机制。下面再看一个示例：")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('var getJSON = function(url) {\n  var promise = new Promise(function(resolve, reject){\n    var client = new XMLHttpRequest();\n    client.open("GET", url);\n    client.onreadystatechange = handler;\n    client.responseType = "json";\n    client.setRequestHeader("Accept", "application/json");\n    client.send();\n    function handler() {\n      if (this.status === 200) { \n              resolve(this.response); \n          } else { \n              reject(new Error(this.statusText)); \n          }\n    };\n  });\n  return promise;\n};\ngetJSON("/posts.json").then(function(json) {\n  console.log(\'Contents: \' + json);\n}, function(error) {\n  console.error(\'出错了\', error);\n});\n')])])]),o("blockquote",[o("p",[e._v("上面代码中，"),o("code",[e._v("resolve")]),e._v("方法和"),o("code",[e._v("reject")]),e._v("方法调用时，都带有参数。它们的参数会被传递给回调函数。"),o("code",[e._v("reject")]),e._v("方法的参数通常是"),o("code",[e._v("Error")]),e._v("对象的实例，而"),o("code",[e._v("resolve")]),e._v("方法的参数除了正常的值以外，还可能是另一个"),o("code",[e._v("Promise")]),e._v("实例，比如像下面这样。")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("var p1 = new Promise(function(resolve, reject){\n  // ... some code\n});\nvar p2 = new Promise(function(resolve, reject){\n  // ... some code\n  resolve(p1);\n})\n")])])]),o("blockquote",[o("p",[e._v("上面代码中，"),o("code",[e._v("p1")]),e._v("和"),o("code",[e._v("p2")]),e._v("都是"),o("code",[e._v("Promise")]),e._v("的实例，但是"),o("code",[e._v("p2")]),e._v("的"),o("code",[e._v("resolve")]),e._v("方法将"),o("code",[e._v("p1")]),e._v("作为参数，这时"),o("code",[e._v("p1")]),e._v("的状态就会传递给"),o("code",[e._v("p2")]),e._v("。如果调用的时候，"),o("code",[e._v("p1")]),e._v("的状态是"),o("code",[e._v("pending")]),e._v("，那么"),o("code",[e._v("p2")]),e._v("的回调函数就会等待"),o("code",[e._v("p1")]),e._v("的状态改变；如果"),o("code",[e._v("p1")]),e._v("的状态已经是"),o("code",[e._v("fulfilled")]),e._v("或者"),o("code",[e._v("rejected")]),e._v("，那么"),o("code",[e._v("p2")]),e._v("的回调函数将会立刻执行")])]),e._v(" "),o("h3",{attrs:{id:"_1-2-promise捕获错误"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-promise捕获错误"}},[e._v("#")]),e._v(" 1.2 promise捕获错误")]),e._v(" "),o("blockquote",[o("p",[o("code",[e._v("Promise.prototype.catch")]),e._v("方法是"),o("code",[e._v("Promise.prototype.then(null, rejection)")]),e._v("的别名，用于指定发生错误时的回调函数")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("getJSON(\"/visa.json\").then(function(result) {\n  // some code\n}).catch(function(error) {\n  // 处理前一个回调函数运行时发生的错误\n  console.log('出错啦！', error);\n});\n")])])]),o("blockquote",[o("p",[o("code",[e._v("Promise")]),e._v("对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个"),o("code",[e._v("catch")]),e._v("语句捕获")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('getJSON("/visa.json").then(function(json) {\n  return json.name;\n}).then(function(name) {\n  // proceed\n}).catch(function(error) {\n    //处理前面任一个then函数抛出的错误\n});\n')])])]),o("h3",{attrs:{id:"_1-3-常用的promise方法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-常用的promise方法"}},[e._v("#")]),e._v(" 1.3 常用的promise方法")]),e._v(" "),o("p",[o("strong",[e._v("Promise.all方法")])]),e._v(" "),o("blockquote",[o("p",[o("code",[e._v("Promise.all")]),e._v("方法用于将多个"),o("code",[e._v("Promise")]),e._v("实例，包装成一个新的"),o("code",[e._v("Promise")]),e._v("实例")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("var p = Promise.all([p1,p2,p3]);\n")])])]),o("ul",[o("li",[e._v("上面代码中，"),o("code",[e._v("Promise.all")]),e._v("方法接受一个数组作为参数，"),o("code",[e._v("p1")]),e._v("、"),o("code",[e._v("p2")]),e._v("、"),o("code",[e._v("p3")]),e._v("都是"),o("code",[e._v("Promise")]),e._v("对象的实例。（"),o("code",[e._v("Promise.all")]),e._v("方法的参数不一定是数组，但是必须具有"),o("code",[e._v("iterator")]),e._v("接口，且返回的每个成员都是"),o("code",[e._v("Promise")]),e._v("实例。）")])]),e._v(" "),o("blockquote",[o("p",[o("code",[e._v("p")]),e._v("的状态由"),o("code",[e._v("p1")]),e._v("、"),o("code",[e._v("p2")]),e._v("、"),o("code",[e._v("p3")]),e._v("决定，分成两种情况")])]),e._v(" "),o("ul",[o("li",[e._v("只有"),o("code",[e._v("p1")]),e._v("、"),o("code",[e._v("p2")]),e._v("、"),o("code",[e._v("p3")]),e._v("的状态都变成"),o("code",[e._v("fulfilled")]),e._v("，"),o("code",[e._v("p")]),e._v("的状态才会变成"),o("code",[e._v("fulfilled")]),e._v("，此时"),o("code",[e._v("p1")]),e._v("、"),o("code",[e._v("p2")]),e._v("、"),o("code",[e._v("p3")]),e._v("的返回值组成一个数组，传递给"),o("code",[e._v("p")]),e._v("的回调函数")]),e._v(" "),o("li",[e._v("只要"),o("code",[e._v("p1")]),e._v("、"),o("code",[e._v("p2")]),e._v("、"),o("code",[e._v("p3")]),e._v("之中有一个被"),o("code",[e._v("rejected")]),e._v("，"),o("code",[e._v("p")]),e._v("的状态就变成"),o("code",[e._v("rejected")]),e._v("，此时第一个被"),o("code",[e._v("reject")]),e._v("的实例的返回值，会传递给p的回调函数")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// 生成一个Promise对象的数组\nvar promises = [2, 3, 5, 7, 11, 13].map(function(id){\n  return getJSON("/get/addr" + id + ".json");\n});\nPromise.all(promises).then(function(posts) {\n  // ...  \n}).catch(function(reason){\n  // ...\n});\n')])])]),o("p",[o("strong",[e._v("Promise.race方法")])]),e._v(" "),o("blockquote",[o("p",[o("code",[e._v("Promise.race")]),e._v("方法同样是将多个"),o("code",[e._v("Promise")]),e._v("实例，包装成一个新的"),o("code",[e._v("Promise")]),e._v("实例。")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("var p = Promise.race([p1,p2,p3]);\n")])])]),o("blockquote",[o("p",[e._v("上面代码中，只要"),o("code",[e._v("p1")]),e._v("、"),o("code",[e._v("p2")]),e._v("、"),o("code",[e._v("p3")]),e._v("之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值")])]),e._v(" "),o("ul",[o("li",[e._v("如果"),o("code",[e._v("Promise.all")]),e._v("方法和"),o("code",[e._v("Promise.race")]),e._v("方法的参数，不是"),o("code",[e._v("Promise")]),e._v("实例，就会先调用下面讲到的"),o("code",[e._v("Promise.resolve")]),e._v("方法，将参数转为"),o("code",[e._v("Promise")]),e._v("实例，再进一步处理")])]),e._v(" "),o("p",[o("strong",[e._v("Promise.resolve")])]),e._v(" "),o("blockquote",[o("p",[e._v("有时需要将现有对象转为"),o("code",[e._v("Promise")]),e._v("对象，"),o("code",[e._v("Promise.resolve")]),e._v("方法就起到这个作用")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("var jsPromise = Promise.resolve($.ajax('/whatever.json'));\n")])])]),o("blockquote",[o("p",[e._v("上面代码将"),o("code",[e._v("jQuery")]),e._v("生成"),o("code",[e._v("deferred")]),e._v("对象，转为一个新的"),o("code",[e._v("ES6")]),e._v("的"),o("code",[e._v("Promise")]),e._v("对象")])]),e._v(" "),o("ul",[o("li",[e._v("如果"),o("code",[e._v("Promise.resolve")]),e._v("方法的参数，不是具有"),o("code",[e._v("then")]),e._v("方法的对象（又称"),o("code",[e._v("thenable")]),e._v("对象），则返回一个新的"),o("code",[e._v("Promise")]),e._v("对象，且它的状态为"),o("code",[e._v("fulfilled")]),e._v("。")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("var p = Promise.resolve('Hello');\np.then(function (s){\n  console.log(s)\n});\n// Hello\n")])])]),o("ul",[o("li",[e._v("上面代码生成一个新的"),o("code",[e._v("Promise")]),e._v("对象的实例"),o("code",[e._v("p")]),e._v("，它的状态为"),o("code",[e._v("fulfilled")]),e._v("，所以回调函数会立即执行，"),o("code",[e._v("Promise.resolve")]),e._v("方法的参数就是回调函数的参数")]),e._v(" "),o("li",[e._v("如果"),o("code",[e._v("Promise.resolve")]),e._v("方法的参数是一个"),o("code",[e._v("Promise")]),e._v("对象的实例，则会被原封不动地返回")]),e._v(" "),o("li",[o("code",[e._v("Promise.reject(reason)")]),e._v("方法也会返回一个新的"),o("code",[e._v("Promise")]),e._v("实例，该实例的状态为"),o("code",[e._v("rejected")]),e._v("。"),o("code",[e._v("Promise.reject")]),e._v("方法的参数"),o("code",[e._v("reason")]),e._v("，会被传递给实例的回调函数")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("var p = Promise.reject('出错啦');\np.then(null, function (error){\n  console.log(error)\n});\n// 出错了\n")])])]),o("h3",{attrs:{id:"_1-4-async-await简化写法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-async-await简化写法"}},[e._v("#")]),e._v(" 1.4 Async/await简化写法")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function getDataAsync (url) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            var res = {\n                url: url,\n                data: Math.random()\n            }\n            resolve(res)\n        }, 1000)\n    })\n}\nasync function getData () {\n    var res1 = await getDataAsync('/page/1?param=123')\n    console.log(res1)\n    var res2 = await getDataAsync(`/page/2?param=${res1.data}`)\n    console.log(res2)\n    var res3 = await getDataAsync(`/page/2?param=${res2.data}`)\n    console.log(res3)\n}\n")])])]),o("blockquote",[o("p",[o("code",[e._v("async/await")]),e._v(" 是基于 "),o("code",[e._v("Promise")]),e._v(" 的，因为使用 "),o("code",[e._v("async")]),e._v(" 修饰的方法最终返回一个 "),o("code",[e._v("Promise")]),e._v("， 实际上，"),o("code",[e._v("async/await")]),e._v(" 可以看做是使用 "),o("code",[e._v("Generator")]),e._v(" 函数处理异步的语法糖，我们来看看如何使用 "),o("code",[e._v("Generator")]),e._v(" 函数处理异步")])]),e._v(" "),o("h3",{attrs:{id:"_1-5-generator"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-generator"}},[e._v("#")]),e._v(" 1.5 Generator")]),e._v(" "),o("p",[e._v("首先异步函数依然是：")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function getDataAsync (url) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            var res = {\n                url: url,\n                data: Math.random()\n            }\n            resolve(res)\n        }, 1000)\n    })\n}\n")])])]),o("blockquote",[o("p",[e._v("使用 "),o("code",[e._v("Generator")]),e._v(" 函数可以这样写")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function * getData () {\n    var res1 = yield getDataAsync('/page/1?param=123')\n    console.log(res1)\n    var res2 = yield getDataAsync(`/page/2?param=${res1.data}`)\n    console.log(res2)\n    var res3 = yield getDataAsync(`/page/2?param=${res2.data}`)\n    console.log(res3))\n}\n")])])]),o("p",[e._v("然后我们这样逐步执行")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("var g = getData()\ng.next().value.then(res1 => {\n    g.next(res1).value.then(res2 => {\n        g.next(res2).value.then(() => {\n            g.next()\n        })\n    })\n})\n")])])]),o("blockquote",[o("p",[e._v("上面的代码，我们逐步调用遍历器的 "),o("code",[e._v("next()")]),e._v(" 方法，由于每一个 "),o("code",[e._v("next()")]),e._v(" 方法返回值的 "),o("code",[e._v("value")]),e._v(" 属性为一个 "),o("code",[e._v("Promise")]),e._v(" 对象，所以我们为其添加 "),o("code",[e._v("then")]),e._v(" 方法， 在 "),o("code",[e._v("then")]),e._v("方法里面接着运行 "),o("code",[e._v("next")]),e._v(" 方法挪移遍历器指针，直到 "),o("code",[e._v("Generator")]),e._v(" 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function run (gen) {\n    var g = gen()\n\n    function next (data) {\n        var res = g.next(data)\n        if (res.done) return res.value\n        res.value.then((data) => {\n            next(data)\n        })\n    }\n\n    next()\n\n}\n")])])]),o("blockquote",[o("p",[o("code",[e._v("run")]),e._v("方法用来自动运行异步的 "),o("code",[e._v("Generator")]),e._v(" 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 "),o("code",[e._v("Generator")]),e._v(" 函数了。 有了 "),o("code",[e._v("run")]),e._v(" 方法，我们只需要这样运行 getData 方法")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("run(getData)\n")])])]),o("blockquote",[o("p",[e._v("这样，我们就可以把异步操作封装到 "),o("code",[e._v("Generator")]),e._v(" 函数内部，使用 "),o("code",[e._v("run")]),e._v(" 方法作为 "),o("code",[e._v("Generator")]),e._v(" 函数的自执行器，来处理异步。其实我们不难发现， "),o("code",[e._v("async/await")]),e._v(" 方法相比于 "),o("code",[e._v("Generator")]),e._v(" 处理异步的方式，有很多相似的地方，只不过 "),o("code",[e._v("async/await")]),e._v(" 在语义化方面更加明显，同时 "),o("code",[e._v("async/await")]),e._v(" 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 "),o("code",[e._v("async/await")]),e._v(" 是 "),o("code",[e._v("Generator")]),e._v(" 函数处理异步的语法糖了")])]),e._v(" "),o("h2",{attrs:{id:"二、promise实现原理剖析"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#二、promise实现原理剖析"}},[e._v("#")]),e._v(" 二、Promise实现原理剖析")]),e._v(" "),o("h3",{attrs:{id:"_2-1-promise标准"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-promise标准"}},[e._v("#")]),e._v(" 2.1 Promise标准")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("Promise")]),e._v(" 规范有很多，如"),o("code",[e._v("Promise/A")]),e._v("，"),o("code",[e._v("Promise/B")]),e._v("，"),o("code",[e._v("Promise/D")]),e._v("以及 "),o("code",[e._v("Promise/A")]),e._v(" 的升级版 "),o("code",[e._v("Promise/A+")]),e._v("。"),o("code",[e._v("ES6")]),e._v("中采用了 "),o("code",[e._v("Promise/A+")]),e._v(" 规范")])]),e._v(" "),o("p",[e._v("中文版规范: "),o("a",{attrs:{href:"http://www.ituring.com.cn/article/66566",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promises/A+规范(中文)"),o("OutboundLink")],1)]),e._v(" "),o("p",[o("strong",[e._v("Promise标准解读")])]),e._v(" "),o("ul",[o("li",[e._v("一个"),o("code",[e._v("promise")]),e._v("的当前状态只能是"),o("code",[e._v("pending")]),e._v("、"),o("code",[e._v("fulfilled")]),e._v("和"),o("code",[e._v("rejected")]),e._v("三种之一。状态改变只能是"),o("code",[e._v("pending")]),e._v("到"),o("code",[e._v("fulfilled")]),e._v("或者"),o("code",[e._v("pending")]),e._v("到"),o("code",[e._v("rejected")]),e._v("。状态改变不可逆")]),e._v(" "),o("li",[o("code",[e._v("promise")]),e._v("的"),o("code",[e._v("then")]),e._v("方法接收两个可选参数，表示该"),o("code",[e._v("promise")]),e._v("状态改变时的回调("),o("code",[e._v("promise.then(onFulfilled, onRejected)")]),e._v(")。"),o("code",[e._v("then")]),e._v("方法返回一个"),o("code",[e._v("promise")]),e._v("。"),o("code",[e._v("then")]),e._v(" 方法可以被同一个 "),o("code",[e._v("promise")]),e._v(" 调用多次")])]),e._v(" "),o("h3",{attrs:{id:"_2-2-实现promise"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-实现promise"}},[e._v("#")]),e._v(" 2.2 实现Promise")]),e._v(" "),o("p",[o("strong",[e._v("构造函数")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function Promise(resolver) {}\n")])])]),o("p",[o("strong",[e._v("原型方法")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("Promise.prototype.then = function() {}\nPromise.prototype.catch = function() {}\n")])])]),o("p",[o("strong",[e._v("静态方法")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("Promise.resolve = function() {}\nPromise.reject = function() {}\nPromise.all = function() {}\nPromise.race = function() {}\n")])])]),o("h3",{attrs:{id:"_2-3-极简promise雏形"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-极简promise雏形"}},[e._v("#")]),e._v(" 2.3 极简promise雏形")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function Promise(fn) {\n    var value = null,\n        callbacks = [];  //callbacks为数组，因为可能同时有很多个回调\n    this.then = function (onFulfilled) {\n        callbacks.push(onFulfilled);\n    };\n    function resolve(value) {\n        callbacks.forEach(function (callback) {\n            callback(value);\n        });\n    }\n    fn(resolve);\n}\n")])])]),o("p",[o("strong",[e._v("大致的逻辑是这样的")])]),e._v(" "),o("ul",[o("li",[e._v("调用"),o("code",[e._v("then")]),e._v("方法，将想要在"),o("code",[e._v("Promise")]),e._v("异步操作成功时执行的回调放入"),o("code",[e._v("callbacks")]),e._v("队列，其实也就是注册回调函数，可以向观察者模式方向思考")]),e._v(" "),o("li",[e._v("创建"),o("code",[e._v("Promise")]),e._v("实例时传入的函数会被赋予一个函数类型的参数，即"),o("code",[e._v("resolve")]),e._v("，它接收一个参数"),o("code",[e._v("value")]),e._v("，代表异步操作返回的结果，当一步操作执行成功后，用户会调用"),o("code",[e._v("resolve")]),e._v("方法，这时候其实真正执行的操作是将"),o("code",[e._v("callbacks")]),e._v("队列中的回调一一执行")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("//例1\nfunction getUserId() {\n    return new Promise(function(resolve) {\n        //异步请求\n        http.get(url, function(results) {\n            resolve(results.id)\n        })\n    })\n}\ngetUserId().then(function(id) {\n    //一些处理\n})\n// 结合例子1分析\n\n// fn 就是getUserId函数\nfunction Promise(fn) {\n    var value = null,\n        callbacks = [];  //callbacks为数组，因为可能同时有很多个回调\n    \n    // 当用户调用getUserId().then的时候开始注册传进来的回调函数\n    // onFulfilled就是例子中的function(id){}\n    // 把then的回调函数收集起来 在resolve的时候调用\n    this.then = function (onFulfilled) {\n        callbacks.push(onFulfilled);\n    };\n    \n    // value是fn函数执行后返回的值\n    function resolve(value) {\n        // callbacks是传给then的回调函数就是例子中的function(id){}\n        // 遍历用户通过then传递进来的回调函数把resolve成功的结果返回给then调用即then(function(data){ console.log(data) }) 这里的data就是通过这里调用返回\n        callbacks.forEach(function (callback) {\n            callback(value);\n        });\n    }\n    \n    //执行fn函数即getUserId()并且传入函数参数resolve 当fn执行完成返回的值传递给resolve函数\n    fn(resolve);\n}\n")])])]),o("blockquote",[o("p",[e._v("结合例1中的代码来看，首先"),o("code",[e._v("new Promise")]),e._v("时，传给"),o("code",[e._v("promise")]),e._v("的函数发送异步请求，接着调用"),o("code",[e._v("promise")]),e._v("对象的"),o("code",[e._v("then")]),e._v("属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用"),o("code",[e._v("resolve(results.id)")]),e._v("方法, 该方法执行"),o("code",[e._v("then")]),e._v("方法注册的回调数组")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("then")]),e._v("方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用。想让"),o("code",[e._v("then")]),e._v("方法支持链式调用，其实也是很简单的")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("this.then = function (onFulfilled) {\n    callbacks.push(onFulfilled);\n    return this;\n};\n")])])]),o("blockquote",[o("p",[e._v("只要简单一句话就可以实现类似下面的链式调用")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// 例2\ngetUserId().then(function (id) {\n    // 一些处理\n}).then(function (id) {\n    // 一些处理\n});\n")])])]),o("h3",{attrs:{id:"_2-4-加入延时机制"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-加入延时机制"}},[e._v("#")]),e._v(" 2.4 加入延时机制")]),e._v(" "),o("blockquote",[o("p",[e._v("上述代码可能还存在一个问题：如果在"),o("code",[e._v("then")]),e._v("方法注册回调之前，"),o("code",[e._v("resolve")]),e._v("函数就执行了，怎么办？比如"),o("code",[e._v("promise")]),e._v("内部的函数是同步函数")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// 例3\nfunction getUserId() {\n    return new Promise(function (resolve) {\n        resolve(9876);\n    });\n}\ngetUserId().then(function (id) {\n    // 一些处理\n});\n")])])]),o("blockquote",[o("p",[e._v("这显然是不允许的，"),o("code",[e._v("Promises/A+")]),e._v("规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在"),o("code",[e._v("resolve")]),e._v("执行之前，"),o("code",[e._v("then")]),e._v("方法已经注册完所有的回调。我们可以这样改造下"),o("code",[e._v("resolve")]),e._v("函数:")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function resolve(value) {\n    setTimeout(function() {\n        callbacks.forEach(function (callback) {\n            callback(value);\n        });\n    }, 0)\n}\n")])])]),o("blockquote",[o("p",[e._v("上述代码的思路也很简单，就是通过"),o("code",[e._v("setTimeout")]),e._v("机制，将"),o("code",[e._v("resolve")]),e._v("中执行回调的逻辑放置到"),o("code",[e._v("JS")]),e._v("任务队列末尾，以保证在"),o("code",[e._v("resolve")]),e._v("执行时，"),o("code",[e._v("then")]),e._v("方法的回调函数已经注册完成")])]),e._v(" "),o("ul",[o("li",[e._v("但是，这样好像还存在一个问题，可以细想一下：如果"),o("code",[e._v("Promise")]),e._v("异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在"),o("code",[e._v("Promise")]),e._v("异步操作成功这之后调用的"),o("code",[e._v("then")]),e._v("注册的回调就再也不会执行了，这显然不是我们想要的")])]),e._v(" "),o("h3",{attrs:{id:"_2-5-加入状态"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-加入状态"}},[e._v("#")]),e._v(" 2.5 加入状态")]),e._v(" "),o("p",[e._v("我们必须加入状态机制，也就是大家熟知的"),o("code",[e._v("pending")]),e._v("、"),o("code",[e._v("fulfilled")]),e._v("、"),o("code",[e._v("rejected")])]),e._v(" "),o("blockquote",[o("p",[o("code",[e._v("Promises/A+")]),e._v("规范中的"),o("code",[e._v("2.1 Promise States")]),e._v("中明确规定了，"),o("code",[e._v("pending")]),e._v("可以转化为"),o("code",[e._v("fulfilled")]),e._v("或"),o("code",[e._v("rejected")]),e._v("并且只能转化一次，也就是说如果"),o("code",[e._v("pending")]),e._v("转化到"),o("code",[e._v("fulfilled")]),e._v("状态，那么就不能再转化到r"),o("code",[e._v("ejected")]),e._v("。并且"),o("code",[e._v("fulfilled")]),e._v("和"),o("code",[e._v("rejected")]),e._v("状态只能由"),o("code",[e._v("pending")]),e._v("转化而来，两者之间不能互相转换")])]),e._v(" "),o("p",[o("img",{attrs:{src:"https://mengera88.github.io/images/promiseState.png",alt:"img"}})]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("//改进后的代码是这样的：\n\nfunction Promise(fn) {\n    var state = 'pending',\n        value = null,\n        callbacks = [];\n    this.then = function (onFulfilled) {\n        if (state === 'pending') {\n            callbacks.push(onFulfilled);\n            return this;\n        }\n        onFulfilled(value);\n        return this;\n    };\n    function resolve(newValue) {\n        value = newValue;\n        state = 'fulfilled';\n        setTimeout(function () {\n            callbacks.forEach(function (callback) {\n                callback(value);\n            });\n        }, 0);\n    }\n    fn(resolve);\n}\n")])])]),o("blockquote",[o("p",[e._v("上述代码的思路是这样的："),o("code",[e._v("resolve")]),e._v("执行时，会将状态设置为"),o("code",[e._v("fulfilled")]),e._v("，在此之后调用"),o("code",[e._v("then")]),e._v("添加的新回调，都会立即执行")])]),e._v(" "),o("h3",{attrs:{id:"_2-6-链式promise"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-链式promise"}},[e._v("#")]),e._v(" 2.6 链式Promise")]),e._v(" "),o("blockquote",[o("p",[e._v("如果用户在"),o("code",[e._v("then")]),e._v("函数里面注册的仍然是一个"),o("code",[e._v("Promise")]),e._v("，该如何解决？比如下面的例4")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// 例4\ngetUserId()\n    .then(getUserJobById)\n    .then(function (job) {\n        // 对job的处理\n    });\nfunction getUserJobById(id) {\n    return new Promise(function (resolve) {\n        http.get(baseUrl + id, function(job) {\n            resolve(job);\n        });\n    });\n}\n")])])]),o("ul",[o("li",[e._v("这种场景相信用过"),o("code",[e._v("promise")]),e._v("的人都知道会有很多，那么类似这种就是所谓的链式"),o("code",[e._v("Promise")])]),e._v(" "),o("li",[e._v("链式"),o("code",[e._v("Promise")]),e._v("是指在当前"),o("code",[e._v("promise")]),e._v("达到"),o("code",[e._v("fulfilled")]),e._v("状态后，即开始进行下一个"),o("code",[e._v("promise")]),e._v("（后邻"),o("code",[e._v("promise")]),e._v("）。那么我们如何衔接当前"),o("code",[e._v("promise")]),e._v("和后邻"),o("code",[e._v("promise")]),e._v("呢？（这是这里的难点")]),e._v(" "),o("li",[e._v("只要在"),o("code",[e._v("then")]),e._v("方法里面"),o("code",[e._v("return")]),e._v("一个"),o("code",[e._v("promise")]),e._v("就好啦。"),o("code",[e._v("Promises/A+")]),e._v("规范中的"),o("code",[e._v("2.2.7")]),e._v("就是这样")])]),e._v(" "),o("blockquote",[o("p",[e._v("下面来看看这段暗藏玄机的"),o("code",[e._v("then")]),e._v("方法和"),o("code",[e._v("resolve")]),e._v("方法改造代码")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function Promise(fn) {\n    var state = 'pending',\n        value = null,\n        callbacks = [];\n    this.then = function (onFulfilled) {\n        return new Promise(function (resolve) {\n            handle({\n                onFulfilled: onFulfilled || null,\n                resolve: resolve\n            });\n        });\n    };\n    function handle(callback) {\n        if (state === 'pending') {\n            callbacks.push(callback);\n            return;\n        }\n        //如果then中没有传递任何东西\n        if(!callback.onFulfilled) {\n            callback.resolve(value);\n            return;\n        }\n        var ret = callback.onFulfilled(value);\n        callback.resolve(ret);\n    }\n    \n    function resolve(newValue) {\n        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n            var then = newValue.then;\n            if (typeof then === 'function') {\n                then.call(newValue, resolve);\n                return;\n            }\n        }\n        state = 'fulfilled';\n        value = newValue;\n        setTimeout(function () {\n            callbacks.forEach(function (callback) {\n                handle(callback);\n            });\n        }, 0);\n    }\n    fn(resolve);\n}\n")])])]),o("blockquote",[o("p",[e._v("我们结合例4的代码，分析下上面的代码逻辑，为了方便阅读，我把例4的代码贴在这里")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("// 例4\ngetUserId()\n    .then(getUserJobById)\n    .then(function (job) {\n        // 对job的处理\n    });\nfunction getUserJobById(id) {\n    return new Promise(function (resolve) {\n        http.get(baseUrl + id, function(job) {\n            resolve(job);\n        });\n    });\n}\n")])])]),o("ul",[o("li",[o("code",[e._v("then")]),e._v("方法中，创建并返回了新的"),o("code",[e._v("Promise")]),e._v("实例，这是串行"),o("code",[e._v("Promis")]),e._v("e的基础，并且支持链式调用")]),e._v(" "),o("li",[o("code",[e._v("handle")]),e._v("方法是"),o("code",[e._v("promise")]),e._v("内部的方法。"),o("code",[e._v("then")]),e._v("方法传入的形参"),o("code",[e._v("onFulfilled")]),e._v("以及创建新"),o("code",[e._v("Promise")]),e._v("实例时传入的"),o("code",[e._v("resolve")]),e._v("均被"),o("code",[e._v("push")]),e._v("到当前"),o("code",[e._v("promise")]),e._v("的"),o("code",[e._v("callbacks")]),e._v("队列中，这是衔接当前"),o("code",[e._v("promise")]),e._v("和后邻"),o("code",[e._v("promise")]),e._v("的关键所在")]),e._v(" "),o("li",[o("code",[e._v("getUserId")]),e._v("生成的"),o("code",[e._v("promise")]),e._v("（简称"),o("code",[e._v("getUserId promise")]),e._v("）异步操作成功，执行其内部方法"),o("code",[e._v("resolve")]),e._v("，传入的参数正是异步操作的结果"),o("code",[e._v("id")])]),e._v(" "),o("li",[e._v("调用"),o("code",[e._v("handle")]),e._v("方法处理"),o("code",[e._v("callbacks")]),e._v("队列中的回调："),o("code",[e._v("getUserJobById")]),e._v("方法，生成新的"),o("code",[e._v("promise")]),e._v("（g"),o("code",[e._v("etUserJobById promise")]),e._v("）")]),e._v(" "),o("li",[e._v("执行之前由"),o("code",[e._v("getUserId promise")]),e._v("的"),o("code",[e._v("then")]),e._v("方法生成的新"),o("code",[e._v("promise")]),e._v("(称为"),o("code",[e._v("bridge promise")]),e._v(")的"),o("code",[e._v("resolve")]),e._v("方法，传入参数为"),o("code",[e._v("getUserJobById promise")]),e._v("。这种情况下，会将该"),o("code",[e._v("resolve")]),e._v("方法传入"),o("code",[e._v("getUserJobById promise")]),e._v("的"),o("code",[e._v("then")]),e._v("方法中，并直接返回")]),e._v(" "),o("li",[e._v("在"),o("code",[e._v("getUserJobById promise")]),e._v("异步操作成功时，执行其"),o("code",[e._v("callbacks")]),e._v("中的回调："),o("code",[e._v("getUserId bridge promise")]),e._v("中的"),o("code",[e._v("resolve")]),e._v("方法")]),e._v(" "),o("li",[e._v("最后执行"),o("code",[e._v("getUserId bridge promise")]),e._v("的后邻"),o("code",[e._v("promise")]),e._v("的"),o("code",[e._v("callbacks")]),e._v("中的回调")])]),e._v(" "),o("h3",{attrs:{id:"_2-7-失败处理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-失败处理"}},[e._v("#")]),e._v(" 2.7 失败处理")]),e._v(" "),o("blockquote",[o("p",[e._v("在异步操作失败时，标记其状态为"),o("code",[e._v("rejected")]),e._v("，并执行注册的失败回调")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("//例5\nfunction getUserId() {\n    return new Promise(function(resolve) {\n        //异步请求\n        http.get(url, function(error, results) {\n            if (error) {\n                reject(error);\n            }\n            resolve(results.id)\n        })\n    })\n}\ngetUserId().then(function(id) {\n    //一些处理\n}, function(error) {\n    console.log(error)\n})\n")])])]),o("blockquote",[o("p",[e._v("有了之前处理"),o("code",[e._v("fulfilled")]),e._v("状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function Promise(fn) {\n    var state = 'pending',\n        value = null,\n        callbacks = [];\n    this.then = function (onFulfilled, onRejected) {\n        return new Promise(function (resolve, reject) {\n            handle({\n                onFulfilled: onFulfilled || null,\n                onRejected: onRejected || null,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n    };\n    function handle(callback) {\n        if (state === 'pending') {\n            callbacks.push(callback);\n            return;\n        }\n        var cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected,\n            ret;\n        if (cb === null) {\n            cb = state === 'fulfilled' ? callback.resolve : callback.reject;\n            cb(value);\n            return;\n        }\n        ret = cb(value);\n        callback.resolve(ret);\n    }\n    function resolve(newValue) {\n        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n            var then = newValue.then;\n            if (typeof then === 'function') {\n                then.call(newValue, resolve, reject);\n                return;\n            }\n        }\n        state = 'fulfilled';\n        value = newValue;\n        execute();\n    }\n    function reject(reason) {\n        state = 'rejected';\n        value = reason;\n        execute();\n    }\n    function execute() {\n        setTimeout(function () {\n            callbacks.forEach(function (callback) {\n                handle(callback);\n            });\n        }, 0);\n    }\n    fn(resolve, reject);\n}\n")])])]),o("blockquote",[o("p",[e._v("上述代码增加了新的"),o("code",[e._v("reject")]),e._v("方法，供异步操作失败时调用，同时抽出了"),o("code",[e._v("resolve")]),e._v("和"),o("code",[e._v("reject")]),e._v("共用的部分，形成"),o("code",[e._v("execute")]),e._v("方法")])]),e._v(" "),o("p",[e._v("错误冒泡是上述代码已经支持，且非常实用的一个特性。在"),o("code",[e._v("handle")]),e._v("中发现没有指定异步操作失败的回调时，会直接将"),o("code",[e._v("bridge promise")]),e._v("("),o("code",[e._v("then")]),e._v("函数返回的"),o("code",[e._v("promise")]),e._v("，后同)设为"),o("code",[e._v("rejected")]),e._v("状态，如此达成执行后续失败回调的效果。这有利于简化串行Promise的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("//例6\ngetUserId()\n    .then(getUserJobById)\n    .then(function (job) {\n        // 处理job\n    }, function (error) {\n        // getUserId或者getUerJobById时出现的错误\n        console.log(error);\n    });\n")])])]),o("h3",{attrs:{id:"_2-8-异常处理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-异常处理"}},[e._v("#")]),e._v(" 2.8 异常处理")]),e._v(" "),o("blockquote",[o("p",[e._v("如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用"),o("code",[e._v("try-catch")]),e._v("捕获错误，并将"),o("code",[e._v("bridge promise")]),e._v("设为"),o("code",[e._v("rejected")]),e._v("状态。"),o("code",[e._v("handle")]),e._v("方法改造如下")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function handle(callback) {\n    if (state === 'pending') {\n        callbacks.push(callback);\n        return;\n    }\n    var cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected,\n        ret;\n    if (cb === null) {\n        cb = state === 'fulfilled' ? callback.resolve : callback.reject;\n        cb(value);\n        return;\n    }\n    try {\n        ret = cb(value);\n        callback.resolve(ret);\n    } catch (e) {\n        callback.reject(e);\n    } \n}\n")])])]),o("blockquote",[o("p",[e._v("如果在异步操作中，多次执行"),o("code",[e._v("resolve")]),e._v("或者"),o("code",[e._v("reject")]),e._v("会重复处理后续回调，可以通过内置一个标志位解决")])]),e._v(" "),o("h3",{attrs:{id:"_2-9-完整实现"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-9-完整实现"}},[e._v("#")]),e._v(" 2.9 完整实现")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('// 三种状态\nconst PENDING = "pending";\nconst RESOLVED = "resolved";\nconst REJECTED = "rejected";\n// promise 接收一个函数参数，该函数会立即执行\nfunction MyPromise(fn) {\n  let _this = this;\n  _this.currentState = PENDING;\n  _this.value = undefined;\n  // 用于保存 then 中的回调，只有当 promise\n  // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n  _this.resolvedCallbacks = [];\n  _this.rejectedCallbacks = [];\n\n  _this.resolve = function (value) {\n    if (value instanceof MyPromise) {\n      // 如果 value 是个 Promise，递归执行\n      return value.then(_this.resolve, _this.reject)\n    }\n    setTimeout(() => { // 异步执行，保证执行顺序\n      if (_this.currentState === PENDING) {\n        _this.currentState = RESOLVED;\n        _this.value = value;\n        _this.resolvedCallbacks.forEach(cb => cb());\n      }\n    })\n  };\n\n  _this.reject = function (reason) {\n    setTimeout(() => { // 异步执行，保证执行顺序\n      if (_this.currentState === PENDING) {\n        _this.currentState = REJECTED;\n        _this.value = reason;\n        _this.rejectedCallbacks.forEach(cb => cb());\n      }\n    })\n  }\n  // 用于解决以下问题\n  // new Promise(() => throw Error(\'error))\n  try {\n    fn(_this.resolve, _this.reject);\n  } catch (e) {\n    _this.reject(e);\n  }\n}\n\nMyPromise.prototype.then = function (onResolved, onRejected) {\n  var self = this;\n  // 规范 2.2.7，then 必须返回一个新的 promise\n  var promise2;\n  // 规范 2.2.onResolved 和 onRejected 都为可选参数\n  // 如果类型不是函数需要忽略，同时也实现了透传\n  // Promise.resolve(4).then().then((value) => console.log(value))\n  onResolved = typeof onResolved === \'function\' ? onResolved : v => v;\n  onRejected = typeof onRejected === \'function\' ? onRejected : r => throw r;\n\n  if (self.currentState === RESOLVED) {\n    return (promise2 = new MyPromise(function (resolve, reject) {\n      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行\n      // 所以用了 setTimeout 包裹下\n      setTimeout(function () {\n        try {\n          var x = onResolved(self.value);\n          resolutionProcedure(promise2, x, resolve, reject);\n        } catch (reason) {\n          reject(reason);\n        }\n      });\n    }));\n  }\n\n  if (self.currentState === REJECTED) {\n    return (promise2 = new MyPromise(function (resolve, reject) {\n      setTimeout(function () {\n        // 异步执行onRejected\n        try {\n          var x = onRejected(self.value);\n          resolutionProcedure(promise2, x, resolve, reject);\n        } catch (reason) {\n          reject(reason);\n        }\n      });\n    }));\n  }\n\n  if (self.currentState === PENDING) {\n    return (promise2 = new MyPromise(function (resolve, reject) {\n      self.resolvedCallbacks.push(function () {\n        // 考虑到可能会有报错，所以使用 try/catch 包裹\n        try {\n          var x = onResolved(self.value);\n          resolutionProcedure(promise2, x, resolve, reject);\n        } catch (r) {\n          reject(r);\n        }\n      });\n\n      self.rejectedCallbacks.push(function () {\n        try {\n          var x = onRejected(self.value);\n          resolutionProcedure(promise2, x, resolve, reject);\n        } catch (r) {\n          reject(r);\n        }\n      });\n    }));\n  }\n};\n// 规范 2.3\nfunction resolutionProcedure(promise2, x, resolve, reject) {\n  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用\n  if (promise2 === x) {\n    return reject(new TypeError("Error"));\n  }\n  // 规范 2.3.2\n  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行\n  if (x instanceof MyPromise) {\n    if (x.currentState === PENDING) {\n      x.then(function (value) {\n        // 再次调用该函数是为了确认 x resolve 的\n        // 参数是什么类型，如果是基本类型就再次 resolve\n        // 把值传给下个 then\n        resolutionProcedure(promise2, value, resolve, reject);\n      }, reject);\n    } else {\n      x.then(resolve, reject);\n    }\n    return;\n  }\n  // 规范 2.3.3.3.3\n  // reject 或者 resolve 其中一个执行过得话，忽略其他的\n  let called = false;\n  // 规范 2.3.3，判断 x 是否为对象或者函数\n  if (x !== null && (typeof x === "object" || typeof x === "function")) {\n    // 规范 2.3.3.2，如果不能取出 then，就 reject\n    try {\n      // 规范 2.3.3.1\n      let then = x.then;\n      // 如果 then 是函数，调用 x.then\n      if (typeof then === "function") {\n        // 规范 2.3.3.3\n        then.call(\n          x,\n          y => {\n            if (called) return;\n            called = true;\n            // 规范 2.3.3.3.1\n            resolutionProcedure(promise2, y, resolve, reject);\n          },\n          e => {\n            if (called) return;\n            called = true;\n            reject(e);\n          }\n        );\n      } else {\n        // 规范 2.3.3.4\n        resolve(x);\n      }\n    } catch (e) {\n      if (called) return;\n      called = true;\n      reject(e);\n    }\n  } else {\n    // 规范 2.3.4，x 为基本类型\n    resolve(x);\n  }\n}\n')])])]),o("h3",{attrs:{id:"_2-10-小结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-10-小结"}},[e._v("#")]),e._v(" 2.10 小结")]),e._v(" "),o("p",[o("strong",[e._v("这里一定要注意的点是")]),e._v("："),o("code",[e._v("promise")]),e._v("里面的"),o("code",[e._v("then")]),e._v("函数仅仅是注册了后续需要执行的代码，真正的执行是在"),o("code",[e._v("resolve")]),e._v("方法里面执行的，理清了这层，再来分析源码会省力的多")]),e._v(" "),o("blockquote",[o("p",[e._v("现在回顾下"),o("code",[e._v("Promise")]),e._v("的实现过程，其主要使用了设计模式中的观察者模式")])]),e._v(" "),o("ul",[o("li",[e._v("通过"),o("code",[e._v("Promise.prototype.then")]),e._v("和"),o("code",[e._v("Promise.prototype.catch")]),e._v("方法将观察者方法注册到被观察者"),o("code",[e._v("Promise")]),e._v("对象中，同时返回一个新的"),o("code",[e._v("Promise")]),e._v("对象，以便可以链式调用")]),e._v(" "),o("li",[e._v("被观察者管理内部"),o("code",[e._v("pending")]),e._v("、"),o("code",[e._v("fulfilled")]),e._v("和"),o("code",[e._v("rejected")]),e._v("的状态转变，同时通过构造函数中传递的"),o("code",[e._v("resolve")]),e._v("和"),o("code",[e._v("reject")]),e._v("方法以主动触发状态转变和通知观察者")])])])}),[],!1,null,null,null);n.default=r.exports}}]);