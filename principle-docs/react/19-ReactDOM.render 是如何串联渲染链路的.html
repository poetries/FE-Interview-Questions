<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试指南</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/FE-Interview-Questions/logo.png">
    <link rel="manifest" href="/FE-Interview-Questions/manifest.json">
    <link rel="apple-touch-icon" href="/FE-Interview-Questions/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/FE-Interview-Questions/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="web前端面试题总结，面试指南，前端面试题整理，web面试宝典，刷题神器，按模块分类整理总结，打造最全面的前端面试题">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/FE-Interview-Questions/assets/css/0.styles.f26b5f0f.css" as="style"><link rel="preload" href="/FE-Interview-Questions/assets/js/app.c7c92663.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/5.ef81f1b0.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/4.1c7c0871.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/118.ce1cbacb.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/11.3e5297f1.js" as="script"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/1.e6248e56.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/10.c76d9920.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/100.f9c899d2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/101.64e615c6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/102.399345d2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/103.9323811c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/104.6af2cf73.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/105.1f857fd0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/106.df333aa0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/107.3ddce516.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/108.4820d5b5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/109.2ad6b050.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/110.dfdec650.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/111.968ab790.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/112.771c16d0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/113.ebfae00f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/114.44224f87.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/115.b6926b4c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/116.83044ed8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/117.9ce579a8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/119.d9686309.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/12.11b7ac22.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/120.143426bc.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/121.f76e0277.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/122.b406c5b0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/123.aaacf72d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/124.0aad522a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/125.bcfd6ea3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/126.12a1a4bb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/127.408c9288.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/128.aa9140a9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/129.f0a33fab.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/13.dc3c7c04.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/130.309d2508.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/131.391cc395.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/132.d5ce339b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/133.816be977.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/134.d836fe3f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/135.0f0fe7ac.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/136.8f192c00.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/137.8f7a9f4f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/138.29c4422a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/139.f39225fa.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/14.6ab36fa5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/140.ea981825.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/141.5c138705.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/15.a6d0032e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/16.6094fda8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/17.5b169955.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/18.0341abc9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/19.9fa6e2c6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/20.92742304.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/21.28c8a661.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/22.3222a772.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/23.8192ecea.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/24.b5156b88.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/25.034d5e81.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/26.c78d8f63.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/27.cd94c89c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/28.b2c8e24c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/29.e9a30c2c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/3.82699565.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/30.2bd67425.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/31.6333035e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/32.1a34dfa0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/33.b5863ac0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/34.cababd6c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/35.0b09d4a2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/36.8f89ed73.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/37.38d590c3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/38.4799c402.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/39.c9d13f25.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/40.b3f0307e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/41.16e0641a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/42.9ce6fd83.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/43.a59bc2c2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/44.5ebdd233.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/45.afcf0d33.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/46.b6f1380b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/47.4a9a713e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/48.a31741eb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/49.06a1d27b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/50.5d785b9d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/51.84fe2d66.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/52.6ff2b7c5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/53.003482ca.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/54.2cbd9f91.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/55.c08355c1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/56.3a1e3c24.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/57.c3c2e05a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/58.f1ca8c6e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/59.6c96ed96.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/6.db1b3cb7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/60.bca0262d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/61.f95a2296.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/62.d8e4be2c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/63.df53bdf6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/64.49010103.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/65.4adf538d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/66.610396dd.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/67.0a26df5e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/68.220a258f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/69.b8e2ca21.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/7.4f359fae.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/70.de16f056.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/71.b5805c52.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/72.0b9ee279.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/73.06a7014e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/74.867ad109.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/75.d27fb245.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/76.3513c4b3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/77.68845809.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/78.950f8c33.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/79.a2d99a1f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/8.b6777e86.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/80.210e9842.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/81.527711d7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/82.89676520.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/83.c4bcb8dc.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/84.4a8e090b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/85.f1720b60.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/86.4f2c39c8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/87.dc404ea3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/88.3d4ddb45.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/89.bcf90917.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/9.31237659.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/90.ce501cc3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/91.2e38302a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/92.6de24981.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/93.fdc7226c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/94.ed86d201.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/95.f459d0e7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/96.9df52cea.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/97.fe804b0e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/98.134b4c27.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/99.01decbbf.js">
    <link rel="stylesheet" href="/FE-Interview-Questions/assets/css/0.styles.f26b5f0f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/FE-Interview-Questions/" class="home-link router-link-active"><img src="/FE-Interview-Questions/logo.png" alt="面试指南" class="logo"> <span class="site-name can-hide">面试指南</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!----> <div style="padding-left:1.5rem;"><div class="qr"><img src="/FE-Interview-Questions/assets/img/qr.ee193d28.jpg" alt="poetries" width="120" height="120" loading="lazy"> <p class="we-intro">
    关注公众号，获取更多资讯
  </p></div></div> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/vue/01-从源码解读Vue生命周期.html" class="sidebar-link">从源码解读Vue生命周期</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/02-组件的本质.html" class="sidebar-link">组件的本质</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/03-有状态组件的设计.html" class="sidebar-link">有状态组件的设计</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/04-设计 VNode.html" class="sidebar-link">设计 VNode</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/05-辅助创建 VNode 的 h 函数.html" class="sidebar-link">辅助创建 VNode 的 h 函数</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/06-自定义渲染器和异步渲染.html" class="sidebar-link">自定义渲染器和异步渲染</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/07-渲染器之挂载.html" class="sidebar-link">渲染器之挂载</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/08-渲染器的核心 Diff 算法.html" class="sidebar-link">渲染器的核心 Diff 算法</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/09-渲染器之patch.html" class="sidebar-link">渲染器之patch</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/10-图解 Vue 响应式原理.html" class="sidebar-link">图解 Vue 响应式原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/11-图解 Vue 异步更新.html" class="sidebar-link">图解 Vue 异步更新</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/12-剖析 Vue 内部运行机制.html" class="sidebar-link">剖析 Vue 内部运行机制</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/13-vue响应式原理模拟.html" class="sidebar-link">vue响应式原理模拟</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/14-vue状态管理之vuex.html" class="sidebar-link">vue状态管理之vuex</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/react/01-React router原理.html" class="sidebar-link">React router原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/02-Dva总结.html" class="sidebar-link">Dva总结</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/03-MobX总结.html" class="sidebar-link">MobX总结</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/04-浅析redux saga中间件及用法.html" class="sidebar-link">浅析redux saga中间件及用法</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/05-Redux之浅析中间件.html" class="sidebar-link">Redux之浅析中间件</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/06-Redux之源码分析.html" class="sidebar-link">Redux之源码分析</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/07-Redux之异步Action及操作.html" class="sidebar-link">Redux之异步Action及操作</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/08-浅析中间件.html" class="sidebar-link">浅析中间件</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/09-react结合redux实战.html" class="sidebar-link">react结合redux实战</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/10-Immutable总结.html" class="sidebar-link">Immutable总结</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/11-React16为什么要更改生命周期(上).html" class="sidebar-link">React16为什么要更改生命周期(上)</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/12-React16为什么要更改生命周期(下).html" class="sidebar-link">React16为什么要更改生命周期(下)</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/13-React Hooks 设计动机与工作模式.html" class="sidebar-link">React Hooks 设计动机与工作模式</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/14-深入 React Hooks 工作机制.html" class="sidebar-link">深入 React Hooks 工作机制</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/15-真正理解虚拟 DOM.html" class="sidebar-link">真正理解虚拟 DOM</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/16-React 中的“栈调和” Stack Reconciler 过程是怎样的.html" class="sidebar-link">React 中的“栈调和” Stack Reconciler 过程是怎样的</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/17-setState 到底是同步的，还是异步的.html" class="sidebar-link">setState 到底是同步的，还是异步的</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/18-如何理解 Fiber 架构的迭代动机与设计思想.html" class="sidebar-link">如何理解 Fiber 架构的迭代动机与设计思想</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html" class="active sidebar-link">ReactDOM.render 是如何串联渲染链路的</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#一、reactdom-render-调用栈的逻辑分层" class="sidebar-link">一、ReactDOM.render 调用栈的逻辑分层</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#二、初始化阶段" class="sidebar-link">二、初始化阶段</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#拆解-reactdom-render-调用栈-初始化阶段" class="sidebar-link">拆解 ReactDOM.render 调用栈——初始化阶段</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#同步的-reactdom-render-异步的-reactdom-createroot" class="sidebar-link">同步的 ReactDOM.render，异步的 ReactDOM.createRoot</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#拓展-关于异步模式下的首次渲染链路" class="sidebar-link">拓展：关于异步模式下的首次渲染链路</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#fiber-架构一定是异步渲染吗" class="sidebar-link">Fiber 架构一定是异步渲染吗？</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#三、render-阶段" class="sidebar-link">三、render 阶段</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#拆解-reactdom-render-调用栈-render-阶段" class="sidebar-link">拆解 ReactDOM.render 调用栈——render 阶段</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#workinprogress-节点的创建" class="sidebar-link">workInProgress 节点的创建</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#beginwork-开启-fiber-节点创建过程" class="sidebar-link">beginWork 开启 Fiber 节点创建过程</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#childreconciler-处理-fiber-节点的幕后-操盘手" class="sidebar-link">ChildReconciler，处理 Fiber 节点的幕后“操盘手”</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#fiber-节点的创建过程梳理" class="sidebar-link">Fiber 节点的创建过程梳理</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#fiber-树的构建过程" class="sidebar-link">Fiber 树的构建过程</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#循环创建新的-fiber-节点" class="sidebar-link">循环创建新的 Fiber 节点</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#fiber-节点间是如何连接的呢" class="sidebar-link">Fiber 节点间是如何连接的呢</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html#四、commit-阶段" class="sidebar-link">四、commit 阶段</a></li></ul></li><li><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html" class="sidebar-link">剖析 Fiber 架构下 Concurrent 模式的实现原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/21-React 事件与 DOM 事件有何不同.html" class="sidebar-link">React 事件与 DOM 事件有何不同</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/22-揭秘 Redux 设计思想与工作原理.html" class="sidebar-link">揭秘 Redux 设计思想与工作原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/23-从 Redux 中间件实现原理切入，理解“面向切面编程”.html" class="sidebar-link">从 Redux 中间件实现原理切入，理解“面向切面编程”</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/24-如何打造高性能的 React 应用.html" class="sidebar-link">如何打造高性能的 React 应用</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/25-跟 React 学设计模式.html" class="sidebar-link">跟 React 学设计模式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/webpack/01-Webpack4打包机制原理解析.html" class="sidebar-link">Webpack4打包机制原理解析</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/02-webpack中的HMR热更新原理剖析.html" class="sidebar-link">webpack中的HMR热更新原理剖析</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/03-从源码窥探Webpack4.x原理.html" class="sidebar-link">从源码窥探Webpack4.x原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/04-实现webpack小型打包工具.html" class="sidebar-link">实现webpack小型打包工具</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/05-Babel原理及其使用.html" class="sidebar-link">Babel原理及其使用</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/node/01-Node事件循环机制原理.html" class="sidebar-link">Node事件循环机制原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/node/02-express详细使用.html" class="sidebar-link">express详细使用</a></li><li><a href="/FE-Interview-Questions/principle-docs/node/03-koa基本用法.html" class="sidebar-link">koa基本用法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>综合</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/01-虚拟DOM原理分析.html" class="sidebar-link">虚拟DOM原理分析</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/02-setTimeout实现原理和使用注意.html" class="sidebar-link">setTimeout实现原理和使用注意</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/03-浅析Promise原理.html" class="sidebar-link">浅析Promise原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/04-浏览器渲染原理.html" class="sidebar-link">浏览器渲染原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/05-前端面试之MVVM浅析.html" class="sidebar-link">前端面试之MVVM浅析</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/06-前端面试之组件化.html" class="sidebar-link">前端面试之组件化</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/07-虚拟DOM（一）.html" class="sidebar-link">虚拟DOM（一）</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/08-虚拟DOM（二）.html" class="sidebar-link">虚拟DOM（二）</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/09-前端性能之Performance.html" class="sidebar-link">前端性能之Performance</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/10-小程序开发实践.html" class="sidebar-link">小程序开发实践</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/11-对比 Koa 和 Redux-分析前端中的中间件理念.html" class="sidebar-link">对比 Koa 和 Redux</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/12-正则完整篇.html" class="sidebar-link">正则完整篇</a></li></ul></section></li></ul> </aside> <main class="page"> <div id="container" class="theme-default-content lock"><div class="content__default"><p>从本讲开始，我们将以首次渲染为切入点，拆解 Fiber 架构下 <code>ReactDOM.render</code> 所触发的渲染链路，结合源码理解整个链路中所涉及的初始化、<code>render 和 commit</code> 等过程</p> <h2 id="一、reactdom-render-调用栈的逻辑分层"><a href="#一、reactdom-render-调用栈的逻辑分层" class="header-anchor">#</a> 一、ReactDOM.render 调用栈的逻辑分层</h2> <p>开篇先给到你一个简单的 React AppDemo：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">&quot;react-dom&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第一段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第二段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> rootElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rootElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Demo 启动后，渲染出的界面如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501195335.png" alt=""></p> <p>现在请你打开 Chrome 的 <code>Performance</code> 面板，点击下图红色圈圈所圈住的这个“记录”按钮：</p> <p><img src="http://img-repo.poetries.top/images/20210501195353.png" alt=""></p> <p>然后重新访问 Demo 页面对应的本地服务地址，待页面刷新后，终止记录，便能够得到如下图右下角所示的这样一个调用栈大图：</p> <p><img src="http://img-repo.poetries.top/images/20210501195414.png" alt=""></p> <p>放大该图，定位“<code>src/index.js</code>”这个文件路径，我们就可以找到 <code>ReactDOM.render</code> 方法对应的调用栈，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501195521.png" alt=""></p> <p>从图中你可以看到，<code>ReactDOM.render</code> 方法对应的调用栈非常深，中间涉及的函数量也比较大。如果这张图使你心里发虚，请先不要急于撤退——分析调用栈只是我们理解渲染链路的一个手段，我们的目的是借此提取关键逻辑，而非理解调用栈中的每一个方法。就这张图来说，你首先需要把握的，就是整个调用链路中所包含的三个阶段</p> <p><img src="http://img-repo.poetries.top/images/20210501195705.png" alt=""></p> <p>图中 <code>scheduleUpdateOnFiber</code> 方法的作用是调度更新，在由 <code>ReactDOM.render</code> 发起的首屏渲染这个场景下，它触发的就是 <code>performSyncWorkOnRoot</code>。<code>performSyncWorkOnRoot</code> 开启的正是我们反复强调的 <strong>render 阶段</strong>；而 <code>commitRoot</code> 方法开启的则是真实 DOM 的渲染过程（<strong>commit 阶段</strong>）。因此以 <code>scheduleUpdateOnFiber</code> 和 <code>commitRoot</code> 两个方法为界，我们可以大致把 <code>ReactDOM.render</code> 的调用栈划分为三个阶段：</p> <ul><li>初始化阶段</li> <li><code>render</code> 阶段</li> <li><code>commit</code> 阶段</li></ul> <h2 id="二、初始化阶段"><a href="#二、初始化阶段" class="header-anchor">#</a> 二、初始化阶段</h2> <h3 id="拆解-reactdom-render-调用栈-初始化阶段"><a href="#拆解-reactdom-render-调用栈-初始化阶段" class="header-anchor">#</a> 拆解 ReactDOM.render 调用栈——初始化阶段</h3> <p>首先我们提取出初始化过程中涉及的调用栈大图：</p> <p><img src="http://img-repo.poetries.top/images/20210501200309.png" alt=""></p> <p>图中的方法虽然看上去又多又杂，但做的事情清清爽爽，那就是<code>完成 Fiber 树中基本实体的创建</code>。</p> <p>什么是基本实体？基本实体有哪些？问题的答案藏在源码里，这里我为你提取了源码中的关键逻辑，首先是 <code>legacyRenderSubtreeIntoContainer</code> 方法。在 <code>ReactDOM.render</code> 函数体中，以下面代码所示的姿势调用了它：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token function">legacyRenderSubtreeIntoContainer</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> element<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而 <code>legacyRenderSubtreeIntoContainer</code> 的关键逻辑如下（解析在注释里）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">legacyRenderSubtreeIntoContainer</span><span class="token punctuation">(</span><span class="token parameter">parentComponent<span class="token punctuation">,</span> children<span class="token punctuation">,</span> container<span class="token punctuation">,</span> forceHydrate<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// container 对应的是我们传入的真实 DOM 对象</span>
  <span class="token keyword">var</span> root <span class="token operator">=</span> container<span class="token punctuation">.</span>_reactRootContainer<span class="token punctuation">;</span>
  <span class="token comment">// 初始化 fiberRoot 对象</span>
  <span class="token keyword">var</span> fiberRoot<span class="token punctuation">;</span>
  <span class="token comment">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span>
    root <span class="token operator">=</span> container<span class="token punctuation">.</span>_reactRootContainer <span class="token operator">=</span> <span class="token function">legacyCreateRootFromDOMContainer</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> forceHydrate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span>
    fiberRoot <span class="token operator">=</span> root<span class="token punctuation">.</span>_internalRoot<span class="token punctuation">;</span>

    <span class="token comment">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> originalCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
      <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token function">getPublicRootInstance</span><span class="token punctuation">(</span>fiberRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">originalCallback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment">// Initial mount should not be batched.</span>
    <span class="token comment">// 进入 unbatchedUpdates 方法</span>
    <span class="token function">unbatchedUpdates</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">updateContainer</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> fiberRoot<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span>
    fiberRoot <span class="token operator">=</span> root<span class="token punctuation">.</span>_internalRoot<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> _originalCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
      <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token function">getPublicRootInstance</span><span class="token punctuation">(</span>fiberRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">_originalCallback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment">// Update</span>

    <span class="token function">updateContainer</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> fiberRoot<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">getPublicRootInstance</span><span class="token punctuation">(</span>fiberRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我为你总结一下首次渲染过程中 <code>legacyRenderSubtreeIntoContainer</code> 方法的主要逻辑链路：</p> <p><img src="http://img-repo.poetries.top/images/20210501201153.png" alt=""></p> <p>在这个流程中，你需要关注到 <code>fiberRoot</code> 这个对象。<code>fiberRoot</code> 到底是什么呢？这里我将运行时的 <code>root 和 fiberRoot</code>为你截取出来，其中 root 对象的结构如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501201231.png" alt=""></p> <p>可以看出，root 对象（<code>container._reactRootContainer</code>）上有一个 <code>_internalRoot</code> 属性，这个 <code>_internalRoot</code> 也就是 <code>fiberRoot</code>。fiberRoot 的本质是一个 FiberRootNode 对象，其中包含一个 current 属性，该属性同样需要划重点。这里我为你高亮出 current 属性的部分内容：</p> <p><img src="http://img-repo.poetries.top/images/20210501201327.png" alt=""></p> <blockquote><p>或许你会对 <code>current</code> 对象包含的海量属性感到陌生和头大，但这并不妨碍你 Get 到“<code>current 对象是一个 FiberNode 实例</code>”这一点，<code>FiberNode</code>，正是 <code>Fiber</code> 节点对应的对象类型。<code>current</code> 对象是一个 <code>Fiber</code> 节点，不仅如此，它还是当前 <code>Fiber</code> 树的头部节点</p></blockquote> <p>考虑到 <code>current</code> 属性对应的 <code>FiberNode</code> 节点，在调用栈中实际是由 <code>createHostRootFiber</code> 方法创建的，React 源码中也有多处以 <code>rootFiber</code> 代指 <code>current</code> 对象，因此下文中我们将以 <code>rootFiber 指代 current 对象</code>。</p> <p>读到这里，你脑海中应该不难形成一个这样的指向关系：</p> <p><img src="http://img-repo.poetries.top/images/20210501201544.png" alt=""></p> <p>其中，<code>fiberRoot</code> 的关联对象是真实 <code>DOM</code> 的容器节点；而 <code>rootFiber</code> 则作为虚拟 DOM 的根节点存在。这两个节点，将是后续整棵 <code>Fiber</code> 树构建的起点。</p> <p>接下来，<code>fiberRoot</code> 将和 <code>ReactDOM.render</code> 方法的其他入参一起，被传入 <code>updateContainer</code> 方法，从而形成一个回调。这个回调，正是接下来要调用的 <code>unbatchedUpdates</code> 方法的入参。我们一起看看 <code>unbatchedUpdates</code> 做了什么，下面代码是对 <code>unbatchedUpdates</code> 主体逻辑的提取：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">unbatchedUpdates</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里是对上下文的处理，不必纠结</span>
  <span class="token keyword">var</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span>
  executionContext <span class="token operator">&amp;=</span> <span class="token operator">~</span>BatchedContext<span class="token punctuation">;</span>
  executionContext <span class="token operator">|=</span> LegacyUnbatchedContext<span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// finally 逻辑里是对回调队列的处理，此处不用太关注</span>
    executionContext <span class="token operator">=</span> prevExecutionContext<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>executionContext <span class="token operator">===</span> NoContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Flush the immediate callbacks that were scheduled during this batch</span>
      <span class="token function">resetRenderTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">flushSyncCallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 <code>unbatchedUpdates</code> 函数体里，当下你只需要 Get 到一个信息：<code>它直接调用了传入的回调 fn</code>。而在当前链路中，fn 是什么呢？fn 是一个针对 <code>updateContainer</code> 的调用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">unbatchedUpdates</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">updateContainer</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> fiberRoot<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>接下来我们很有必要去看看 <code>updateContainer</code> 里面的逻辑。这里我将主体代码提取如下（解析在注释里，如果没有耐心读完可以直接看文字解读）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateContainer</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> container<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token operator">...</span>

  <span class="token comment">// 这是一个 event 相关的入参，此处不必关注</span>
  <span class="token keyword">var</span> eventTime <span class="token operator">=</span> <span class="token function">requestEventTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token operator">...</span><span class="token operator">...</span>

  <span class="token comment">// 这是一个比较关键的入参，lane 表示优先级</span>
  <span class="token keyword">var</span> lane <span class="token operator">=</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span>current$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span>
  <span class="token keyword">var</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>eventTime<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span> 

  <span class="token comment">// update 的 payload 对应的是一个 React 元素</span>
  update<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span>
    element<span class="token operator">:</span> element
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span>
  callback <span class="token operator">=</span> callback <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> callback<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'render(...): Expected the last optional `callback` argument to be a '</span> <span class="token operator">+</span> <span class="token string">'function. Instead received: %s.'</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 将 update 入队</span>
  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>current$<span class="token number">1</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 调度 fiberRoot </span>
  <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>current$<span class="token number">1</span><span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回当前节点（fiberRoot）的优先级</span>
  <span class="token keyword">return</span> lane<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>updateContainer</code> 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：</p> <ul><li>请求当前 <code>Fiber</code> 节点的 lane（优先级）；</li> <li>结合 <code>lane</code>（优先级），创建当前 <code>Fiber</code> 节点的 <code>update</code> 对象，并将其入队；</li> <li>调度当前节点（<code>rootFiber</code>）。</li></ul> <p>函数体中的 <code>scheduleWork</code> 其实就是 <code>scheduleUpdateOnFiber</code>，<code>scheduleUpdateOnFiber</code> 函数的任务是调度当前节点的更新。在这个函数中，会处理一系列与优先级、打断操作相关的逻辑。但是在 <code>ReactDOM.render</code> 发起的首次渲染链路中，这些意义都不大，因为这个渲染过程其实是同步的。我们可以尝试在 Source 面板中为该函数打上断点，逐行执行代码，会发现逻辑最终会走到下图的高亮处：</p> <p><img src="http://img-repo.poetries.top/images/20210501211335.png" alt=""></p> <p><code>performSyncWorkOnRoot</code>直译过来就是“执行根节点的同步任务”，<code>这里的“同步”二字需要注意，它明示了接下来即将开启的是一个同步的过程</code>。这也正是为什么在整个渲染链路中，调度（Schedule）动作没有存在感的原因。</p> <p>前面我们曾经提到过，<code>performSyncWorkOnRoot</code> 是 <code>render</code> 阶段的起点，<code>render 阶段</code>的任务就是完成 <code>Fiber</code> 树的构建，它是整个渲染链路中最核心的一环。<code>在异步渲染的模式下，render 阶段应该是一个可打断的异步过程</code></p> <blockquote><p>而现在，我相信你心里更多的疑惑在于：<code>都说 Fiber 架构带来的异步渲染是 React 16 的亮点，为什么分析到现在，竟然发现 ReactDOM.render 触发的首次渲染是个同步过程呢</code></p></blockquote> <h3 id="同步的-reactdom-render-异步的-reactdom-createroot"><a href="#同步的-reactdom-render-异步的-reactdom-createroot" class="header-anchor">#</a> 同步的 ReactDOM.render，异步的 ReactDOM.createRoot</h3> <p>其实在 React 16，包括近期发布的 React 17 小版本中，React 都有以下 3 种启动方式：</p> <p><strong>legacy 模式：</strong></p> <p><code>ReactDOM.render(&lt;App /&gt;, rootNode)</code>。这是当前 <code>React App</code> 使用的方式，当前没有计划删除本模式，但是这个模式可能不支持这些新功能。</p> <p><strong>blocking 模式：</strong></p> <p><code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code>。目前正在实验中，作为迁移到 <code>concurrent</code> 模式的第一个步骤</p> <p><strong>concurrent 模式：</strong></p> <p><code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code>。目前在实验中，未来稳定之后，打算作为 <code>React</code>的默认开发模式，这个模式开启了所有的新功能</p> <blockquote><p>在这 3 种模式中，<code>我们常用的 ReactDOM.render 对应的是 legacy 模式，它实际触发的仍然是同步的渲染链路</code>。<code>blocking</code> 模式可以理解为 <code>legacy</code> 和 <code>concurrent</code>之间的一个过渡形态，之所以会有这个模式，是因为 React 官方希望能够提供渐进的迁移策略，帮助我们更加顺滑地过渡到 <code>Concurrent</code> 模式。<code>blocking</code> 在实际应用中是比较低频的一个模式，了解即可。</p></blockquote> <p>按照官方的说法，“<code>长远来看，模式的数量会收敛，不用考虑不同的模式</code>，但就目前而言，模式是一项重要的迁移策略，让每个人都能决定自己什么时候迁移，并按照自己的速度进行迁移”。由此可以看出，<code>Concurrent 模式确实是 React 的终极目标</code>，也是其创作团队使用 Fiber 架构重写核心算法的动机所在。</p> <h3 id="拓展-关于异步模式下的首次渲染链路"><a href="#拓展-关于异步模式下的首次渲染链路" class="header-anchor">#</a> 拓展：关于异步模式下的首次渲染链路</h3> <p>当下，如果想要开启异步渲染，我们需要调用 <code>ReactDOM.createRoot</code> 方法来启动应用，那 <code>ReactDOM.createRoot</code> 开启的渲染链路与 <code>ReactDOM.render</code> 有何不同呢？</p> <p>这里我修改一下调用方式，给你展示一下调用栈。由于本讲的源码取材于 React 17.0.0 版本，在这个版本中，<code>createRoot</code> 仍然是一个 <code>unstable</code> 的方法。因此实际调用的 API 应该是“<code>unstable_createRoot</code>”：</p> <div class="language-js extra-class"><pre class="language-js"><code>ReactDOM<span class="token punctuation">.</span><span class="token function">unstable_createRoot</span><span class="token punctuation">(</span>rootElement<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>Concurrent</code> 模式开启后，首次渲染的调用栈变成了如下图所示的样子：</p> <p><img src="http://img-repo.poetries.top/images/20210501212348.png" alt=""></p> <p>乍一看，好像和 <code>ReactDOM.render</code> 差别很大，其实不然。图中 <code>createRoot</code> 所触发的逻辑仍然是一些准备性质的初始化工作，此处不必太纠结。关键在于下面我给你框出来的这部分，如下图所示</p> <p><img src="http://img-repo.poetries.top/images/20210501212616.png" alt=""></p> <p>我们拉近一点来看，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501212641.png" alt=""></p> <p>你会发现这地方也调用了一个 <code>render</code>。再顺着这个调用往下看，发现有大量的熟悉面孔：<code>updateContainer</code>、<code>requestUpdateLane</code>、<code>createUpdate</code>、<code>scheduleUpdateOnFiber</code>......这些函数在 <code>ReactDOM.render</code> 的调用栈中也出现过。</p> <p>其实，当前你看到的这个 <code>render</code> 调用链路，和 <code>ReactDOM.render</code> 的调用链路是非常相似的，主要的区别在 <code>scheduleUpdateOnFiber</code> 的这个判断里：</p> <p><img src="http://img-repo.poetries.top/images/20210501212753.png" alt=""></p> <p>在异步渲染模式下，由于请求到的 <code>lane</code> 不再是 <code>SyncLane</code>（同步优先级），故不会再走到 <code>performSyncWorkOnRoot</code> 这个调用，而是会转而执行 <code>else</code> 中调度相关的逻辑。</p> <p>这里有个点要给你点出来——React 是如何知道当前处于哪个模式的呢？我们可以以 <code>requestUpdateLane</code> 函数为例，下面是它局部的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取 mode 属性</span>
  <span class="token keyword">var</span> mode <span class="token operator">=</span> fiber<span class="token punctuation">.</span>mode<span class="token punctuation">;</span>
  <span class="token comment">// 结合 mode 属性判断当前的</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">&amp;</span> BlockingMode<span class="token punctuation">)</span> <span class="token operator">===</span> NoMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> SyncLane<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">&amp;</span> ConcurrentMode<span class="token punctuation">)</span> <span class="token operator">===</span> NoMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">getCurrentPriorityLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> ImmediatePriority$<span class="token number">1</span> <span class="token operator">?</span> SyncLane <span class="token operator">:</span> SyncBatchedLane<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span><span class="token operator">...</span>
  <span class="token keyword">return</span> lane<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码中需要注意 <code>fiber</code>节点上的 <code>mode</code> 属性：<code>React 将会通过修改 mode 属性为不同的值，来标识当前处于哪个渲染模式；在执行过程中，也是通过判断这个属性，来区分不同的渲染模式</code>。</p> <blockquote><p>因此不同的渲染模式在挂载阶段的差异，本质上来说并不是工作流的差异（其工作流涉及 初始化 → render → commit 这 3 个步骤），而是 mode 属性的差异。<code>mode 属性决定着这个工作流是一气呵成（同步）的，还是分片执行（异步）的</code></p></blockquote> <h3 id="fiber-架构一定是异步渲染吗"><a href="#fiber-架构一定是异步渲染吗" class="header-anchor">#</a> Fiber 架构一定是异步渲染吗？</h3> <p><code>React 16</code> 如果没有开启 <code>Concurrent</code> 模式，那它还能叫 <code>Fiber</code> 架构吗？</p> <p>从动机上来看，<code>Fiber 架构的设计确实主要是为了 Concurrent 而存在</code>。但经过了本讲紧贴源码的讲解，相信你也能够看出，在 React 16，包括已发布的 React 17 版本中，不管是否是 Concurrent，整个数据结构层面的设计、包括贯穿整个渲染链路的处理逻辑，已经完全用 Fiber 重构了一遍。站在这个角度来看，<code>Fiber 架构在 React 中并不能够和异步渲染画严格的等号，它是一种同时兼容了同步渲染与异步渲染的设计</code>。</p> <h2 id="三、render-阶段"><a href="#三、render-阶段" class="header-anchor">#</a> 三、render 阶段</h2> <h3 id="拆解-reactdom-render-调用栈-render-阶段"><a href="#拆解-reactdom-render-调用栈-render-阶段" class="header-anchor">#</a> 拆解 ReactDOM.render 调用栈——render 阶段</h3> <p>首先，我们复习一下 <code>render 阶段</code>在整个渲染链路中的定位，如下图所示。</p> <p><img src="http://img-repo.poetries.top/images/20210501214149.png" alt=""></p> <p>图中，<code>performSyncWorkOnRoot</code> 标志着 <code>render 阶段</code>的开始，<code>finishSyncRender</code> 标志着 <code>render</code>阶段的结束。这中间包含了大量的 <code>beginWork</code>、<code>completeWork</code> 调用栈，正是 <code>render</code> 的工作内容。</p> <blockquote><p><code>beginWork</code>、<code>completeWork</code> 这两个方法需要注意，它们串联起的是一个“模拟递归”的过程。</p></blockquote> <p><code>React 15 下的调和过程是一个递归的过程</code>。而 <code>Fiber</code> 架构下的调和过程，虽然<code>并不是依赖递归来实现的</code>，但在 <code>ReactDOM.render</code> 触发的同步模式下，它仍然是一个<code>深度优先搜索</code>的过程。在这个过程中，<code>beginWork</code> 将创建新的 <code>Fiber</code> 节点，而 <code>completeWork</code> 则负责将 <code>Fiber</code> 节点映射为 <code>DOM</code> 节点。</p> <p>我们的 Fiber 树都还长这个样子：</p> <p><img src="http://img-repo.poetries.top/images/20210501214428.png" alt=""></p> <p>就这么个样子，你遍历它，能遍历出来什么？到底怎么个遍历法？接下来我们就深入到源码里去一探究竟！</p> <h3 id="workinprogress-节点的创建"><a href="#workinprogress-节点的创建" class="header-anchor">#</a> workInProgress 节点的创建</h3> <p><code>performSyncWorkOnRoot</code>  是 <code>render</code> 阶段的起点，而这个函数最关键的地方在于它调用了 <code>renderRootSync</code>。下面我们放大 <code>Performance</code> 调用栈，来看看 <code>renderRootSync</code> 被调用后，紧接着发生了什么：</p> <p><img src="http://img-repo.poetries.top/images/20210501214533.png" alt=""></p> <p>紧随其后的是 <code>prepareFreshStack</code>，这里不卖关子，<code>prepareFreshStack</code> 的作用是重置一个新的堆栈环境，其中最需要我们关注的步骤，就是对<code>createWorkInProgress</code> 的调用。以下我对 <code>createWorkInProgress</code> 的主要逻辑进行了提取（解析在注释里）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这里入参中的 current 传入的是现有树结构中的 rootFiber 对象</span>
<span class="token keyword">function</span> <span class="token function">createWorkInProgress</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span> pendingProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> workInProgress <span class="token operator">=</span> current<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
  <span class="token comment">// ReactDOM.render 触发的首屏渲染将进入这个逻辑</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这是需要你关注的第一个点，workInProgress 是 createFiber 方法的返回值</span>
    workInProgress <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> current<span class="token punctuation">.</span>key<span class="token punctuation">,</span> current<span class="token punctuation">.</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    workInProgress<span class="token punctuation">.</span>elementType <span class="token operator">=</span> current<span class="token punctuation">.</span>elementType<span class="token punctuation">;</span>
    workInProgress<span class="token punctuation">.</span>type <span class="token operator">=</span> current<span class="token punctuation">.</span>type<span class="token punctuation">;</span>
    workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> current<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
    <span class="token comment">// 这是需要你关注的第二个点，workInProgress 的 alternate 将指向 current</span>
    workInProgress<span class="token punctuation">.</span>alternate <span class="token operator">=</span> current<span class="token punctuation">;</span>
    <span class="token comment">// 这是需要你关注的第三个点，current 的 alternate 将反过来指向 workInProgress</span>
    current<span class="token punctuation">.</span>alternate <span class="token operator">=</span> workInProgress<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// else 的逻辑此处先不用关注</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 以下省略大量 workInProgress 对象的属性处理逻辑</span>
  <span class="token comment">// 返回 workInProgress 节点</span>
  <span class="token keyword">return</span> workInProgress<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先要声明的是，该函数中的 <code>current</code> 入参指的是现有树结构中的 <code>rootFiber</code> 对象，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501214757.png" alt=""></p> <p>源码太长（其实经过处理已经不长了）不看版的重点如下：</p> <ul><li><code>createWorkInProgress</code> 将调用 <code>createFiber</code>，<code>workInProgress</code>是 <code>createFiber</code> 方法的返回值；</li> <li><code>workInProgress</code> 的 <code>alternate</code> 将指向 <code>current</code>；</li> <li><code>current</code> 的 <code>alternate</code> 将反过来指向 <code>workInProgress</code>。</li></ul> <p>理解了这三点，你就会自然而然地想知道 <code>workInProgress</code> 的本体到底是什么样的，也就是 <code>createFiber</code> 到底会返回什么。下面我们就看看 <code>createFiber</code> 的逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">createFiber</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">,</span> mode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FiberNode</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>代码出奇的简单，但信息却给得很到位 —— <code>createFiber 将创建一个 FiberNode 实例，而 FiberNode，它正是 Fiber 节点的类型</code>。因此 <code>workInProgress 就是一个 Fiber 节点</code>。不仅如此，细心的你可能还会发现 <code>workInProgress</code> 的创建入参其实来源于 <code>current</code>，如下面代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code>workInProgress <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> current<span class="token punctuation">.</span>key<span class="token punctuation">,</span> current<span class="token punctuation">.</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>workInProgress 节点其实就是 current 节点（即 rootFiber）的副本</strong></p> <p>再结合  current 指向 rootFiber 对象（同样是 FiberNode 实例），以及 current 和 workInProgress 通过 alternate 互相连接这些信息，我们可以分析出这波操作执行完之后，整棵树的结构应该如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501215239.png" alt=""></p> <p>完成了这个任务之后，就会进入 workLoopSync 的逻辑。这个 workLoopSync 函数也是个“人狠话不多”的主，它的逻辑同样是简洁明了的，如下所示（解析在注释里）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 若 workInProgress 不为空</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 针对它执行 performUnitOfWork 方法</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>workLoopSync</code> 做的事情就是通过 <code>while</code> 循环反复判断 <code>workInProgress</code> 是否为空，并在不为空的情况下针对它执行 <code>performUnitOfWork</code> 函数。</p> <blockquote><p>而 <code>performUnitOfWork</code> 函数将触发对 <code>beginWork</code> 的调用，进而实现对新 <code>Fiber</code> 节点的创建。若 <code>beginWork</code> 所创建的 <code>Fiber</code> 节点不为空，则 <code>performUniOfWork</code> 会用这个新的 <code>Fiber</code> 节点来更新 <code>workInProgress</code> 的值，为下一次循环做准备。</p></blockquote> <p><code>通过循环调用 performUnitOfWork 来触发 beginWork，新的 Fiber 节点就会被不断地创建</code>。当 <code>workInProgress</code> 终于为空时，说明没有新的节点可以创建了，也就意味着已经完成对整棵 <code>Fiber</code> 树的构建。</p> <p>在这个过程中，<code>每一个被创建出来的新 Fiber 节点，都会一个一个挂载为最初那个 workInProgress 节点（如下图高亮处）的后代节点</code>。而上述过程中构建出的这棵 Fiber 树，也正是大名鼎鼎的 <code>workInProgress 树</code>。</p> <p><img src="http://img-repo.poetries.top/images/20210501215505.png" alt=""></p> <p>相应地，图中 current 指针所指向的根节点所在的那棵树，我们叫它“<code>current 树</code>”。</p> <p>相应地，图中 current 指针所指向的根节点所在的那棵树，我们叫它“current 树”。</p> <p>这时候，相信一些同学心里已经开始犯嘀咕了：一棵 current 树，一棵 workInProgress 树，这名堂也太多了吧！况且这两棵 Fiber 树至少在现在看来，是完全没区别的（毕竟都还只有一个根节点，哈哈）。React 这样设计的目的何在？或者换个问法——到底是什么样的事情一棵树做不到，非得搞两棵“一样”的树出来？</p> <p>在一步一步理解 Fiber 树的构建和更新过程之后，我将带你去认识“两棵 Fiber 树”这一现象背后的动机。</p> <p>接下来我们就深入到 <code>beginWork</code> 和 <code>completeWork</code> 的逻辑里去，一起看看 <code>Fiber</code> 树的构建过程及最终形态。</p> <h3 id="beginwork-开启-fiber-节点创建过程"><a href="#beginwork-开启-fiber-节点创建过程" class="header-anchor">#</a> beginWork 开启 Fiber 节点创建过程</h3> <p>有一说一，beginWork 的源码实在是长到不科学。这里我们本着抓主要矛盾的原则，针对与树构建过程强相关的动作进行逻辑提取，代码如下（解析在注释里）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token operator">...</span>

  <span class="token comment">//  current 节点不为空的情况下，会加一道辨识，看看是否有更新逻辑要处理</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取新旧 props</span>
    <span class="token keyword">var</span> oldProps <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
    <span class="token keyword">var</span> newProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>

    <span class="token comment">// 若 props 更新或者上下文改变，则认为需要&quot;接受更新&quot;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldProps <span class="token operator">!==</span> newProps <span class="token operator">||</span> <span class="token function">hasContextChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>
     workInProgress<span class="token punctuation">.</span>type <span class="token operator">!==</span> current<span class="token punctuation">.</span>type <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 打个更新标</span>
      didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>xxx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 不需要更新的情况 A</span>
      <span class="token keyword">return</span> <span class="token constant">A</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>需要更新的情况 <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不需要更新的其他情况，这里我们的首次渲染就将执行到这一行的逻辑</span>
        didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
  <span class="token operator">...</span><span class="token operator">...</span>
  <span class="token comment">// 这坨 switch 是 beginWork 中的核心逻辑，原有的代码量相当大</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token operator">...</span>
    <span class="token comment">// 这里省略掉大量形如&quot;case: xxx&quot;的逻辑</span>
    <span class="token comment">// 根节点将进入这个逻辑</span>
    <span class="token keyword">case</span> HostRoot<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">updateHostRoot</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span>
    <span class="token comment">// dom 标签对应的节点将进入这个逻辑</span>
    <span class="token keyword">case</span> HostComponent<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">updateHostComponent</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span>

    <span class="token comment">// 文本节点将进入这个逻辑</span>
    <span class="token keyword">case</span> HostText<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">updateHostText</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">)</span>
    <span class="token operator">...</span><span class="token operator">...</span> 
    <span class="token comment">// 这里省略掉大量形如&quot;case: xxx&quot;的逻辑</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 这里是错误兜底，处理 switch 匹配不上的情况</span>
  <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span>
        <span class="token string">&quot;Unknown unit of work tag (&quot;</span> <span class="token operator">+</span>
          workInProgress<span class="token punctuation">.</span>tag <span class="token operator">+</span>
          <span class="token string">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>beginWork 源码太长不看版的重点总结</strong>：</p> <ul><li><code>beginWork</code> 的入参是一对用 <code>alternate</code> 连接起来的 <code>workInProgress</code> 和 <code>current</code> 节点；</li> <li><code>beginWork</code> 的核心逻辑是根据 <code>fiber</code> 节点（<code>workInProgress</code>）的 <code>tag</code> 属性的不同，调用不同的节点创建函数。</li></ul> <p>当前的 <code>current 节点是 rootFiber</code>，而 <code>workInProgress</code> 则是 <code>current 的副本</code>，它们的 <code>tag 都是 3</code>，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501215910.png" alt=""></p> <p>而 <code>3</code> 正是 <code>HostRoot</code> 所对应的值，因此第一个 <code>beginWork</code> 将进入 <code>updateHostRoot</code> 的逻辑。</p> <p>这里你先不必急于关注 <code>updateHostRoot</code> 的逻辑细节。事实上，在整段 <code>switch</code> 逻辑里，包含的形如“<code>update+类型名</code>”这样的函数是非常多的</p> <p>幸运的是，这些函数之间不仅命名形式一致，工作内容也相似。就 render 链路来说，它们共同的特性，就是都会通过调用 reconcileChildren 方法，生成当前节点的子节点。</p> <p>reconcileChildren 的源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reconcileChildren</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> renderLanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断 current 是否为 null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若 current 为 null，则进入 mountChildFibers 的逻辑</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">mountChildFibers</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若 current 不为 null，则进入 reconcileChildFibers 的逻辑</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> current<span class="token punctuation">.</span>child<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从源码来看，<code>reconcileChildren</code> 也只是做逻辑的分发，具体的工作还要到 <code>mountChildFibers</code> 和 <code>reconcileChildFibers</code> 里去看。</p> <h3 id="childreconciler-处理-fiber-节点的幕后-操盘手"><a href="#childreconciler-处理-fiber-节点的幕后-操盘手" class="header-anchor">#</a> ChildReconciler，处理 Fiber 节点的幕后“操盘手”</h3> <p>那么这两个函数又是何方神圣呢？在源码中，我们可以觅得这样两个赋值语句：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> reconcileChildFibers <span class="token operator">=</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> mountChildFibers <span class="token operator">=</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>原来 <code>reconcileChildFibers</code> 和 <code>mountChildFibers</code> 不仅名字相似，出处也一致。它们都是 <code>ChildReconciler</code> 这个函数的返回值，仅仅存在入参上的区别。而 <code>ChildReconciler</code>，则是一个实打实的“庞然大物”，其内部的逻辑量堪比 <code>N</code> 个 <code>beginWork</code>。这里我将关键要素提取如下（解析在注释里）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token parameter">shouldTrackSideEffects</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 删除节点的逻辑</span>
  <span class="token keyword">function</span> <span class="token function">deleteChild</span><span class="token punctuation">(</span><span class="token parameter">returnFiber<span class="token punctuation">,</span> childToDelete</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Noop.</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token comment">// 以下执行删除逻辑</span>
  <span class="token punctuation">}</span>
 
  <span class="token operator">...</span><span class="token operator">...</span>


  <span class="token comment">// 单个节点的插入逻辑</span>
  <span class="token keyword">function</span> <span class="token function">placeSingleChild</span><span class="token punctuation">(</span><span class="token parameter">newFiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects <span class="token operator">&amp;&amp;</span> newFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newFiber<span class="token punctuation">.</span>flags <span class="token operator">=</span> Placement<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 插入节点的逻辑</span>
  <span class="token keyword">function</span> <span class="token function">placeChild</span><span class="token punctuation">(</span><span class="token parameter">newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIndex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newFiber<span class="token punctuation">.</span>index <span class="token operator">=</span> newIndex<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Noop.</span>
      <span class="token keyword">return</span> lastPlacedIndex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 以下执行插入逻辑</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span><span class="token operator">...</span>
  <span class="token comment">// 此处省略一系列 updateXXX 的函数，它们用于处理 Fiber 节点的更新</span>

  <span class="token comment">// 处理不止一个子节点的情况</span>
  <span class="token keyword">function</span> <span class="token function">reconcileChildrenArray</span><span class="token punctuation">(</span><span class="token parameter">returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> newChildren<span class="token punctuation">,</span> lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token operator">...</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 此处省略一堆 reconcileXXXXX 形式的函数，它们负责处理具体的 reconcile 逻辑</span>
  <span class="token keyword">function</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span><span class="token parameter">returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> newChild<span class="token punctuation">,</span> lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这是一个逻辑分发器，它读取入参后，会经过一系列的条件判断，调用上方所定义的负责具体节点操作的函数</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 将总的 reconcileChildFibers 函数返回</span>
  <span class="token keyword">return</span> reconcileChildFibers<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于原本的代码量着实巨大，感兴趣的同学可以<a href="https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactChildFiber.old.js#L253" target="_blank" rel="noopener noreferrer">点开这个文件查看细节<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，此处我仅针对与主流程强相关的逻辑为你总结以下要点：</p> <ul><li>关键的入参 <code>shouldTrackSideEffects</code>，意为“是否需要追踪副作用”，因此 <code>reconcileChildFibers</code> 和 <code>mountChildFibers</code> 的不同，在于对副作用的处理不同；</li> <li><code>ChildReconciler</code> 中定义了大量如 <code>placeXXX、deleteXXX、updateXXX、reconcileXXX</code> 等这样的函数，这些函数覆盖了对 <code>Fiber</code> 节点的创建、增加、删除、修改等动作，将直接或间接地被 <code>reconcileChildFibers</code> 所调用；</li> <li><code>ChildReconciler</code> 的返回值是一个名为 <code>reconcileChildFibers</code> 的函数，这个函数是一个逻辑分发器，它将根据入参的不同，执行不同的 Fiber 节点操作，最终返回不同的目标 Fiber 节点。</li></ul> <p>对于第 1 点，这里展开说说。对副作用的处理不同，到底是哪里不同？以 placeSingleChild 为例，以下是 placeSingleChild 的源码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">placeSingleChild</span><span class="token punctuation">(</span><span class="token parameter">newFiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects <span class="token operator">&amp;&amp;</span> newFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newFiber<span class="token punctuation">.</span>flags <span class="token operator">=</span> Placement<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newFiber<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看出，一旦判断 <code>shouldTrackSideEffects</code> 为 <code>false</code>，那么下面所有的逻辑都不执行了，直接返回。那如果执行下去会发生什么呢？简而言之就是给 Fiber 节点打上一个叫“flags”的标记，像这样：</p> <div class="language- extra-class"><pre class="language-text"><code>newFiber.flags = Placement;
</code></pre></div><p>这个名为 flags 的标记有何作用呢？</p> <p><strong>小科普：flags 是什么</strong></p> <p>由于这里我引用的是 v17.0.0 版本的源码，属性名已经变更为 flags，但在更早一些的版本中，这个属性名叫“effectTag”。在时下的社区讨论中，effectTag 这个命名更常见，也更语义化，因此下文我将以 “effectTag”代指“flags”。</p> <p><code>Placement</code> 这个 <code>effectTag</code> 的意义，<code>是在渲染器执行时，也就是真实 DOM 渲染时，告诉渲染器：我这里需要新增 DOM 节点</code>。 <code>effectTag 记录的是副作用的类型</code>，而所谓“副作用”，React 给出的定义是“数据获取、订阅或者修改 DOM”等动作。在这里，Placement 对应的显然是 DOM 相关的副作用操作。</p> <p>像 <code>Placement 这样的副作用标识，还有很多，它们均以二进制常量的形式存在</code>，下图我为你截取了局部（你可以在这个文件里查看 <code>effectTag</code> 的类型）：</p> <p><img src="http://img-repo.poetries.top/images/20210501220545.png" alt=""></p> <p>回到我们的调用链路里来，由于 <code>current</code> 是 <code>rootFiber</code>，它不为 <code>null</code>，因此它将走入的是下图所高亮的这行逻辑。也就是说在 <code>mountChildFibers</code> 和 <code>reconcileChildFibers</code> 之间，它选择的是 <code>reconcileChildFibers</code>：</p> <p><img src="http://img-repo.poetries.top/images/20210501220749.png" alt=""></p> <p>结合前面的分析可知，<code>reconcileChildFibers</code> 是<code>ChildReconciler(true)</code>的返回值。入参为 <code>true</code>，意味着其内部逻辑是允许追踪副作用的，因此“打 <code>effectTag</code>”这个动作将会生效。</p> <p>接下来进入 <code>reconcileChildFibers</code> 的逻辑，在 <code>reconcileChildFibers</code> 这个逻辑分发器中，会把 <code>rootFiber</code> 子节点的创建工作分发给 <code>reconcileXXX</code> 函数家族的一员——<code>reconcileSingleElement</code> 来处理，具体的调用形式如下图高亮处所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501220845.png" alt=""></p> <p><code>reconcileSingleElement</code> 将基于 <code>rootFiber</code> 子节点的 <code>ReactElement</code> 对象信息，创建其对应的 FiberNode。这个过程中涉及的函数调用如下图高亮处所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501220908.png" alt=""></p> <p>这里需要说明的一点是：<code>rootFiber 作为 Fiber 树的根节点</code>，它并没有一个确切的 <code>ReactElement</code> 与之映射。结合 <code>JSX</code> 结构来看，我们可以将其理解为是 <code>JSX</code> 中根组件的父节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">&quot;react-dom&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第一段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第二段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> rootElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rootElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看出，根组件是一个类型为 App 的函数组件，因此 <code>rootFiber 就是 App 的父节点</code>。</p> <p>结合这个分析来看，图中的 <code>_created4</code> 是根据 <code>rootFiber</code> 的第一个子节点对应的 <code>ReactElement 来创建的 Fiber 节点</code>，那么它就是 App 所对应的 <code>Fiber</code> 节点。现在我为你打印出运行时的 <code>_created4</code> 值，会发现确实如此：</p> <p><img src="http://img-repo.poetries.top/images/20210501221024.png" alt=""></p> <p>App 所对应的 <code>Fiber</code> 节点，将被 <code>placeSingleChild</code> 打上“<code>Placement</code>”（新增）的副作用标记，而后作为 <code>reconcileChildFibers</code> 函数的返回值，返回给下图中的 <code>workInProgress.child</code>：</p> <p><img src="http://img-repo.poetries.top/images/20210501221052.png" alt=""></p> <p><code>reconcileChildren</code> 函数上下文里的 <code>workInProgress</code> 就是 <code>rootFiber</code> 节点。那么此时，我们就将新创建的 <code>App Fiber</code> 节点和 <code>rootFiber</code> 关联了起来，整个 <code>Fiber</code> 树如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501221125.png" alt=""></p> <h3 id="fiber-节点的创建过程梳理"><a href="#fiber-节点的创建过程梳理" class="header-anchor">#</a> Fiber 节点的创建过程梳理</h3> <p>分析完 <code>App FiberNode</code> 的创建过程，我们先不必急于继续往下走这个渲染链路。因为其实最关键的东西已经讲完了，剩余节点的创建只不过是对 <code>performUnitOfWork</code>、 <code>beginWork</code> 和 <code>ChildReconciler</code> 等相关逻辑的重复。</p> <p>刚刚这一通分析所涉及的调用栈很长，相信不少人如果是初读的话，过程中肯定不可避免地要反复回看，确认自己现在到底在调用栈的哪一环。这里为了方便你把握逻辑脉络，我将本讲讲解的 beginWork 所触发的调用流程总结进一张大图：</p> <p><img src="http://img-repo.poetries.top/images/20210501221222.png" alt=""></p> <h3 id="fiber-树的构建过程"><a href="#fiber-树的构建过程" class="header-anchor">#</a> Fiber 树的构建过程</h3> <p>理解了 Fiber 节点的创建过程，就不难理解 Fiber 树的构建过程了。</p> <p>前面我们已经锲而不舍地研究了各路关键函数的源码逻辑，此时相信你已经能够将函数名与函数的工作内容做到对号入座。这里我们不必再纠结与源码的实现细节，可以直接从工作流程的角度来看后续节点的创建。</p> <h3 id="循环创建新的-fiber-节点"><a href="#循环创建新的-fiber-节点" class="header-anchor">#</a> 循环创建新的 Fiber 节点</h3> <p>研究节点创建的工作流，我们的切入点是workLoopSync这个函数。</p> <p>为什么选它？这里来复习一遍workLoopSync会做什么：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 若 workInProgress 不为空</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 针对它执行 performUnitOfWork 方法</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它会循环地调用 <code>performUnitOfWork</code>，而 <code>performUnitOfWork</code>，<code>其主要工作是“通过调用 beginWork，来实现新 Fiber 节点的创建”</code>；它还有一个次要工作，就是<code>把新创建的这个 Fiber 节点的值更新到 workInProgress 变量里去</code>。源码中的相关逻辑提取如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 新建 Fiber 节点</span>
next <span class="token operator">=</span> <span class="token function">beginWork$1</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> unitOfWork<span class="token punctuation">,</span> subtreeRenderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将新的 Fiber 节点赋值给 workInProgress</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// If this doesn't spawn new work, complete the current work.</span>
  <span class="token function">completeUnitOfWork</span><span class="token punctuation">(</span>unitOfWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  workInProgress <span class="token operator">=</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如此便能够确保每次 <code>performUnitOfWork</code> 执行完毕后，当前的 <code>workInProgress</code>都存储着下一个需要被处理的节点，从而为下一次的 <code>workLoopSync</code>循环做好准备。</p> <p>现在我在 <code>workLoopSync</code> 内部打个断点，尝试输出每一次获取到的 <code>workInProgress</code> 的值，<code>workInProgress</code> 值的变化过程如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501221423.png" alt=""></p> <p>共有 7 个节点，若你点击展开查看每个节点的内容，就会发现这 7 个节点其实分别是：</p> <ul><li><code>rootFiber</code>（当前 Fiber 树的根节点）</li> <li><code>App FiberNode</code>（App 函数组件对应的节点）</li> <li><code>class</code> 为 App 的 DOM 元素对应的节点，其内容如下图所示</li></ul> <p><img src="http://img-repo.poetries.top/images/20210501221451.png" alt=""></p> <p>class 为 <code>container</code> 的 DOM 元素对应的节点，其内容如下图所示</p> <p><img src="http://img-repo.poetries.top/images/20210501221508.png" alt=""></p> <p>h1 标签对应的节点</p> <p>第 1 个 p 标签对应的 FiberNode，内容为“我是第一段话”，如下图所示</p> <p><img src="http://img-repo.poetries.top/images/20210501221520.png" alt=""></p> <p>第 2 个 p 标签对应的 FiberNode，内容为“我是第二段话”，如下图所示</p> <p><img src="http://img-repo.poetries.top/images/20210501221536.png" alt=""></p> <p>结合这 7 个 <code>FiberNode</code>，再对照对照我们的 Demo：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第一段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第二段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>你会发现组件自上而下，每一个非文本类型的 ReactElement 都有了它对应的 Fiber 节点。</p></blockquote> <p><strong>注：</strong> React 并不会为所有的文本类型 <code>ReactElement</code> 创建对应的 <code>FiberNode</code>，这是一种优化策略。是否需要创建 <code>FiberNode</code>，在源码中是通过<code>isDirectTextChild</code>这个变量来区分的</p> <p>这样一来，我们构建的这棵树里，就多出了不少 FiberNode，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210501221636.png" alt=""></p> <p>Fiber 节点有是有了，但这些 Fiber 节点之间又是如何相互连接的呢？</p> <h3 id="fiber-节点间是如何连接的呢"><a href="#fiber-节点间是如何连接的呢" class="header-anchor">#</a> Fiber 节点间是如何连接的呢</h3> <blockquote><p>不同的 Fiber 节点之间，将通过 <code>child、return、sibling</code> 这 3 个属性建立关系，其中 <code>child、return</code> 记录的是父子节点关系，而 <code>sibling</code> 记录的则是兄弟节点关系。</p></blockquote> <p>这里我以 h1 这个元素对应的 Fiber 节点为例，给你展示下它是如何与其他节点相连接的。展开这个 Fiber 节点，对它的 child、 return、sibling 3 个属性作截取，如下图所示：</p> <p>child 属性为 null，说明 h1 节点没有子 Fiber 节点：</p> <p><img src="http://img-repo.poetries.top/images/20210501221716.png" alt=""></p> <p>return 属性局部截图：</p> <p><img src="http://img-repo.poetries.top/images/20210501221727.png" alt=""></p> <p>sibling 属性局部截图：</p> <p><img src="http://img-repo.poetries.top/images/20210501221737.png" alt=""></p> <blockquote><p>可以看到，<code>return 属性指向的是 class 为 container 的 div 节点</code>，而 <code>sibling 属性指向的是第 1 个 p 节点</code>。结合 JSX 中的嵌套关系我们不难得知 ——<code>FiberNode 实例中，return 指向的是当前 Fiber 节点的父节点</code>，而 <code>sibling 指向的是当前节点的第 1 个兄弟节点</code>。</p></blockquote> <p>结合这 3 个属性所记录的节点间关系信息，我们可以轻松地将上面梳理出来的新 FiberNode 连接起来：</p> <p><img src="http://img-repo.poetries.top/images/20210501221811.png" alt=""></p> <p>以上便是 <code>workInProgress Fiber</code> 树的最终形态了。从图中可以看出，虽然人们习惯上仍然将眼前的这个产物称为“Fiber 树”，但<code>它的数据结构本质其实已经从树变成了链表</code>。</p> <p>注意，在分析 <code>Fiber</code> 树的构建过程时，我们选取了 <code>beginWork</code> 作为切入点，但整个 <code>Fiber</code> 树的构建过程中，并不是只有 <code>beginWork</code> 在工作。这其中，还穿插着 <code>completeWork</code> 的工作。只有将 <code>completeWork 和 beginWork</code> 放在一起来看，你才能够真正理解，<code>Fiber</code> 架构下的“深度优先遍历”到底是怎么一回事。</p> <h2 id="四、commit-阶段"><a href="#四、commit-阶段" class="header-anchor">#</a> 四、commit 阶段</h2></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/FE-Interview-Questions/principle-docs/react/18-如何理解 Fiber 架构的迭代动机与设计思想.html" class="prev">如何理解 Fiber 架构的迭代动机与设计思想</a></span> <span class="next"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html">剖析 Fiber 架构下 Concurrent 模式的实现原理</a>
      →
    </span></p></div>  <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="请先阅读购买协议" class="el-dialog el-dialog--center" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">请先阅读购买协议</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button disabled="disabled" type="button" class="el-button el-button--danger is-disabled" style="width:100%;"><!----><!----><span>我已阅读（8s）</span></button></span></div></div></div> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="付费阅读" class="el-dialog" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">付费阅读</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button disabled="disabled" type="button" class="el-button el-button--danger is-disabled" style="width:100%;"><!----><!----><span>确 定</span></button></span></div></div></div> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="dialog" class="el-dialog" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title"></span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div> <img src="data:image/png;base64,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" class="theme-float-btn"></main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/FE-Interview-Questions/assets/js/app.c7c92663.js" defer></script><script src="/FE-Interview-Questions/assets/js/5.ef81f1b0.js" defer></script><script src="/FE-Interview-Questions/assets/js/4.1c7c0871.js" defer></script><script src="/FE-Interview-Questions/assets/js/118.ce1cbacb.js" defer></script><script src="/FE-Interview-Questions/assets/js/11.3e5297f1.js" defer></script>
  </body>
</html>
