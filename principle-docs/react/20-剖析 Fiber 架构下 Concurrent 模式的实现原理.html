<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试指南</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/FE-Interview-Questions/logo.png">
    <link rel="manifest" href="/FE-Interview-Questions/manifest.json">
    <link rel="apple-touch-icon" href="/FE-Interview-Questions/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/FE-Interview-Questions/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="web前端面试题总结，面试指南，前端面试题整理，web面试宝典，刷题神器，按模块分类整理总结，打造最全面的前端面试题">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/FE-Interview-Questions/assets/css/0.styles.f26b5f0f.css" as="style"><link rel="preload" href="/FE-Interview-Questions/assets/js/app.d3236e00.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/5.8734293f.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/4.a9037b86.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/121.0b52a657.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/11.20ed5a18.js" as="script"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/1.8315493a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/10.ed8a1dec.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/100.8e4407b6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/101.065ef3fa.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/102.cd5a31aa.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/103.8efb9711.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/104.37e84a3e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/105.63bf4892.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/106.f58a6e53.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/107.c97fe7c4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/108.64c36113.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/109.9fcfcb26.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/110.2ae1f447.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/111.2baf310d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/112.2a226e43.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/113.186aac46.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/114.0200461a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/115.d8a6b7d2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/116.5d539af6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/117.29ac906d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/118.d3f81cae.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/119.11922bd4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/12.4f8bd6d5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/120.d396607a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/122.5e9ca27a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/123.80813021.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/124.459705f0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/125.640bdf3d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/126.37d60b09.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/127.ed8e91ad.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/128.eceadeed.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/129.f7b20909.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/13.459cf7e5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/130.69af78b5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/131.c5d6caa8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/132.30be73d4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/133.0d1981ac.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/134.cbf6cf99.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/135.0dc9ac63.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/136.0f6f1a79.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/137.c2616a83.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/138.fa7f9a22.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/139.97534d25.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/14.07c597cf.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/140.365dd98f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/141.8583bf2f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/142.550f8f58.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/143.facaf6ce.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/144.a13da062.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/145.6d6b78d8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/146.63e91d3e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/147.5d206fa9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/148.e7c14f93.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/149.37ec2b84.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/15.dbcded7e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/150.c096c5f6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/16.7b2cae8f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/17.f17aa05b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/18.62911da1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/19.563f48f8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/20.3e216286.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/21.fd673e34.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/22.5e1f2627.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/23.51f6d75b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/24.9298cfd4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/25.551d18a4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/26.85a0494a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/27.43ed759a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/28.382777a3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/29.62aceeda.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/3.e0a878ad.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/30.8f6b574e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/31.d5e2e6d7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/32.36023c14.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/33.ef59682f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/34.557f9d74.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/35.b34ad016.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/36.ce3f7ff2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/37.04a0c5be.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/38.523c458d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/39.612443be.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/40.913a2380.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/41.db43847c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/42.81801866.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/43.decc6b43.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/44.0379153d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/45.24a3c866.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/46.b6f1380b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/47.f19be565.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/48.3bd4ed36.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/49.1f1e6303.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/50.25ca4557.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/51.eb25a810.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/52.8406715f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/53.86f2ec3e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/54.9e9f70f7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/55.8247116e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/56.4d9e12a7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/57.35d9bdc5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/58.2fdf4bb5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/59.6886a442.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/6.24402e06.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/60.0af8899c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/61.54856b99.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/62.c8c671b2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/63.eb495c9a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/64.adf62045.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/65.73fe187a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/66.3d0972a8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/67.de71cd57.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/68.0c2e9911.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/69.c3080cbb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/7.3da69439.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/70.08e2d0fa.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/71.cdd011af.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/72.072f8269.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/73.06a7014e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/74.97075082.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/75.035f9cf7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/76.66137c69.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/77.f834b25f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/78.4d532767.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/79.baae07ae.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/8.3abf44a7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/80.851c32a9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/81.9bbfa622.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/82.89676520.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/83.77970f3f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/84.b68f30d0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/85.383ca552.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/86.3ec2ace7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/87.b6468b75.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/88.44a4811d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/89.fe9d1263.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/9.45e7fe22.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/90.7fca978f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/91.44105474.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/92.6b2d0401.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/93.c2429643.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/94.9e617dd9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/95.5585ebf8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/96.b6737889.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/97.195b9fd2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/98.778da81e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/99.314ef45c.js">
    <link rel="stylesheet" href="/FE-Interview-Questions/assets/css/0.styles.f26b5f0f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/FE-Interview-Questions/" class="home-link router-link-active"><img src="/FE-Interview-Questions/logo.png" alt="面试指南" class="logo"> <span class="site-name can-hide">面试指南</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!----> <div style="padding-left:1.5rem;"><div class="qr"><img src="/FE-Interview-Questions/assets/img/qr.ee193d28.jpg" alt="poetries" width="120" height="120" loading="lazy"> <p class="we-intro">
    关注公众号，获取更多资讯
  </p></div></div> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/vue/01-从源码解读Vue生命周期.html" class="sidebar-link">从源码解读Vue生命周期</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/02-组件的本质.html" class="sidebar-link">组件的本质</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/03-有状态组件的设计.html" class="sidebar-link">有状态组件的设计</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/04-设计 VNode.html" class="sidebar-link">设计 VNode</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/05-辅助创建 VNode 的 h 函数.html" class="sidebar-link">辅助创建 VNode 的 h 函数</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/06-自定义渲染器和异步渲染.html" class="sidebar-link">自定义渲染器和异步渲染</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/07-渲染器之挂载.html" class="sidebar-link">渲染器之挂载</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/08-渲染器的核心 Diff 算法.html" class="sidebar-link">渲染器的核心 Diff 算法</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/09-渲染器之patch.html" class="sidebar-link">渲染器之patch</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/10-图解 Vue 响应式原理.html" class="sidebar-link">图解 Vue 响应式原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/11-图解 Vue 异步更新.html" class="sidebar-link">图解 Vue 异步更新</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/12-剖析 Vue 内部运行机制.html" class="sidebar-link">剖析 Vue 内部运行机制</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/13-vue响应式原理模拟.html" class="sidebar-link">vue响应式原理模拟</a></li><li><a href="/FE-Interview-Questions/principle-docs/vue/14-vue状态管理之vuex.html" class="sidebar-link">vue状态管理之vuex</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/react/01-React router原理.html" class="sidebar-link">React router原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/02-Dva总结.html" class="sidebar-link">Dva总结</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/03-MobX总结.html" class="sidebar-link">MobX总结</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/04-浅析redux saga中间件及用法.html" class="sidebar-link">浅析redux saga中间件及用法</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/05-Redux之浅析中间件.html" class="sidebar-link">Redux之浅析中间件</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/06-Redux之源码分析.html" class="sidebar-link">Redux之源码分析</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/07-Redux之异步Action及操作.html" class="sidebar-link">Redux之异步Action及操作</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/08-浅析中间件.html" class="sidebar-link">浅析中间件</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/09-react结合redux实战.html" class="sidebar-link">react结合redux实战</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/10-Immutable总结.html" class="sidebar-link">Immutable总结</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/11-React16为什么要更改生命周期(上).html" class="sidebar-link">React16为什么要更改生命周期(上)</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/12-React16为什么要更改生命周期(下).html" class="sidebar-link">React16为什么要更改生命周期(下)</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/13-React Hooks 设计动机与工作模式.html" class="sidebar-link">React Hooks 设计动机与工作模式</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/14-深入 React Hooks 工作机制.html" class="sidebar-link">深入 React Hooks 工作机制</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/15-真正理解虚拟DOM.html" class="sidebar-link">真正理解虚拟DOM</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/16-React 中的“栈调和” Stack Reconciler 过程是怎样的.html" class="sidebar-link">React 中的“栈调和” Stack Reconciler 过程是怎样的</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/17-setState 到底是同步的，还是异步的.html" class="sidebar-link">setState 到底是同步的，还是异步的</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/18-如何理解 Fiber 架构的迭代动机与设计思想.html" class="sidebar-link">如何理解 Fiber 架构的迭代动机与设计思想</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html" class="sidebar-link">ReactDOM.render 是如何串联渲染链路的</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html" class="active sidebar-link">剖析 Fiber 架构下 Concurrent 模式的实现原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#current-树-与-workinprogress-树-双缓冲-模式在-fiber-架构下的实现" class="sidebar-link">current 树 与 workInProgress 树：“双缓冲”模式在 Fiber 架构下的实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#什么是-双缓冲-模式" class="sidebar-link">什么是“双缓冲”模式</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#current-树与-workinprogress-树之间是如何-相互利用-的" class="sidebar-link">current 树与 workInProgress 树之间是如何“相互利用”的</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#挂载后的-fiber-树" class="sidebar-link">挂载后的 Fiber  树</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#更新链路要素拆解" class="sidebar-link">更新链路要素拆解</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#update-的创建" class="sidebar-link">update 的创建</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#从-update-对象到-scheduleupdateonfiber" class="sidebar-link">从 update 对象到 scheduleUpdateOnFiber</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#scheduleupdateonfiber-如何区分同步还是异步" class="sidebar-link">scheduleUpdateOnFiber 如何区分同步还是异步？</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#scheduler-时间切片-与-优先级-的幕后推手" class="sidebar-link">Scheduler——“时间切片”与“优先级”的幕后推手</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#结合-react-调用栈-理解时间切片现象" class="sidebar-link">结合 React 调用栈，理解时间切片现象</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#时间切片是如何实现的" class="sidebar-link">时间切片是如何实现的？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#优先级调度是如何实现的" class="sidebar-link">优先级调度是如何实现的</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/principle-docs/react/20-剖析 Fiber 架构下 Concurrent 模式的实现原理.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/FE-Interview-Questions/principle-docs/react/21-React 事件与 DOM 事件有何不同.html" class="sidebar-link">React 事件与 DOM 事件有何不同</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/22-揭秘 Redux 设计思想与工作原理.html" class="sidebar-link">揭秘 Redux 设计思想与工作原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/23-从 Redux 中间件实现原理切入，理解“面向切面编程”.html" class="sidebar-link">从 Redux 中间件实现原理切入，理解“面向切面编程”</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/24-如何打造高性能的 React 应用.html" class="sidebar-link">如何打造高性能的 React 应用</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/25-跟 React 学设计模式.html" class="sidebar-link">跟 React 学设计模式</a></li><li><a href="/FE-Interview-Questions/principle-docs/react/26-React全部api解读.html" class="sidebar-link">React全部api解读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/webpack/01-Webpack4打包机制原理解析.html" class="sidebar-link">Webpack4打包机制原理解析</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/02-webpack中的HMR热更新原理剖析.html" class="sidebar-link">webpack中的HMR热更新原理剖析</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/03-从源码窥探Webpack4.x原理.html" class="sidebar-link">从源码窥探Webpack4.x原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/04-实现webpack小型打包工具.html" class="sidebar-link">实现webpack小型打包工具</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/05-Babel原理及其使用.html" class="sidebar-link">Babel原理及其使用</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/06-Webpack 与 Rollup 二者之间该如何选择.html" class="sidebar-link">Webpack 与 Rollup 二者之间该如何选择</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/07-前端构建新玩法 Vite 上手与思考.html" class="sidebar-link">前端构建新玩法 Vite 上手与思考</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/08-利用 Webpack CodeSplitting 完成复杂应用拆包.html" class="sidebar-link">利用 Webpack CodeSplitting 完成复杂应用拆包</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/09-玩转 Webpack 的 TreeShaking 与 sideEffects 特性.html" class="sidebar-link">玩转 Webpack 的 TreeShaking 与 sideEffects 特性</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/10-如何配置 Webpack SourceMap 的最佳实践.html" class="sidebar-link">如何配置 Webpack SourceMap 的最佳实践</a></li><li><a href="/FE-Interview-Questions/principle-docs/webpack/11-Webpack 运行机制与核心工作原理.html" class="sidebar-link">Webpack 运行机制与核心工作原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/node/01-Node事件循环机制原理.html" class="sidebar-link">Node事件循环机制原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/node/02-express详细使用.html" class="sidebar-link">express详细使用</a></li><li><a href="/FE-Interview-Questions/principle-docs/node/03-koa基本用法.html" class="sidebar-link">koa基本用法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>综合</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/01-虚拟DOM原理分析.html" class="sidebar-link">虚拟DOM原理分析</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/02-setTimeout实现原理和使用注意.html" class="sidebar-link">setTimeout实现原理和使用注意</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/03-浅析Promise原理.html" class="sidebar-link">浅析Promise原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/04-浏览器渲染原理.html" class="sidebar-link">浏览器渲染原理</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/05-前端面试之MVVM浅析.html" class="sidebar-link">前端面试之MVVM浅析</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/06-前端面试之组件化.html" class="sidebar-link">前端面试之组件化</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/07-虚拟DOM（一）.html" class="sidebar-link">虚拟DOM（一）</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/08-虚拟DOM（二）.html" class="sidebar-link">虚拟DOM（二）</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/09-前端性能之Performance.html" class="sidebar-link">前端性能之Performance</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/10-小程序开发实践.html" class="sidebar-link">小程序开发实践</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/11-对比 Koa 和 Redux-分析前端中的中间件理念.html" class="sidebar-link">对比 Koa 和 Redux</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/12-正则完整篇.html" class="sidebar-link">正则完整篇</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/13-打造前端监控系统.html" class="sidebar-link">打造前端监控系统</a></li><li><a href="/FE-Interview-Questions/principle-docs/comprehensive/14-浏览器渲染机制.html" class="sidebar-link">浏览器渲染机制</a></li></ul></section></li></ul> </aside> <main class="page"> <div id="container" class="theme-default-content lock"><div class="content__default"><p>通过对整个 ReactDOM.render 所触发的渲染链路进行了分析和串联，我们已经把 Fiber 架构在实现层面的大部分要点都过了一遍。刚讲过的这部分知识，一方面相对来说复杂度比较高，需要一些耐心反复地理解和消化；另一方面，本讲接下来要讲解的内容，也和它存在着较强的依赖关系，因此对这些前置知识的把握就显得尤为重要。</p> <p>下面我说几个函数，帮你检验一下自己的学习效果：</p> <ul><li><code>performSyncWorkOnRoot</code></li> <li><code>workLoopSync</code></li> <li><code>performUnitOfWork</code></li> <li><code>beginWork</code></li> <li><code>completeWork</code></li> <li><code>completeUnitOfWork</code></li> <li><code>reconcileChildFibers</code></li></ul> <p>本讲我将带你去认识 Fiber 架构最迷人的那一面——<code>Concurrent 模式</code>（异步渲染）下的“时间切片”和“优先级”实现。</p> <h2 id="current-树-与-workinprogress-树-双缓冲-模式在-fiber-架构下的实现"><a href="#current-树-与-workinprogress-树-双缓冲-模式在-fiber-架构下的实现" class="header-anchor">#</a> current 树 与 workInProgress 树：“双缓冲”模式在 Fiber 架构下的实现</h2> <h3 id="什么是-双缓冲-模式"><a href="#什么是-双缓冲-模式" class="header-anchor">#</a> 什么是“双缓冲”模式</h3> <p>“双缓冲”模式其实是一种在游戏领域由来已久的经典设计模式。为了帮助你快速理解它，这里我先举一个生活中的例子：假如你去看一场总时长只有 1 个小时的话剧，这场话剧中场不休息，需要不间断地演出。</p> <p>按照剧情的需求，半个小时处需要一次转场。所谓转场，就是说话剧舞台的灯光、布景、氛围等全部要切换到另一种风格里去。在不中断演出的情况下，想要实现转场，怎么办呢？场务工作做得再快，也要十几二十分钟，这对一场时长 1 小时的话剧来说，实在太漫长了。观众也无法接受这样的剧情“卡顿”体验。</p> <p>有一种解法，那就是准备两个舞台来做这场戏，当第一个舞台处于使用中时，第二个舞台的布局已经完成。这样当第一个舞台的表演结束时，只需要把第一个舞台的灯光灭掉，第二个舞台的灯光亮起，就可以做到剧情的无缝衔接了。</p> <p>事实上，在真实的话剧中，我们也确实常常看到这样的画面——演员从舞台的左侧走到了右侧，灯光一切换，就从卧室（左侧舞台）走到了公园（右侧舞台）；又从公园（右侧舞台）走到了办公室（左侧舞台）。左侧舞台的布景从卧室变成了办公室，这个过程正是在演员利用右侧舞台表演时完成的。</p> <p>在这个过程中，我们可以认为，左侧舞台和右侧舞台分别是两套缓冲数据，而呈现在观众眼前的连贯画面，就是不同的缓冲数据交替被读取后的结果。</p> <p>在计算机图形领域，通过让图形硬件交替读取两套缓冲数据，可以实现画面的无缝切换，减少视觉效果上的抖动甚至卡顿。而在 React 中，双缓冲模式的主要利好，则是<code>能够帮我们较大限度地实现 Fiber 节点的复用，从而减少性能方面的开销</code>。</p> <h3 id="current-树与-workinprogress-树之间是如何-相互利用-的"><a href="#current-树与-workinprogress-树之间是如何-相互利用-的" class="header-anchor">#</a> current 树与 workInProgress 树之间是如何“相互利用”的</h3> <p>在 React 中，current 树与 workInProgress 树，两棵树可以对标“双缓冲”模式下的两套缓冲数据：当 current 树呈现在用户眼前时，所有的更新都会由 workInProgress 树来承接。workInProgress 树将会在用户看不到的地方（内存里）悄悄地完成所有改变，直到“灯光”打到它身上，也就是 current 指针指向它的时候，此时就意味着 commit 阶段已经执行完毕，workInProgress 树变成了那棵呈现在界面上的 current 树。</p> <p>接下来我将用一个 Demo，带你切身感受一把 workInProgress 树和 current 树“相互利用”的过程。代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function">setState</span><span class="token punctuation">(</span>state <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> width<span class="token operator">:</span> <span class="token number">128</span><span class="token punctuation">,</span> textAlign<span class="token operator">:</span> <span class="token string">'center'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
          <span class="token punctuation">{</span>state<span class="token punctuation">}</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre></div><p>这个组件挂载后呈现出的界面很简单，就是一个数字 0，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502092851.png" alt=""></p> <h3 id="挂载后的-fiber-树"><a href="#挂载后的-fiber-树" class="header-anchor">#</a> 挂载后的 Fiber  树</h3> <p>关于 Fiber 树的构建过程，前面已经详细讲解过，这里不再重复。下面我直接为你展示挂载时的 render 阶段结束后，commit 执行前，两棵 Fiber 树的形态，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502092910.png" alt=""></p> <p>待 commit 阶段完成后，右侧的 workInProgress 树对应的 DOM 树就被真正渲染到了页面上，此时 current 指针会指向 workInProgress 树：</p> <p><img src="http://img-repo.poetries.top/images/20210502092926.png" alt=""></p> <p>由于挂载是一个从无到有的过程，在这个过程中我们是在不断地创建新节点，因此还谈不上什么“节点复用”。节点复用要到更新过程中去看。</p> <p><strong>第一次更新</strong></p> <p>现在我点击数字 0，触发一次更新。这次更新中，下图高亮的 rootFiber 节点就会被复用：</p> <p><img src="http://img-repo.poetries.top/images/20210502092947.png" alt=""></p> <p>这段复用的逻辑在 beginWork 调用链路中的 createWorkInProgress 方法里。这里我为你截取了 createWorkInProgress 方法里面一段非常关键的逻辑，请看下图：</p> <p><img src="http://img-repo.poetries.top/images/20210502093001.png" alt=""></p> <p>在 createWorkInProgress 方法中，会先取当前节点的 alternate 属性，将其记为 workInProgress 节点。对于 rootFiber 节点来说，它的 alternate 属性，其实就是上一棵 current 树的 rootFiber，如下图高亮部分所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502093019.png" alt=""></p> <p>当检查到上一棵 current 树的 rootFiber 存在时，React 会直接复用这个节点，让它作为下一棵 workInProgress 的节点存在下去，也就是说会走进 createWorkInProgress 的 else 逻辑里去。如果它和目标的 workInProgress 节点之间存在差异，直接在该节点上修改属性、使其与目标节点一致即可，而不必再创建新的 Fiber 节点。</p> <p>至于剩下的 App、div、p 等节点，由于没有对应的 alternate 节点存在，因此它们的 createWorkInProgress 调用会走进下图高亮处的逻辑中：</p> <p><img src="http://img-repo.poetries.top/images/20210502093033.png" alt=""></p> <p>在这段逻辑里，将调用 createFiber 来新建一个 FiberNode。</p> <p>第一次更新结束后，我们会得到一棵新的 workInProgress Fiber 树，current 指针最后将会指向这棵新的 workInProgress Fiber 树，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502093050.png" alt=""></p> <p><strong>第二次更新</strong></p> <p>接下来我们再次点击数字 1，触发 state 的第二次更新。</p> <p>在这次更新中，current 树中的每一个 alternate 属性都不为空（如上图所示）。因此每次通过 beginWork 触发 createWorkInProgress 调用时，都会一致地走入 else 里面的逻辑，也就是直接复用现成的节点。</p> <p>以上便是 current 树和 work 树相互“打配合”，实现节点复用的过程。</p> <h3 id="更新链路要素拆解"><a href="#更新链路要素拆解" class="header-anchor">#</a> 更新链路要素拆解</h3> <p>在上一讲，我们已经学习了挂载阶段的渲染链路。同步模式下的更新链路与挂载链路的 render 阶段基本是一致的，都是通过 performSyncWorkOnRoot 来触发包括 beginWork、completeWork 在内的深度优先搜索过程。这里我为你展示一个更新过程的调用栈，请看下图：</p> <p><img src="http://img-repo.poetries.top/images/20210502093120.png" alt=""></p> <p>你会发现还是熟悉的配方，还是原来的味道。其实，挂载可以理解为一种特殊的更新，ReactDOM.render 和 setState 一样，也是一种触发更新的姿势。在 React 中，ReactDOM.render、setState、useState 等方法都是可以触发更新的，这些方法发起的调用链路很相似，是因为它们最后“殊途同归”，都会通过创建 update 对象来进入同一套更新工作流。</p> <h2 id="update-的创建"><a href="#update-的创建" class="header-anchor">#</a> update 的创建</h2> <p>接下来我继续以开篇的 Demo 为例，为你拆解更新链路中的要素。在点击数字后，点击相关的回调被执行，它首先触发的是 dispatchAction 这个方法，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502093141.png" alt=""></p> <p>请你关注图中两处标红的函数调用，你会看到 dispatchAction 方法在 performSyncWorkOnRoot 的左边。也就是说整体的更新链路应该是这样的：</p> <p><img src="http://img-repo.poetries.top/images/20210502093156.png" alt=""></p> <p><code>dispatchAction</code> 中，会完成 update 对象的创建，如下图标红处所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502093208.png" alt=""></p> <h3 id="从-update-对象到-scheduleupdateonfiber"><a href="#从-update-对象到-scheduleupdateonfiber" class="header-anchor">#</a> 从 update 对象到 scheduleUpdateOnFiber</h3> <p>等等，这段逻辑你是否觉得似曾相识？如果你对 ReactDOM.render 系列的第一课时还有印象的话，我希望你能回忆起 updateContainer 这个方法。在 updateContainer 中，React 曾经有过性质一模一样的行为，这里我为你截取了 updateContainer 函数中的相关逻辑：</p> <p><img src="http://img-repo.poetries.top/images/20210502093233.png" alt=""></p> <p>图中这一段代码的逻辑是非常清晰的，以 enqueueUpdate 为界，它一共做了以下三件事。</p> <ul><li>enqueueUpdate 之前：创建 update。</li> <li>enqueueUpdate 调用：将 update 入队。这里简单说下，每一个 Fiber 节点都会有一个属于它自己的 updateQueue，用于存储多个更新，这个 updateQueue 是以链表的形式存在的。在 render 阶段，updateQueue 的内容会成为 render 阶段计算 Fiber 节点的新 state 的依据。</li> <li>scheduleUpdateOnFiber：调度 update。如果你对之前学过的知识还有印象，会记得同步挂载链路中，这个方法后面紧跟的就是 performSyncWorkOnRoot 所触发的 render 阶段，如下图所示：</li></ul> <p><img src="http://img-repo.poetries.top/images/20210502093304.png" alt=""></p> <p>现在我们再回过头来看 dispatchAction 的逻辑，你会发现 dispatchAction 里面同样有对这三个动作的处理。上面我对 dispatchAction 的局部截图，包含了对 update 对象的创建和入队处理。dispatchAction 的更新调度动作，在函数的末尾，如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502093315.png" alt=""></p> <p>这里有一个点需要提示一下：dispatchAction 中，调度的是当前触发更新的节点，这一点和挂载过程需要区分开来。在挂载过程中，updateContainer 会直接调度根节点。其实，对于更新这种场景来说，大部分的更新动作确实都不是由根节点触发的，而 render 阶段的起点则是根节点。因此在 scheduleUpdateOnFiber 中，有这样一个方法，见下图标红处：</p> <p><img src="http://img-repo.poetries.top/images/20210502093328.png" alt=""></p> <p>markUpdateLaneFromFiberToRoot 将会从当前 Fiber 节点开始，向上遍历直至根节点，并将根节点返回。</p> <h3 id="scheduleupdateonfiber-如何区分同步还是异步"><a href="#scheduleupdateonfiber-如何区分同步还是异步" class="header-anchor">#</a> scheduleUpdateOnFiber 如何区分同步还是异步？</h3> <p>如果你对之前学过的同步渲染链路分析还有印象，相信你对下面这段逻辑不会陌生：</p> <p><img src="http://img-repo.poetries.top/images/20210502093359.png" alt=""></p> <p>这是 scheduleUpdateOnFiber 中的一段逻辑。在同步的渲染链路中，lane === SyncLane 这个条件是成立的，因此会直接进入 performSyncWorkOnRoot 的逻辑，开启同步的 render 流程；而在异步渲染模式下，则将进入 else 的逻辑。</p> <p>在 else 中，需要引起你注意的是 ensureRootIsScheduled 这个方法，该方法很关键，它将决定如何开启当前更新所对应的 render 阶段。在 ensureRootIsScheduled 中，有这样一段核心逻辑（解析在注释里）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>newCallbackPriority <span class="token operator">===</span> SyncLanePriority<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 同步更新的 render 入口</span>
    newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将当前任务的 lane 优先级转换为 scheduler 可理解的优先级</span>
    <span class="token keyword">var</span> schedulerPriorityLevel <span class="token operator">=</span> <span class="token function">lanePriorityToSchedulerPriority</span><span class="token punctuation">(</span>newCallbackPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 异步更新的 render 入口</span>
    newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>schedulerPriorityLevel<span class="token punctuation">,</span> <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>请你关注performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 这两个方法：前者是同步更新模式下的 render 阶段入口；而后者是异步模式下的 render 阶段入口。</p> <p>从这段逻辑中我们可以看出，React 会以当前更新任务的优先级类型为依据，决定接下来是调度 performSyncWorkOnRoot 还是 performConcurrentWorkOnRoot。这里调度任务用到的函数分别是 scheduleSyncCallback 和 scheduleCallback，这两个函数在内部都是通过调用 unstable_scheduleCallback 方法来执行任务调度的。而 unstable_scheduleCallback 正是 Scheduler（调度器）中导出的一个核心方法，也是本讲的一个重点。</p> <p>在解读 unstable_scheduleCallback 的工作原理之前，我们先来一起认识一下 Scheduler。</p> <h2 id="scheduler-时间切片-与-优先级-的幕后推手"><a href="#scheduler-时间切片-与-优先级-的幕后推手" class="header-anchor">#</a> Scheduler——“时间切片”与“优先级”的幕后推手</h2> <p>Scheduler 从架构上来看，是 Fiber 架构分层中的“调度层”；从实现上来看，它并非一段内嵌的逻辑，而是一个与 react-dom 同级的文件夹，如下图所示，其中收敛了所有相对通用的调度逻辑：</p> <p><img src="http://img-repo.poetries.top/images/20210502093441.png" alt=""></p> <p>通过前面的学习，我们已经知道 Fiber 架构下的异步渲染（即 Concurrent 模式）的核心特征分别是“时间切片”与“优先级调度”。而这两点，也正是 Scheduler 的核心能力。接下来，我们就以这两个特征为线索，解锁 Scheduler 的工作原理。</p> <h3 id="结合-react-调用栈-理解时间切片现象"><a href="#结合-react-调用栈-理解时间切片现象" class="header-anchor">#</a> 结合 React 调用栈，理解时间切片现象</h3> <p>在理解时间切片的实现原理之前，我们首先要搞清楚时间切片是一种什么样的现象。</p> <p>在 ReactDOM.render 相关的课时中，我曾经强调过，同步渲染模式下的 render 阶段，是一个同步的、深度优先搜索的过程。同步的过程会带来什么样的麻烦呢？现在，我们直接通过调用栈来理解它，下面是一个渲染工作量相对比较大的 React Demo，代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> renderContent <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> width<span class="token operator">:</span> <span class="token number">128</span><span class="token punctuation">,</span> textAlign<span class="token operator">:</span> <span class="token string">'center'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">测试文本第</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>index<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">行</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>
          renderContent
        <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre></div><p>这个 App 组件会在界面上渲染出 1000 行文本，局部效果如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502093521.png" alt=""></p> <p>当我使用 ReactDOM.render 来渲染这个长列表时，它的调用栈如下图所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502093533.png" alt=""></p> <p>在这张图中，你就不必再重复去关注 beginWork、completeWork 之流了，请把目光放在调用栈的上层，也就是图中标红的地方——一个不间断的灰色“Task”长条，对浏览器来说就意味着是一个不可中断的任务。</p> <p>在我的浏览器上，这个 Task 的执行时长在 130ms 以上（将鼠标悬浮在 Task 长条上就可以查看执行时长）。而浏览器的刷新频率为 60Hz，也就是说每 16.6ms 就会刷新一次。在这 16.6ms 里，除了 JS 线程外，渲染线程也是有工作要处理的，但超长的 Task 显然会挤占渲染线程的工作时间，引起“掉帧”，进而带来卡顿的风险，这也正是第 12 讲中所提到的“JS 对主线程的超时占用”问题。</p> <p>若将 ReactDOM.render 调用改为 createRoot 调用（即开启 Concurrent 模式），调用栈就会变成下面这样：</p> <p><img src="http://img-repo.poetries.top/images/20210502093551.png" alt=""></p> <p>请继续将你的注意力放在顶层的 Task 长条上。</p> <p>你会发现那一个不间断的 Task 长条（大任务），如今像是被“切”过了一样，已经变成了多个断断续续的 Task “短条”（小任务），单个短 Task 的执行时长在我的浏览器中是 5ms 左右。这些短 Task 的工作量加起来，和之前长 Task 工作量是一样的。但短 Task 之间留出的时间缝隙，却给了浏览器喘息的机会，这就是所谓的“时间切片”效果。</p> <h3 id="时间切片是如何实现的"><a href="#时间切片是如何实现的" class="header-anchor">#</a> 时间切片是如何实现的？</h3> <p>在同步渲染中，循环创建 Fiber 节点、构建 Fiber 树的过程是由 workLoopSync 函数来触发的。这里我们来复习一下 workLoopSync 的源码，请看下图：</p> <p><img src="http://img-repo.poetries.top/images/20210502093618.png" alt=""></p> <p>在 workLoopSync 中，只要 workInProgress 不为空，while 循环就不会结束，它所触发的是一个同步的 performUnitOfWork 循环调用过程。</p> <p>而在异步渲染模式下，这个循环是由 workLoopConcurrent 来开启的。workLoopConcurrent 的工作内容和 workLoopSync 非常相似，仅仅在循环判断上有一处不同，请注意下图源码中标红部分：</p> <p><img src="http://img-repo.poetries.top/images/20210502093629.png" alt=""></p> <p>shouldYield 直译过来的话是“需要让出”。顾名思义，当 shouldYield() 调用返回为 true 时，就说明当前需要对主线程进行让出了，此时 whille 循环的判断条件整体为 false，while 循环将不再继续。</p> <p>那么这个 shouldYield 又是何方神圣呢？在源码中，我们可以寻得这样两行赋值语句：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Scheduler_shouldYield <span class="token operator">=</span> Scheduler<span class="token punctuation">.</span>unstable_shouldYield<span class="token punctuation">,</span>
<span class="token operator">...</span><span class="token operator">...</span>
<span class="token keyword">var</span> shouldYield <span class="token operator">=</span> Scheduler_shouldYield<span class="token punctuation">;</span>
</code></pre></div><p>从这两行代码中我们可以看出，shouldYield 的本体其实是 Scheduler.unstable_shouldYield，也就是 Scheduler 包中导出的 unstable_shouldYield 方法，该方法本身比较简单。其源码如下图标红处所示：</p> <p><img src="http://img-repo.poetries.top/images/20210502093654.png" alt=""></p> <p>其中 unstable_now 这里实际取的就是 performance.now() 的值，即“当前时间”。那么 deadline 又是什么呢？它可以被理解为当前时间切片的到期时间，它的计算过程在 Scheduler 包中的 performWorkUntilDeadline 方法里可以找到，也就是下图的标红部分：</p> <p><img src="http://img-repo.poetries.top/images/20210502093706.png" alt=""></p> <p>在这行算式里，currentTime 是当前时间，yieldInterval 是时间切片的长度。注意，时间切片的长度并不是一个常量，它是由 React 根据浏览器的帧率大小计算所得出来的，与浏览器的性能有关。</p> <p>现在我们来总结一下时间切片的实现原理：React 会根据浏览器的帧率，计算出时间切片的大小，并结合当前时间计算出每一个切片的到期时间。在 workLoopConcurrent 中，while 循环每次执行前，会调用 shouldYield 函数来询问当前时间切片是否到期，若已到期，则结束循环、出让主线程的控制权。</p> <h3 id="优先级调度是如何实现的"><a href="#优先级调度是如何实现的" class="header-anchor">#</a> 优先级调度是如何实现的</h3> <p>在“更新链路要素拆解”这一小节的末尾，我们已经知道，无论是 scheduleSyncCallback 还是 scheduleCallback，最终都是通过调用 unstable_scheduleCallback 来发起调度的。unstable_scheduleCallback 是 Scheduler 导出的一个核心方法，它将结合任务的优先级信息为其执行不同的调度逻辑。</p> <p>接下来我们就结合源码，一起看看这个过程是如何实现的（解析在注释里）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">unstable_scheduleCallback</span><span class="token punctuation">(</span><span class="token parameter">priorityLevel<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前时间</span>
  <span class="token keyword">var</span> currentTime <span class="token operator">=</span> exports<span class="token punctuation">.</span><span class="token function">unstable_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 声明 startTime，startTime 是任务的预期开始时间</span>
  <span class="token keyword">var</span> startTime<span class="token punctuation">;</span>
  <span class="token comment">// 以下是对 options 入参的处理</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> options <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> options <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> delay <span class="token operator">=</span> options<span class="token punctuation">.</span>delay<span class="token punctuation">;</span>

    <span class="token comment">// 若入参规定了延迟时间，则累加延迟时间</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> delay <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> delay <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      startTime <span class="token operator">=</span> currentTime <span class="token operator">+</span> delay<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      startTime <span class="token operator">=</span> currentTime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    startTime <span class="token operator">=</span> currentTime<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// timeout 是 expirationTime 的计算依据</span>
  <span class="token keyword">var</span> timeout<span class="token punctuation">;</span>
  <span class="token comment">// 根据 priorityLevel，确定 timeout 的值</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>priorityLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ImmediatePriority<span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">IMMEDIATE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> UserBlockingPriority<span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">USER_BLOCKING_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> IdlePriority<span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">IDLE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> LowPriority<span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">LOW_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> NormalPriority<span class="token operator">:</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">NORMAL_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 优先级越高，timout 越小，expirationTime 越小</span>
  <span class="token keyword">var</span> expirationTime <span class="token operator">=</span> startTime <span class="token operator">+</span> timeout<span class="token punctuation">;</span>

  <span class="token comment">// 创建 task 对象</span>
  <span class="token keyword">var</span> newTask <span class="token operator">=</span> <span class="token punctuation">{</span>
    id<span class="token operator">:</span> taskIdCounter<span class="token operator">++</span><span class="token punctuation">,</span>
    callback<span class="token operator">:</span> callback<span class="token punctuation">,</span>
    priorityLevel<span class="token operator">:</span> priorityLevel<span class="token punctuation">,</span>
    startTime<span class="token operator">:</span> startTime<span class="token punctuation">,</span>
    expirationTime<span class="token operator">:</span> expirationTime<span class="token punctuation">,</span>
    sortIndex<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token punctuation">{</span>
    newTask<span class="token punctuation">.</span>isQueued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 若当前时间小于开始时间，说明该任务可延时执行(未过期）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>startTime <span class="token operator">&gt;</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将未过期任务推入 &quot;timerQueue&quot;</span>
    newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> startTime<span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span>timerQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 若 taskQueue 中没有可执行的任务，而当前任务又是 timerQueue 中的第一个任务</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newTask <span class="token operator">===</span> <span class="token function">peek</span><span class="token punctuation">(</span>timerQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span><span class="token operator">...</span>
          <span class="token comment">// 那么就派发一个延时任务，这个延时任务用于检查当前任务是否过期</span>
      <span class="token function">requestHostTimeout</span><span class="token punctuation">(</span>handleTimeout<span class="token punctuation">,</span> startTime <span class="token operator">-</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// else 里处理的是当前时间大于 startTime 的情况，说明这个任务已过期</span>
    newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> expirationTime<span class="token punctuation">;</span>
    <span class="token comment">// 过期的任务会被推入 taskQueue</span>
    <span class="token function">push</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span><span class="token operator">...</span>

    <span class="token comment">// 执行 taskQueue 中的任务</span>
    <span class="token function">requestHostCallback</span><span class="token punctuation">(</span>flushWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newTask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从源码中我们可以看出，unstable_scheduleCallback 的主要工作是针对当前任务创建一个 task，然后结合 startTime 信息将这个 task 推入 timerQueue 或 taskQueue，最后根据 timerQueue 和 taskQueue 的情况，执行延时任务或即时任务。</p> <p>要想理解这个过程，首先要搞清楚以下几个概念。</p> <ul><li><code>startTime</code>：任务的开始时间。</li> <li><code>expirationTime</code>：这是一个和优先级相关的值，expirationTime 越小，任务的优先级就越高。</li> <li><code>timerQueue</code>：一个以 startTime 为排序依据的小顶堆，它存储的是 startTime 大于当前时间（也就是待执行）的任务。</li> <li><code>taskQueue</code>：一个以 expirationTime 为排序依据的小顶堆，它存储的是 startTime 小于当前时间（也就是已过期）的任务。</li></ul> <p>这里的“小顶堆”概念可能会触及一部分同学的知识盲区，我简单解释下：堆是一种特殊的完全二叉树。如果对一棵完全二叉树来说，它每个结点的结点值都不大于其左右孩子的结点值，这样的完全二叉树就叫“小顶堆”。小顶堆自身特有的插入和删除逻辑，决定了无论我们怎么增删小顶堆的元素，其根节点一定是所有元素中值最小的一个节点。这样的性质，使得小顶堆经常被用于实现优先队列。</p> <p>结合小顶堆的特性，我们再来看源码中涉及 timerQueue 和 taskQueue 的操作，这段代码同时也是整个 unstable_scheduleCallback 方法中的核心逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 若当前时间小于开始时间，说明该任务可延时执行(未过期）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>startTime <span class="token operator">&gt;</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将未过期任务推入 &quot;timerQueue&quot;</span>
    newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> startTime<span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span>timerQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 若 taskQueue 中没有可执行的任务，而当前任务又是 timerQueue 中的第一个任务</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newTask <span class="token operator">===</span> <span class="token function">peek</span><span class="token punctuation">(</span>timerQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span><span class="token operator">...</span>
          <span class="token comment">// 那么就派发一个延时任务，这个延时任务用于将过期的 task 加入 taskQueue 队列</span>
      <span class="token function">requestHostTimeout</span><span class="token punctuation">(</span>handleTimeout<span class="token punctuation">,</span> startTime <span class="token operator">-</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// else 里处理的是当前时间大于 startTime 的情况，说明这个任务已过期</span>
    newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> expirationTime<span class="token punctuation">;</span>
    <span class="token comment">// 过期的任务会被推入 taskQueue</span>
    <span class="token function">push</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span><span class="token operator">...</span>

    <span class="token comment">// 执行 taskQueue 中的任务</span>
    <span class="token function">requestHostCallback</span><span class="token punctuation">(</span>flushWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>若判断当前任务是待执行任务，那么该任务会在 sortIndex 属性被赋值为 startTime 后，被推入 timerQueue。随后，会进入这样的一段判断逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 若 taskQueue 中没有可执行的任务，而当前任务又是 timerQueue 中的第一个任务</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newTask <span class="token operator">===</span> <span class="token function">peek</span><span class="token punctuation">(</span>timerQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token operator">...</span>
    <span class="token comment">// 那么就派发一个延时任务，这个延时任务用于将过期的 task 加入 taskQueue 队列</span>
  <span class="token function">requestHostTimeout</span><span class="token punctuation">(</span>handleTimeout<span class="token punctuation">,</span> startTime <span class="token operator">-</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>要理解这段逻辑，首先需要理解 peek(xxx) 做了什么：peek() 的入参是一个小顶堆，它将取出这个小顶堆的堆顶元素。</p> <p>taskQueue 里存储的是已过期的任务，peek(taskQueue) 取出的任务若为空，则说明 taskQueue 为空、当前并没有已过期任务。在没有已过期任务的情况下，会进一步判断 timerQueue，也就是未过期任务队列里的情况。</p> <p>而通过前面的科普，大家已经知道了小顶堆是一个相对有序的数据结构。timerQueue 作为一个小顶堆，它的排序依据其实正是 sortIndex 属性的大小。这里的 sortIndex 属性取值为 startTime，意味着小顶堆的堆顶任务一定是整个 timerQueue 堆结构里 startTime 最小的任务，也就是需要最早被执行的未过期任务。</p> <p>若当前任务（newTask）就是 timerQueue 中需要最早被执行的未过期任务，那么 unstable_scheduleCallback 会通过调用 requestHostTimeout，为当前任务发起一个延时调用。</p> <p>注意，这个延时调用（也就是 handleTimeout）并不会直接调度执行当前任务——它的作用是在当前任务到期后，将其从 timerQueue 中取出，加入 taskQueue 中，然后触发对 flushWork 的调用。真正的调度执行过程是在 flushWork 中进行的。flushWork 中将调用 workLoop，workLoop 会逐一执行 taskQueue 中的任务，直到调度过程被暂停（时间片用尽）或任务全部被清空。</p> <p>以上便是针对未过期任务的处理。在这个基础上，我们不难理解 else 中，对过期任务的处理逻辑（也就是下面这段代码）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token comment">// else 里处理的是当前时间大于 startTime 的情况，说明这个任务已过期</span>
  newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> expirationTime<span class="token punctuation">;</span>
  <span class="token comment">// 过期的任务会被推入 taskQueue</span>
  <span class="token function">push</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">...</span><span class="token operator">...</span>
  <span class="token comment">// 执行 taskQueue 中的任务</span>
  <span class="token function">requestHostCallback</span><span class="token punctuation">(</span>flushWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>与 timerQueue 不同的是，taskQueue 是一个以 expirationTime 为 sortIndex（排序依据）的小顶堆。对于已过期任务，React 在将其推入 taskQueue 后，会通过 requestHostCallback(flushWork) 发起一个针对 flushWork 的即时任务，而 flushWork 会执行 taskQueue 中过期的任务。</p> <p>从 React 17.0.0 源码来看，当下 React 发起 Task 调度的姿势有两个：setTimeout、MessageChannel。在宿主环境不支持 MessageChannel 的情况下，会降级到 setTimeout。但不管是 setTimeout 还是 MessageChannel，它们发起的都是异步任务。</p> <p>因此  requestHostCallback 发起的“即时任务”最早也要等到下一次事件循环才能够执行。“即时”仅仅意味它相对于“延时任务”来说，不需要等待指定的时间间隔，并不意味着同步调用。</p> <p>这里为了方便大家理解，我将 unstable_scheduleCallback 方法的工作流总结进一张大图：</p> <p><img src="http://img-repo.poetries.top/images/20210502093842.png" alt=""></p> <p>这张大图需要结合楼上的文字解析一起消化，如果你是跳读至此，还请回到文章中细嚼慢咽~^_^</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>这一讲我们首先认识了“双缓存”模式在 Fiber 架构下的实现，接着对更新链路的种种要素进行了拆解，理解了挂载 / 更新等动作的本质。最后，我们结合源码对 Scheduler（调度器）的核心能力，也就是“时间切片”和“优先级调度”两个方面进行了剖析，最终揭开了 Fiber 架构异步渲染的神秘面纱，理解了Concurrent 模式背后的实现逻辑。</p></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/FE-Interview-Questions/principle-docs/react/19-ReactDOM.render 是如何串联渲染链路的.html" class="prev">ReactDOM.render 是如何串联渲染链路的</a></span> <span class="next"><a href="/FE-Interview-Questions/principle-docs/react/21-React 事件与 DOM 事件有何不同.html">React 事件与 DOM 事件有何不同</a>
      →
    </span></p></div>  <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="请先阅读购买协议" class="el-dialog el-dialog--center" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">请先阅读购买协议</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button disabled="disabled" type="button" class="el-button el-button--danger is-disabled" style="width:100%;"><!----><!----><span>我已阅读（8s）</span></button></span></div></div></div> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="付费阅读" class="el-dialog" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">付费阅读</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button disabled="disabled" type="button" class="el-button el-button--danger is-disabled" style="width:100%;"><!----><!----><span>确 定</span></button></span></div></div></div> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="dialog" class="el-dialog" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title"></span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div> <img src="data:image/png;base64,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" class="theme-float-btn"></main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/FE-Interview-Questions/assets/js/app.d3236e00.js" defer></script><script src="/FE-Interview-Questions/assets/js/5.8734293f.js" defer></script><script src="/FE-Interview-Questions/assets/js/4.a9037b86.js" defer></script><script src="/FE-Interview-Questions/assets/js/121.0b52a657.js" defer></script><script src="/FE-Interview-Questions/assets/js/11.20ed5a18.js" defer></script>
  </body>
</html>
