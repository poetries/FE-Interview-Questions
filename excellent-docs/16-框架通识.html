<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1 MVVM | 面试指南</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/FE-Interview-Questions/logo.png">
    <link rel="manifest" href="/FE-Interview-Questions/manifest.json">
    <link rel="apple-touch-icon" href="/FE-Interview-Questions/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/FE-Interview-Questions/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="web前端面试题总结，面试指南，前端面试题整理，web面试宝典，刷题神器，按模块分类整理总结，打造最全面的前端面试题">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/FE-Interview-Questions/assets/css/0.styles.c50a8daf.css" as="style"><link rel="preload" href="/FE-Interview-Questions/assets/js/app.58edb9ce.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/5.035c7bc0.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/4.d083826f.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/69.3c2cfb0d.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/11.073738bd.js" as="script"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/1.fb66e5d5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/10.23f0a638.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/100.b8b89dd3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/101.d1efeceb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/102.4de9268d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/103.3ee82290.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/104.9d34cf9a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/105.cb91db82.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/106.7997e494.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/107.a85ef15a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/108.ba09e040.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/109.2b4ec00e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/110.437a6da9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/111.4e4cc21d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/112.816c4cb9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/113.2f2fe049.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/114.6cbd8ba5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/115.09b7246e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/116.4949ea01.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/117.0ac606c0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/118.fd87c147.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/119.3473721c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/12.685cd31a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/120.75600f1c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/121.d0c65067.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/122.ceada77d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/123.201f5fdb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/124.0d67fccf.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/125.71e894a0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/126.7a2c302b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/127.492b26fb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/128.27cfc908.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/129.7b1bea22.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/13.28b1ec93.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/130.cf0d1274.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/131.693c1163.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/132.ebfa6946.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/133.7109652e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/134.c31a5f7c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/135.28662e80.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/136.f5fe1744.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/137.8fe30dfb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/138.5936adf4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/139.74d19aa9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/14.09e699c1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/140.290a3847.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/141.ae9de95e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/142.f4058730.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/143.857a8198.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/144.db7f025d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/145.bb706bc4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/146.ff313333.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/147.e63f0766.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/148.2a9fbd5f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/149.2b98191d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/15.15b4b2b5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/150.fb5f8181.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/151.6b4f8864.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/16.cc6cf2ae.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/17.c463925b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/18.14363275.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/19.497aa643.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/20.26efce1b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/21.bd0b54b0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/22.ab70e1f1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/23.184987c0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/24.8b22bdd0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/25.f7aeefe6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/26.f98c905a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/27.8c9878d2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/28.6806a811.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/29.66da1646.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/3.3078c011.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/30.f8a107b2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/31.0a0e518e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/32.b9be1b29.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/33.18aad37f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/34.b8436f4a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/35.e8794e15.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/36.a8198532.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/37.db8e1fe7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/38.12b7245f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/39.81152f78.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/40.a3f9b732.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/41.0a8d86df.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/42.dde6db07.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/43.c950312f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/44.3a19db81.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/45.b0a4ec11.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/46.c3a92a8c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/47.485f71e4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/48.5102edc3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/49.33f5348b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/50.422fc51a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/51.96fa6875.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/52.7c08afef.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/53.dd385a46.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/54.66e141d0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/55.8a055ff2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/56.8a9281f6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/57.b6c9ba4e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/58.7b21c169.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/59.7518cfd5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/6.c94d65ce.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/60.7c4edeb5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/61.d3748cba.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/62.868e2273.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/63.7ddbd530.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/64.f5230c43.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/65.89f78e71.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/66.1b2f7e90.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/67.801066f1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/68.1bd192ad.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/7.391896ff.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/70.4ac9c192.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/71.c33b68e5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/72.3b16d2d0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/73.10930a7a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/74.6dcffcf9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/75.9c3e8322.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/76.962cfaba.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/77.95c63e6c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/78.5a9dc449.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/79.f01cc2b8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/8.d7534d4e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/80.6d4a0fad.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/81.81c03ed7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/82.7f7c4c39.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/83.cf952951.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/84.3e666841.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/85.36472e58.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/86.d04c05bf.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/87.f5154090.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/88.fa9ae655.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/89.366b0b82.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/9.c80fbc2e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/90.c04d0d9a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/91.ebe056cf.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/92.4407d2db.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/93.9f7f67a4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/94.dce08c5a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/95.cf79b909.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/96.f8a54b7d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/97.0fedbf81.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/98.2fc31690.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/99.bf168948.js">
    <link rel="stylesheet" href="/FE-Interview-Questions/assets/css/0.styles.c50a8daf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/FE-Interview-Questions/" class="home-link router-link-active"><img src="/FE-Interview-Questions/logo.png" alt="面试指南" class="logo"> <span class="site-name can-hide">面试指南</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!----> <div style="padding-left:1.5rem;"><div class="qr"><img src="/FE-Interview-Questions/assets/img/qr.ee193d28.jpg" alt="poetries" width="120" height="120" loading="lazy"> <p class="we-intro">
    关注公众号，获取更多资讯
  </p></div></div> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>精选模块</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/excellent-docs/1-HTML模块.html" class="sidebar-link">1 HTML模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/2-CSS模块.html" class="sidebar-link">2 CSS模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/3-JS模块.html" class="sidebar-link">3 JS模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/4-ES6模块.html" class="sidebar-link">4 ES6模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/5-浏览器模块.html" class="sidebar-link">5 浏览器模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/6-React.html" class="sidebar-link">6 React模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html" class="sidebar-link">7 Vue模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/8-Node模块.html" class="sidebar-link">8 Node模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/9-前端工程模块.html" class="sidebar-link">9 前端工程相关</a></li><li><a href="/FE-Interview-Questions/excellent-docs/10-移动多端开发.html" class="sidebar-link">10 移动多端开发</a></li><li><a href="/FE-Interview-Questions/excellent-docs/11-小程序模块.html" class="sidebar-link">11 小程序模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/12-前端安全模块.html" class="sidebar-link">12 前端安全模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/13-性能优化模块.html" class="sidebar-link">13 性能优化相关</a></li><li><a href="/FE-Interview-Questions/excellent-docs/14-HTTP模块.html" class="sidebar-link">14 HTTP模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/15-设计模式.html" class="sidebar-link">15 常用设计模式</a></li><li><a href="/FE-Interview-Questions/excellent-docs/16-框架通识.html" class="active sidebar-link">16 框架通识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/16-框架通识.html#_1-mvvm" class="sidebar-link">1 MVVM</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/16-框架通识.html#_2-路由原理" class="sidebar-link">2 路由原理</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/16-框架通识.html#_3-virtual-dom" class="sidebar-link">3 Virtual Dom</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/16-框架通识.html#_4-diff算法" class="sidebar-link">4 Diff算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/16-框架通识.html#_4-1-react-diff" class="sidebar-link">4.1 React-Diff</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/16-框架通识.html#_4-2-vue2-x-diff-双端比较" class="sidebar-link">4.2 Vue2.X Diff —— 双端比较</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/16-框架通识.html#_4-3-vue3-diff-最长递增子序列" class="sidebar-link">4.3 Vue3 Diff —— 最长递增子序列</a></li></ul></li></ul></li><li><a href="/FE-Interview-Questions/excellent-docs/17-排序算法.html" class="sidebar-link">17 排序算法</a></li><li><a href="/FE-Interview-Questions/excellent-docs/18-计算机通识.html" class="sidebar-link">18 计算机通识</a></li></ul></section></li></ul> </aside> <main class="page"> <div id="container" class="theme-default-content lock"><div class="content__default"><h2 id="_1-mvvm"><a href="#_1-mvvm" class="header-anchor">#</a> 1 MVVM</h2> <blockquote><p><code>MVVM</code> 由以下三个内容组成</p></blockquote> <ul><li><code>View</code>：界面</li> <li><code>Model</code>：数据模型</li> <li><code>ViewModel</code>：作为桥梁负责沟通 <code>View</code> 和 <code>Model</code></li></ul> <blockquote><p>在 <code>JQuery</code> 时期，如果需要刷新 <code>UI</code> 时，需要先取到对应的 <code>DOM</code> 再更新 <code>UI</code>，这样数据和业务的逻辑就和页面有强耦合。</p></blockquote> <div class="custom-block tip"><p class="custom-block-title">MVVM</p> <p>在 <code>MVVM</code> 中，<code>UI</code> 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 <code>UI</code>，<code>UI</code> 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。<code>ViewModel</code> 只关心数据和业务的处理，不关心 <code>View</code> 如何处理数据，在这种情况下，<code>View</code> 和 <code>Model</code> 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 <code>ViewModel</code> 中，让多个 <code>View</code>复用这个 <code>ViewModel</code>。</p></div> <ul><li>在 <code>MVVM</code> 中，最核心的也就是数据双向绑定，例如 <code>Angluar</code> 的脏数据检测，<code>Vue</code> 中的数据劫持。</li></ul> <p><strong>脏数据检测</strong></p> <blockquote><p>当触发了指定事件后会进入脏数据检测，这时会调用 <code>$digest</code> 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 <code>$watch</code> 函数，然后再次调用 <code>$digest</code> 循环直到发现没有变化。循环至少为二次 ，至多为十次。</p></blockquote> <blockquote><p>脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 <code>Vue</code> 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 <code>UI</code>，大大减少了操作 <code>DOM</code> 的次数。所以低效也是相对的，这就仁者见仁智者见智了。</p></blockquote> <p><strong>数据劫持</strong></p> <blockquote><p><code>Vue</code> 内部使用了 <code>Object.defineProperty()</code> 来实现双向绑定，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'yck'</span> <span class="token punctuation">}</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">let</span> name <span class="token operator">=</span> data<span class="token punctuation">.</span>name <span class="token comment">// -&gt; get value</span>
data<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yyy'</span> <span class="token comment">// -&gt; change value</span>

<span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断类型</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 递归子属性</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get value'</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> val
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'change value'</span><span class="token punctuation">)</span>
      val <span class="token operator">=</span> newVal
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    {{name}}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><blockquote><p>在解析如上模板代码时，遇到 <code>{name}</code> 就会给属性 <code>name</code> 添加发布订阅。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 通过 Dep 解耦</span>
<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token function">addSub</span><span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// sub 是 Watcher 实例</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">sub</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 全局属性，通过该属性配置 Watcher</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> value
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将 Dep.target 指向自己</span>
    <span class="token comment">// 然后触发属性的 getter 添加监听</span>
    <span class="token comment">// 最后将 Dep.target 置空</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb
    <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获得新值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span>
    <span class="token comment">// 调用 update 方法更新 Dom</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'yck'</span> <span class="token punctuation">}</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token comment">// 模拟解析到 `{{name}}` 触发的操作</span>
<span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
<span class="token comment">// update Dom innerText</span>
data<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yyy'</span>
</code></pre></div><blockquote><p>接下来,对 <code>defineReactive</code> 函数进行改造</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 递归子属性</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
  <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get value'</span><span class="token punctuation">)</span>
      <span class="token comment">// 将 Watcher 添加到订阅</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> val
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'change value'</span><span class="token punctuation">)</span>
      val <span class="token operator">=</span> newVal
      <span class="token comment">// 执行 watcher 的 update 方法</span>
      dp<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 <code>getter</code> 来实现发布订阅的添加</p></blockquote> <p><strong>Proxy 与 Object.defineProperty 对比</strong></p> <blockquote><p><code>Object.defineProperty</code> 虽然已经能够实现双向绑定了，但是他还是有缺陷的。</p></blockquote> <ul><li>只能对属性进行数据劫持，所以需要深度遍历整个对象
对于数组不能监听到数据的变化</li> <li>虽然 <code>Vue</code> 中确实能检测到数组数据的变化，但是其实是使用了 <code>hack</code>的办法，并且也是有缺陷的。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>
<span class="token comment">// hack 以下几个函数</span>
<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获得原生函数</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用原生函数</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">let</span> inserted
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
    <span class="token comment">// 触发更新</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>反观 <code>Proxy</code>就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 <code>Vue</code> 也将在下个大版本中使用 <code>Proxy</code> 替换 <code>Object.defineProperty</code></p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">onWatch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> setBind<span class="token punctuation">,</span> getLogger</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">getLogger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">)</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setBind</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> value
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token function">onWatch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  value <span class="token operator">=</span> v
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> property</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Get '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>property<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">' = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token punctuation">[</span>property<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// bind `value` to `2`</span>
p<span class="token punctuation">.</span>a <span class="token comment">// -&gt; Get 'a' = 2</span>
</code></pre></div><h2 id="_2-路由原理"><a href="#_2-路由原理" class="header-anchor">#</a> 2 路由原理</h2> <blockquote><p>前端路由实现起来其实很简单，本质就是监听 <code>URL</code> 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式</p></blockquote> <ul><li><code>hash</code> 模式</li> <li><code>history</code> 模式</li></ul> <blockquote><p><code>www.test.com/##/</code> 就是 <code>Hash URL</code>，当 <code>##</code> 后面的哈希值发生变化时，不会向服务器请求数据，可以通过
<code>hashchange</code> 事件来监听到 <code>URL</code> 的变化，从而进行跳转页面。</p></blockquote> <p><img src="https://poetries1.gitee.io/img-repo/2020/09/99.png" alt=""></p> <blockquote><p><code>History</code>模式是 <code>HTML5</code> 新推出的功能，比之 <code>Hash URL</code> 更加美观</p></blockquote> <p><img src="https://poetries1.gitee.io/img-repo/2020/09/100.png" alt=""></p> <h2 id="_3-virtual-dom"><a href="#_3-virtual-dom" class="header-anchor">#</a> 3 Virtual Dom</h2> <p><strong>为什么需要 Virtual Dom</strong></p> <blockquote><p>众所周知，操作 <code>DOM</code> 是很耗费性能的一件事情，既然如此，我们可以考虑通过 <code>JS</code> 对象来模拟 <code>DOM</code> 对象，毕竟操作 <code>JS</code> 对象比操作 <code>DOM</code> 省时的多</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment">// 这里替换上面的 li</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
</code></pre></div><blockquote><p>从上述例子中，我们一眼就可以看出先前的 <code>ul</code> 中的第三个 <code>li</code> 被移除了，四五替换了位置。</p></blockquote> <ul><li>如果以上操作对应到 <code>DOM</code> 中，那么就是以下代码</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 删除第三个 li</span>
ul<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 将第四个 li 和第五个交换位置</span>
<span class="token keyword">let</span> fromNode <span class="token operator">=</span> ul<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> toNode <span class="token operator">=</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> cloneFromNode <span class="token operator">=</span> fromNode<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> cloenToNode <span class="token operator">=</span> toNode<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
ul<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>cloneFromNode<span class="token punctuation">,</span> toNode<span class="token punctuation">)</span>
ul<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>cloenToNode<span class="token punctuation">,</span> fromNode<span class="token punctuation">)</span>
</code></pre></div><blockquote><p>当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 <code>Vue</code> 和 <code>React</code> 中官方推荐列表里的节点使用唯一的 <code>key</code> 来保证性能。</p></blockquote> <ul><li>那么既然 <code>DOM</code> 对象可以通过 <code>JS</code> 对象来模拟，反之也可以通过 <code>JS</code> 对象来渲染出对应的 <code>DOM</code></li> <li>以下是一个 <code>JS</code> 对象模拟 <code>DOM</code> 对象的简单实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Element</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * @param {String} tag 'div'
   * @param {Object} props { class: 'item' }
   * @param {Array} children [ Element1, 'text']
   * @param {String} key option
   */</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag
    <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> children
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> children
      <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key
  <span class="token punctuation">}</span>
  <span class="token comment">// 渲染</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_createElement</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tag<span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>key
    <span class="token punctuation">)</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token keyword">return</span> root
  <span class="token punctuation">}</span>
  <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_createElement</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tag<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 创建节点</span>
  <span class="token function">_createElement</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> child<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过 tag 创建节点</span>
    <span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
    <span class="token comment">// 设置节点属性</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> value <span class="token operator">=</span> props<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 递归添加子节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      child<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">element</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> child
        <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token keyword">instanceof</span> <span class="token class-name">Element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          child <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_createElement</span><span class="token punctuation">(</span>
            element<span class="token punctuation">.</span>tag<span class="token punctuation">,</span>
            element<span class="token punctuation">.</span>props<span class="token punctuation">,</span>
            element<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
            element<span class="token punctuation">.</span>key
          <span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          child <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> el
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>Virtual Dom 算法简述</strong></p> <ul><li>既然我们已经通过 <code>JS</code> 来模拟实现了 <code>DOM</code>，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。</li> <li><code>DOM</code> 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 <code>O(n ^ 3)</code>，这个复杂度肯定是不能接受的。于是 <code>React</code>团队优化了算法，实现了 <code>O(n)</code> 的复杂度来对比差异。</li> <li>实现<code>O(n)</code> 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 <code>DOM</code> 元素</li></ul> <blockquote><p>所以判断差异的算法就分为了两步</p></blockquote> <ul><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li> <li>一旦节点有子元素，就去判断子元素是否有不同</li></ul> <p><strong>Virtual Dom 算法实现</strong></p> <p><strong>树的递归</strong></p> <ul><li>首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况</li> <li>新的节点的 <code>tagName</code> 或者 <code>key</code> 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了</li> <li>新的节点的 <code>tagName</code> 和 <code>key</code>（可能都没有）和旧的相同，开始遍历子树</li> <li>没有新的节点，那么什么都不用做</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> StateEnums<span class="token punctuation">,</span> isString<span class="token punctuation">,</span> move <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./util'</span>
<span class="token keyword">import</span> Element <span class="token keyword">from</span> <span class="token string">'./element'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">diff</span><span class="token punctuation">(</span><span class="token parameter">oldDomTree<span class="token punctuation">,</span> newDomTree</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用于记录差异</span>
  <span class="token keyword">let</span> pathchs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 一开始的索引为 0</span>
  <span class="token function">dfs</span><span class="token punctuation">(</span>oldDomTree<span class="token punctuation">,</span> newDomTree<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> pathchs<span class="token punctuation">)</span>
  <span class="token keyword">return</span> pathchs
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">oldNode<span class="token punctuation">,</span> newNode<span class="token punctuation">,</span> index<span class="token punctuation">,</span> patches</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用于保存子树的更改</span>
  <span class="token keyword">let</span> curPatches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 需要判断三种情况</span>
  <span class="token comment">// 1.没有新的节点，那么什么都不用做</span>
  <span class="token comment">// 2.新的节点的 tagName 和 `key` 和旧的不同，就替换</span>
  <span class="token comment">// 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode<span class="token punctuation">.</span>tag <span class="token operator">===</span> oldNode<span class="token punctuation">.</span>tag <span class="token operator">&amp;&amp;</span> newNode<span class="token punctuation">.</span>key <span class="token operator">===</span> oldNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断属性是否变更</span>
    <span class="token keyword">let</span> props <span class="token operator">=</span> <span class="token function">diffProps</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">.</span>props<span class="token punctuation">,</span> newNode<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>length<span class="token punctuation">)</span> curPatches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> StateEnums<span class="token punctuation">.</span>ChangeProps<span class="token punctuation">,</span> props <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 遍历子树</span>
    <span class="token function">diffChildren</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span> newNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span> index<span class="token punctuation">,</span> patches<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 节点不同，需要替换</span>
    curPatches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> StateEnums<span class="token punctuation">.</span>Replace<span class="token punctuation">,</span> node<span class="token operator">:</span> newNode <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>curPatches<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>patches<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      patches<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> patches<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>curPatches<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      patches<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> curPatches
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>判断属性的更改</strong></p> <blockquote><p>判断属性的更改也分三个步骤</p></blockquote> <ul><li>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</li> <li>遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化</li> <li>在第二步中同时查看是否有属性不存在与旧的属性列列表中</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">diffProps</span><span class="token punctuation">(</span><span class="token parameter">oldProps<span class="token punctuation">,</span> newProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断 Props 分以下三步骤</span>
  <span class="token comment">// 先遍历 oldProps 查看是否存在删除的属性</span>
  <span class="token comment">// 然后遍历 newProps 查看是否有属性值被修改</span>
  <span class="token comment">// 最后查看是否有属性新增</span>
  <span class="token keyword">let</span> change <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> oldProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldProps<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>newProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      change<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        prop<span class="token operator">:</span> key
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> newProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newProps<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prop <span class="token operator">=</span> newProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> oldProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> newProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        change<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          prop<span class="token operator">:</span> key<span class="token punctuation">,</span>
          value<span class="token operator">:</span> newProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        change<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          prop<span class="token operator">:</span> key<span class="token punctuation">,</span>
          value<span class="token operator">:</span> newProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> change
<span class="token punctuation">}</span>
</code></pre></div><p><strong>判断列表差异算法实现</strong></p> <blockquote><p>这个算法是整个 <code>Virtual Dom</code> 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步</p></blockquote> <ul><li>遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中</li> <li>遍历新的节点列表，判断是否有新的节点</li> <li>在第二步中同时判断节点是否有移动</li></ul> <blockquote><p>PS：该算法只对有 <code>key</code> 的节点做处理</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">listDiff</span><span class="token punctuation">(</span><span class="token parameter">oldList<span class="token punctuation">,</span> newList<span class="token punctuation">,</span> index<span class="token punctuation">,</span> patches</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 为了遍历方便，先取出两个 list 的所有 keys</span>
  <span class="token keyword">let</span> oldKeys <span class="token operator">=</span> <span class="token function">getKeys</span><span class="token punctuation">(</span>oldList<span class="token punctuation">)</span>
  <span class="token keyword">let</span> newKeys <span class="token operator">=</span> <span class="token function">getKeys</span><span class="token punctuation">(</span>newList<span class="token punctuation">)</span>
  <span class="token keyword">let</span> changes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  <span class="token comment">// 用于保存变更后的节点数据</span>
  <span class="token comment">// 使用该数组保存有以下好处</span>
  <span class="token comment">// 1.可以正确获得被删除节点索引</span>
  <span class="token comment">// 2.交换节点位置只需要操作一遍 DOM</span>
  <span class="token comment">// 3.用于 `diffChildren` 函数中的判断，只需要遍历</span>
  <span class="token comment">// 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要</span>
  <span class="token comment">// 再去判断一遍</span>
  <span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  oldList <span class="token operator">&amp;&amp;</span>
    oldList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> key <span class="token operator">=</span> item<span class="token punctuation">.</span>key
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        key <span class="token operator">=</span> item
      <span class="token punctuation">}</span>
      <span class="token comment">// 寻找新的 children 中是否含有当前节点</span>
      <span class="token comment">// 没有的话需要删除</span>
      <span class="token keyword">let</span> index <span class="token operator">=</span> newKeys<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 遍历变更后的数组</span>
  <span class="token keyword">let</span> length <span class="token operator">=</span> list<span class="token punctuation">.</span>length
  <span class="token comment">// 因为删除数组元素是会更改索引的</span>
  <span class="token comment">// 所有从后往前删可以保证索引不变</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断当前元素是否为空，为空表示需要删除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      list<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
      changes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        type<span class="token operator">:</span> StateEnums<span class="token punctuation">.</span>Remove<span class="token punctuation">,</span>
        index<span class="token operator">:</span> i
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 遍历新的 list，判断是否有节点新增或移动</span>
  <span class="token comment">// 同时也对 `list` 做节点新增和移动节点的操作</span>
  newList <span class="token operator">&amp;&amp;</span>
    newList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> key <span class="token operator">=</span> item<span class="token punctuation">.</span>key
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        key <span class="token operator">=</span> item
      <span class="token punctuation">}</span>
      <span class="token comment">// 寻找旧的 children 中是否含有当前节点</span>
      <span class="token keyword">let</span> index <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token comment">// 没找到代表新节点，需要插入</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        changes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          type<span class="token operator">:</span> StateEnums<span class="token punctuation">.</span>Insert<span class="token punctuation">,</span>
          node<span class="token operator">:</span> item<span class="token punctuation">,</span>
          index<span class="token operator">:</span> i
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        list<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 找到了，需要判断是否需要移动</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          changes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            type<span class="token operator">:</span> StateEnums<span class="token punctuation">.</span>Move<span class="token punctuation">,</span>
            from<span class="token operator">:</span> index<span class="token punctuation">,</span>
            to<span class="token operator">:</span> i
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token function">move</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> index<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> changes<span class="token punctuation">,</span> list <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getKeys</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">let</span> text
  list <span class="token operator">&amp;&amp;</span>
    list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> key
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        key <span class="token operator">=</span> <span class="token punctuation">[</span>item<span class="token punctuation">]</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">instanceof</span> <span class="token class-name">Element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        key <span class="token operator">=</span> item<span class="token punctuation">.</span>key
      <span class="token punctuation">}</span>
      keys<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> keys
<span class="token punctuation">}</span>
</code></pre></div><p><strong>遍历子元素打标识</strong></p> <blockquote><p>对于这个函数来说，主要功能就两个</p></blockquote> <ul><li>判断两个列表差异
<ul><li>给节点打上标记</li> <li>总体来说，该函数实现的功能很简单</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">diffChildren</span><span class="token punctuation">(</span><span class="token parameter">oldChild<span class="token punctuation">,</span> newChild<span class="token punctuation">,</span> index<span class="token punctuation">,</span> patches</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span> changes<span class="token punctuation">,</span> list <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">listDiff</span><span class="token punctuation">(</span>oldChild<span class="token punctuation">,</span> newChild<span class="token punctuation">,</span> index<span class="token punctuation">,</span> patches<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>changes<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>patches<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      patches<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> patches<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>changes<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      patches<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> changes
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 记录上一个遍历过的节点</span>
  <span class="token keyword">let</span> last <span class="token operator">=</span> <span class="token keyword">null</span>
  oldChild <span class="token operator">&amp;&amp;</span>
    oldChild<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> child <span class="token operator">=</span> item <span class="token operator">&amp;&amp;</span> item<span class="token punctuation">.</span>children
      <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        index <span class="token operator">=</span>
          last <span class="token operator">&amp;&amp;</span> last<span class="token punctuation">.</span>children <span class="token operator">?</span> index <span class="token operator">+</span> last<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> index <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">let</span> keyIndex <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
        <span class="token keyword">let</span> node <span class="token operator">=</span> newChild<span class="token punctuation">[</span>keyIndex<span class="token punctuation">]</span>
        <span class="token comment">// 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">dfs</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> node<span class="token punctuation">,</span> index<span class="token punctuation">,</span> patches<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> index <span class="token operator">+=</span> <span class="token number">1</span>
      last <span class="token operator">=</span> item
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>渲染差异</strong></p> <blockquote><p>通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 <code>DOM</code> 了，下面就让我们来看看 <code>Virtual Dom</code> 算法的最后一步骤</p></blockquote> <p><strong>这个函数主要两个功能</strong></p> <ul><li>深度遍历树，将需要做变更操作的取出来</li> <li>局部更新 <code>DOM</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> patchs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> changes <span class="token operator">=</span> patchs<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
  <span class="token keyword">let</span> childNodes <span class="token operator">=</span> node <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>childNodes
  <span class="token comment">// 这里的深度遍历和 diff 中是一样的</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childNodes<span class="token punctuation">)</span> index <span class="token operator">+=</span> <span class="token number">1</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>changes <span class="token operator">&amp;&amp;</span> changes<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> patchs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">changeDom</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> changes<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> last <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>childNodes <span class="token operator">&amp;&amp;</span> childNodes<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    childNodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      index <span class="token operator">=</span>
        last <span class="token operator">&amp;&amp;</span> last<span class="token punctuation">.</span>children <span class="token operator">?</span> index <span class="token operator">+</span> last<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> index <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> patchs<span class="token punctuation">)</span>
      last <span class="token operator">=</span> item
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">changeDom</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> changes<span class="token punctuation">,</span> noChild</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  changes <span class="token operator">&amp;&amp;</span>
    changes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">change</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> <span class="token punctuation">{</span> type <span class="token punctuation">}</span> <span class="token operator">=</span> change
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> StateEnums<span class="token punctuation">.</span>ChangeProps<span class="token operator">:</span>
          <span class="token keyword">let</span> <span class="token punctuation">{</span> props <span class="token punctuation">}</span> <span class="token operator">=</span> change
          props<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              node<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>prop<span class="token punctuation">,</span> item<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
              node<span class="token punctuation">.</span><span class="token function">removeAttribute</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>prop<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> StateEnums<span class="token punctuation">.</span>Remove<span class="token operator">:</span>
          node<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span>change<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> StateEnums<span class="token punctuation">.</span>Insert<span class="token operator">:</span>
          <span class="token keyword">let</span> dom
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>change<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>change<span class="token punctuation">.</span>node<span class="token punctuation">)</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>change<span class="token punctuation">.</span>node <span class="token keyword">instanceof</span> <span class="token class-name">Element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dom <span class="token operator">=</span> change<span class="token punctuation">.</span>node<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          node<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>dom<span class="token punctuation">,</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span>change<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> StateEnums<span class="token punctuation">.</span>Replace<span class="token operator">:</span>
          node<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>change<span class="token punctuation">.</span>node<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">case</span> StateEnums<span class="token punctuation">.</span>Move<span class="token operator">:</span>
          <span class="token keyword">let</span> fromNode <span class="token operator">=</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span>change<span class="token punctuation">.</span>from<span class="token punctuation">]</span>
          <span class="token keyword">let</span> toNode <span class="token operator">=</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span>change<span class="token punctuation">.</span>to<span class="token punctuation">]</span>
          <span class="token keyword">let</span> cloneFromNode <span class="token operator">=</span> fromNode<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
          <span class="token keyword">let</span> cloenToNode <span class="token operator">=</span> toNode<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
          node<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>cloneFromNode<span class="token punctuation">,</span> toNode<span class="token punctuation">)</span>
          node<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>cloenToNode<span class="token punctuation">,</span> fromNode<span class="token punctuation">)</span>
          <span class="token keyword">break</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
          <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>Virtual Dom 算法的实现也就是以下三步</strong></p> <ul><li>通过 <code>JS</code> 来模拟创建 <code>DOM</code> 对象</li> <li>判断两个对象的差异</li> <li>渲染差异</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> test4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'my-div'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'test4'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> test5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'my-div'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'test5'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> test1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'my-div'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>test4<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> test2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'11'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>test5<span class="token punctuation">,</span> test4<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> root <span class="token operator">=</span> test1<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> pathchs <span class="token operator">=</span> <span class="token function">diff</span><span class="token punctuation">(</span>test1<span class="token punctuation">,</span> test2<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pathchs<span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'开始更新'</span><span class="token punctuation">)</span>
  <span class="token function">patch</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> pathchs<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'结束更新'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_4-diff算法"><a href="#_4-diff算法" class="header-anchor">#</a> 4 Diff算法</h2> <h3 id="_4-1-react-diff"><a href="#_4-1-react-diff" class="header-anchor">#</a> 4.1 React-Diff</h3> <p>React的思路是递增法。通过对比新的列表中的节点，在原本的列表中的位置是否是递增，来判断当前节点是否需要移动。</p> <p><strong>1. 实现原理</strong></p> <p>来看这样一个例子。</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc8e69cb5b04387b7b259622a91bbe6~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p><code>nextList</code>为新的列表，<code>prevList</code>为旧列表。这个例子我们一眼能看出来，新列表是不需要进行移动的。下面我用<code>react</code>的递增思想，解释一下为什么新列表中的节点不需要移动。</p> <p>我们首先遍历<code>nextList</code>，并且找到每一个节点，在<code>prevList</code>中的位置。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">prevList<span class="token punctuation">,</span> nextList</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> nextItem <span class="token operator">=</span> nextList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> prevItem <span class="token operator">=</span> prevList<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextItem <span class="token operator">===</span> prevItem<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>找到位置以后，与上一个节点的位置进行对比，如果当前的位置大于上一个位置，说明当前节点不需要移动。因此我们要定义一个<code>lastIndex</code>来记录上一个节点的位置。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">prevList<span class="token punctuation">,</span> nextList</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> nextItem <span class="token operator">=</span> nextList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> prevItem <span class="token operator">=</span> prevList<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextItem <span class="token operator">===</span> prevItem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 需要移动节点</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span>
                    lastIndex <span class="token operator">=</span> j
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的例子中，<code>nextList</code>每个节点在<code>prevList</code>的位置为<code>0 1 2 3</code>。每一项都要比前一项要大，所以不需要移动，这就是<code>react</code>的<code>diff</code>算法的原理。</p> <p><strong>2. 找到需要移动的节点</strong></p> <p>在上一小节中，我们是通过对比值是否相等，查找的对应位置。但是在vdom中，每一个节点都是一个vNode，我们应该如何进行判断呢？</p> <p>答案就是<code>key</code>，我们通过对每个节点的<code>key</code>进行赋值，并且让处于同一<code>children</code>数组下的<code>vnode</code>的<code>key</code>都不相同，以此来确定每个节点的唯一性，并进行新旧列表的对比。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reactDiff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> nextChild <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> prevChild <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextChild<span class="token punctuation">.</span>key <span class="token operator">===</span> prevChild<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">patch</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">,</span> nextChild<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 需要移动节点</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span>
                    lastIndex <span class="token operator">=</span> j
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>3. 移动节点</strong></p> <p>首先我们先明确一点，移动节点所指的节点是<code>DOM</code>节点。<code>vnode.el</code>指向该节点对应的真实<code>DOM</code>节点。<code>patch</code>方法会将更新过后的<code>DOM</code>节点，赋值给<strong>新的</strong><code>vnode</code>的<code>el</code>属性。</p> <blockquote><p>为了画图方便，我们用<code>key</code>的值来表示<code>vnode</code>节点。为了行文方便，我们把<code>key</code>值为<code>a</code>的<code>vnode</code>简写为<code>vnode-a</code>，<code>vnode-a</code>对应的真实DOM节点为<code>DOM-A</code></p></blockquote> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab3a37a997a84b95af9f39326bf2a24f~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>我们来将上图的例子代入<code>reactDiff</code>中执行。我们遍历<strong>新列表</strong>，并查找<code>vnode</code>在<strong>旧列表</strong>中的位置。当遍历到<code>vnode-d</code>时，之前遍历在<strong>旧列表</strong>的位置为<code>0 &lt; 2 &lt; 3</code>，说明<code>A C D</code>这三个节点都是不需要移动的。此时<code>lastIndex = 3</code>, 并进入下一次循环，发现<code>vnode-b</code>在<strong>旧列表</strong>的<code>index</code>为<code>1</code>，<code>1 &lt; 3</code>，说明<code>DOM-B</code>要移动。</p> <p>通过观察我们能发现，只需要把<code>DOM-B</code>移动到<code>DOM-D</code>之后就可以了。也就是<strong>找到需要移动的VNode，我们称该VNode为α，将α对应的真实的DOM节点移动到，α在<code>新列表</code>中的前一个VNode对应的真实DOM的后面。</strong></p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e757d546440478b83e938f3824f9364~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>在上述的例子中，就是将<code>vnode-b</code>对应的真实DOM节点<code>DOM-B</code>, 移动到<code>vnode-b</code>在新列表中的前一个<code>VNode</code>——<code>vnode-d</code>对应的真实DOM节点<code>DOM-D</code>的后面</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reactDiff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> nextChild <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> prevChild <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextChild<span class="token punctuation">.</span>key <span class="token operator">===</span> prevChild<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">patch</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">,</span> nextChild<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 移动到前一个节点的后面</span>
                    <span class="token keyword">let</span> refNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling<span class="token punctuation">;</span>
                    parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span>
                    lastIndex <span class="token operator">=</span> j
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为什么是这样移动的呢？首先我们列表是<code>从头到尾</code>遍历的。这就意味着对于当前<code>VNode</code>节点来说，该节点之前的所有节点都是排好序的，如果该节点需要移动，那么只需要将DOM节点移动到前一个<code>vnode</code>节点之后就可以，因为在<strong>新列表</strong>中<code>vnode</code>的顺序就是这样的。</p> <p><strong>4. 添加节点</strong></p> <p>上一小节我们只讲了如何移动节点，但是忽略了另外一种情况，就是在<strong>新列表</strong>中有全新的<code>VNode</code>节点，在<strong>旧列表</strong>中找不到。遇到这种情况，我们需要根据新的<code>VNode</code>节点生成<code>DOM</code>节点，并插入<code>DOM</code>树中。</p> <p>至此，我们面临两个问题：1.如何发现全新的节点、2. 生成的<code>DOM</code>节点插入到哪里</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7f3ae4ecace400a801b35c156e2edfc~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>我们先来解决第一个问题，找节点还是比较简单的，我们定义一个<code>find</code>变量值为<code>false</code>。如果在<strong>旧列表</strong>找到了<code>key</code> 相同的<code>vnode</code>，就将<code>find</code>的值改为<code>true</code>。当遍历结束后判断<code>find</code>值，如果为<code>false</code>，说明当前节点为新节点</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reactDiff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> nextChild <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
            find <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> prevChild <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextChild<span class="token punctuation">.</span>key <span class="token operator">===</span> prevChild<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                find <span class="token operator">=</span> <span class="token boolean">true</span>
                <span class="token function">patch</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">,</span> nextChild<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 移动到前一个节点的后面</span>
                    <span class="token keyword">let</span> refNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling<span class="token punctuation">;</span>
                    parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span>
                    lastIndex <span class="token operator">=</span> j
                <span class="token punctuation">}</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 插入新节点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>找到新节点后，下一步就是插入到哪里了，这里的逻辑其实是和移动节点的逻辑是一样的。我们观察上图可以发现，新的<code>vnode-c</code>是紧跟在<code>vnode-b</code>后面的，并且<code>vnode-b</code>的DOM节点——<code>DOM-B</code>是已经排好序的，所以我们只需要将<code>vnode-c</code>生成的DOM节点插入到<code>DOM-B</code>之后就可以了。</p> <p>但是这里有一种特殊情况需要注意，就是新的节点位于<strong>新列表</strong>的第一个，这时候我们需要找到<strong>旧列表</strong>第一个节点，将新节点插入到原来第一个节点之前就可以了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reactDiff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> nextChild <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
            find <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> prevChild <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextChild<span class="token punctuation">.</span>key <span class="token operator">===</span> prevChild<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                find <span class="token operator">=</span> <span class="token boolean">true</span>
                <span class="token function">patch</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">,</span> nextChild<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 移动到前一个节点的后面</span>
                    <span class="token keyword">let</span> refNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling<span class="token punctuation">;</span>
                    parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span>
                    lastIndex <span class="token operator">=</span> j
                <span class="token punctuation">}</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 插入新节点</span>
            <span class="token keyword">let</span> refNode <span class="token operator">=</span> i <span class="token operator">&lt;=</span> <span class="token number">0</span>
                            <span class="token operator">?</span> prevChildren<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el
                            <span class="token operator">:</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
            <span class="token function">mount</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>5. 移除节点</strong></p> <p>有增就有减，当旧的节点不在<strong>新列表</strong>中时，我们就将其对应的DOM节点移除。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cf836312b6345d98b4ea8c9efe80a9a~tplv-k3u1fbpfcp-watermark.image?imageslim" alt="img"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reactDiff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> nextChild <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
            find <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> prevChild <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextChild<span class="token punctuation">.</span>key <span class="token operator">===</span> prevChild<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                find <span class="token operator">=</span> <span class="token boolean">true</span>
                <span class="token function">patch</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">,</span> nextChild<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 移动到前一个节点的后面</span>
                    <span class="token keyword">let</span> refNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling<span class="token punctuation">;</span>
                    parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 不需要移动节点，记录当前位置，与之后的节点进行对比</span>
                    lastIndex <span class="token operator">=</span> j
                <span class="token punctuation">}</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 插入新节点</span>
            <span class="token keyword">let</span> refNode <span class="token operator">=</span> i <span class="token operator">&lt;=</span> <span class="token number">0</span>
                            <span class="token operator">?</span> prevChildren<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el
                            <span class="token operator">:</span> nextChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
            <span class="token function">mount</span><span class="token punctuation">(</span>nextChild<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prevChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> prevChild <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
            key <span class="token operator">=</span> prevChild<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
            has <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span>key <span class="token operator">===</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>has<span class="token punctuation">)</span> parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChild<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>6. 优化与不足</strong></p> <p>以上就是React的diff算法的思路。</p> <p>目前的<code>reactDiff</code>的时间复杂度为<code>O(m*n)</code>，我们可以用空间换时间，把<code>key</code>与<code>index</code>的关系维护成一个<code>Map</code>，从而将时间复杂度降低为<code>O(n)</code>，具体的代码可以<a href="https://github.com/sunyanzhe/virtual-dom/blob/master/src/diff/react-diff.js" target="_blank" rel="noopener noreferrer">查看此项目<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>我们接下来看这样一个例子</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aed2a562a9674f5293e4e51a1b8b9005~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>根据<code>reactDiff</code>的思路，我们需要先将<code>DOM-A</code>移动到<code>DOM-C</code>之后，然后再将<code>DOM-B</code>移动到<code>DOM-A</code>之后，完成<code>Diff</code>。但是我们通过观察可以发现，只要将<code>DOM-C</code>移动到<code>DOM-A</code>之前就可以完成<code>Diff</code>。</p> <p>这里是有可优化的空间的，接下来我们介绍<code>vue2.x</code>中的<code>diff</code>算法——<code>双端比较</code>，该算法解决了上述的问题</p> <h3 id="_4-2-vue2-x-diff-双端比较"><a href="#_4-2-vue2-x-diff-双端比较" class="header-anchor">#</a> 4.2 Vue2.X Diff —— 双端比较</h3> <p>所谓<code>双端比较</code>就是<strong>新列表</strong>和<strong>旧列表</strong>两个列表的头与尾互相对比，，在对比的过程中指针会逐渐向内靠拢，直到某一个列表的节点全部遍历过，对比停止。</p> <p><strong>1. 实现原理</strong></p> <p>我们先用四个指针指向两个列表的头尾</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> oldStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    oldEndIndex <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
    newStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    newEndIndex <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>nextStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>nextEndIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们根据四个指针找到四个节点，然后进行对比，那么如何对比呢？我们按照以下四个步骤进行对比</p> <ol><li>使用<strong>旧列表</strong>的头一个节点<code>oldStartNode</code>与<strong>新列表</strong>的头一个节点<code>newStartNode</code>对比</li> <li>使用<strong>旧列表</strong>的最后一个节点<code>oldEndNode</code>与<strong>新列表</strong>的最后一个节点<code>newEndNode</code>对比</li> <li>使用<strong>旧列表</strong>的头一个节点<code>oldStartNode</code>与<strong>新列表</strong>的最后一个节点<code>newEndNode</code>对比</li> <li>使用<strong>旧列表</strong>的最后一个节点<code>oldEndNode</code>与<strong>新列表</strong>的头一个节点<code>newStartNode</code>对比</li></ol> <p>使用以上四步进行对比，去寻找<code>key</code>相同的可复用的节点，当在某一步中找到了则停止后面的寻找。具体对比顺序如下图</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847306f303ab4177891b56cccff1ebd3~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>对比顺序代码结构如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> oldStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    oldEndIndex <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
    newStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    newEndIndex <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newEndIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当对比时找到了可复用的节点，我们还是先<code>patch</code>给元素打补丁，然后将指针进行<code>前/后移</code>一位指针。根据对比节点的不同，我们移动的<strong>指针</strong>和<strong>方向</strong>也不同，具体规则如下：</p> <ol><li>当<strong>旧列表</strong>的头一个节点<code>oldStartNode</code>与<strong>新列表</strong>的头一个节点<code>newStartNode</code>对比时<code>key</code>相同。那么<strong>旧列表</strong>的头指针<code>oldStartIndex</code>与<strong>新列表</strong>的头指针<code>newStartIndex</code>同时向<strong>后</strong>移动一位。</li> <li>当<strong>旧列表</strong>的最后一个节点<code>oldEndNode</code>与<strong>新列表</strong>的最后一个节点<code>newEndNode</code>对比时<code>key</code>相同。那么<strong>旧列表</strong>的尾指针<code>oldEndIndex</code>与<strong>新列表</strong>的尾指针<code>newEndIndex</code>同时向<strong>前</strong>移动一位。</li> <li>当<strong>旧列表</strong>的头一个节点<code>oldStartNode</code>与<strong>新列表</strong>的最后一个节点<code>newEndNode</code>对比时<code>key</code>相同。那么<strong>旧列表</strong>的头指针<code>oldStartIndex</code>向<strong>后</strong>移动一位；<strong>新列表</strong>的尾指针<code>newEndIndex</code>向<strong>前</strong>移动一位。</li> <li>当<strong>旧列表</strong>的最后一个节点<code>oldEndNode</code>与<strong>新列表</strong>的头一个节点<code>newStartNode</code>对比时<code>key</code>相同。那么<strong>旧列表</strong>的尾指针<code>oldEndIndex</code>向<strong>前</strong>移动一位；<strong>新列表</strong>的头指针<code>newStartIndex</code>向<strong>后</strong>移动一位。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> oldStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    oldEndIndex <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    newStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    newEndIndex <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newEndIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldvStartNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

    oldStartIndex<span class="token operator">++</span>
    newStartIndex<span class="token operator">++</span>
    oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span>
    newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldEndNode<span class="token punctuation">,</span> newEndNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

    oldEndIndex<span class="token operator">--</span>
    newEndIndex<span class="token operator">--</span>
    oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIndex<span class="token punctuation">]</span>
    newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newEndIndex<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldStartNode<span class="token punctuation">,</span> newEndNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

    oldStartIndex<span class="token operator">++</span>
    newEndIndex<span class="token operator">--</span>
    oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span>
    newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newEndIndex<span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>oldEndNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

    oldEndIndex<span class="token operator">--</span>
    nextStartIndex<span class="token operator">++</span>
    oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIndex<span class="token punctuation">]</span>
    newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在小节的开头，提到了要让指针向内靠拢，所以我们需要循环。循环停止的条件是当其中一个列表的节点全部遍历完成，代码如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> oldStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    oldEndIndex <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    newStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    newEndIndex <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newEndIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldStartNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

      oldStartIndex<span class="token operator">++</span>
      newStartIndex<span class="token operator">++</span>
      oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span>
      newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldEndNode<span class="token punctuation">,</span> newEndNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

      oldEndIndex<span class="token operator">--</span>
      newndIndex<span class="token operator">--</span>
      oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIndex<span class="token punctuation">]</span>
      newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newEndIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldvStartNode<span class="token punctuation">,</span> newEndNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

      oldStartIndex<span class="token operator">++</span>
      newEndIndex<span class="token operator">--</span>
      oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span>
      newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newEndIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldEndNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

      oldEndIndex<span class="token operator">--</span>
      newStartIndex<span class="token operator">++</span>
      oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIndex<span class="token punctuation">]</span>
      newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此整体的循环我们就全部完成了，下面我们需要考虑这样两个问题：</p> <ul><li>什么情况下<code>DOM</code>节点需要移动</li> <li><code>DOM</code>节点如何移动</li></ul> <p>我们来解决第一个问题：<strong>什么情况下需要移动</strong>，我们还是以上图为例。</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8c96a75e48346aea2c7de1d8bfa6f67~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>当我们在第一个循环时，在<code>第四步</code>发现<strong>旧列表的尾节点</strong><code>oldEndNode</code>与<strong>新列表的头节点</strong><code>newStartNode</code>的<code>key</code>相同，是可复用的<code>DOM</code>节点。通过观察我们可以发现，<strong>原本在旧列表末尾的节点，却是新列表中的开头节点，没有人比他更靠前，因为他是第一个，所以我们只需要把当前的节点移动到原本旧列表中的第一个节点之前，让它成为第一个节点即可</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// ...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldEndNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
      <span class="token comment">// 移动到旧列表头节点之前</span>
      parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
      
      oldEndIndex<span class="token operator">--</span>
      newStartIndex<span class="token operator">++</span>
      oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldEndIndex<span class="token punctuation">]</span>
      newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7f3368a5a5744bcb2b356d7424093a6~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>然后我们进入第二次循环，我们在<code>第二步</code>发现，<strong>旧列表的尾节点</strong><code>oldEndNode</code>和<strong>新列表的尾节点</strong><code>newEndNode</code>为复用节点。<strong>原本在旧列表中就是尾节点，在新列表中也是尾节点，说明该节点不需要移动</strong>，所以我们什么都不需要做。</p> <p>同理，如果是<strong>旧列表的头节点</strong><code>oldStartNode</code>和<strong>新列表的头节点</strong><code>newStartNode</code>为复用节点，我们也什么都不需要做。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2520c8511aad44589947be3616f7f50b~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>进入第三次循环，我们在<code>第三部</code>发现，<strong>旧列表的头节点</strong><code>oldStartNode</code>和<strong>新列表的尾节点</strong><code>newEndNode</code>为复用节点。到这一步聪明如你肯定就一眼可以看出来了，我们只要将<code>DOM-A</code>移动到<code>DOM-B</code>后面就可以了。</p> <p>依照惯例我们还是解释一下，<strong>原本旧列表中是头节点，然后在新列表中是尾节点。那么只要在旧列表中把当前的节点移动到原本尾节点的后面，就可以了</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldStartNode<span class="token punctuation">,</span> newEndNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
      parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldEndNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling<span class="token punctuation">)</span>

      oldStartIndex<span class="token operator">++</span>
      newEndIndex<span class="token operator">--</span>
      oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span>
      newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newEndIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">//...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d0a744cac8045fc9ae4f593a153cc72~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>OK，进入最后一个循环。在<code>第一步</code><strong>旧列表</strong>头节点<code>oldStartNode</code>与<strong>新列表</strong>头节点<code>newStartNode</code>位置相同，所以啥也不用做。然后结束循环，这就是<code>Vue2 双端比较</code>的原理。</p> <p><strong>2. 非理想情况</strong></p> <p>上一小节，我们讲了<code>双端比较</code>的原理，但是有一种特殊情况，当四次对比都<strong>没找到</strong>复用节点时，我们只能拿<strong>新列表</strong>的第一个节点去<strong>旧列表</strong>中找与其<code>key</code>相同的节点。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dea77f7267b406ca0dc8600096c4dc1~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在旧列表中找到 和新列表头节点key 相同的节点</span>
      <span class="token keyword">let</span> newKey <span class="token operator">=</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
        oldIndex <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> child<span class="token punctuation">.</span>key <span class="token operator">===</span> newKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>找节点的时候其实会有两种情况：一种在<strong>旧列表</strong>中找到了，另一种情况是没找到。我们先以上图为例，说一下找到的情况。</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a74e61a47abb4e3ca85ffee65410340d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>当我们在旧列表中找到对应的<code>VNode</code>，我们只需要将找到的节点的<code>DOM</code>元素，移动到开头就可以了。这里的逻辑其实和<code>第四步</code>的逻辑是一样的，只不过<code>第四步</code>是移动的尾节点，这里是移动找到的节点。<code>DOM</code>移动后，由我们将<strong>旧列表</strong>中的节点改为<code>undefined</code>，这是<strong>至关重要</strong>的一步，因为我们已经做了节点的移动了所以我们不需要进行再次的对比了。最后我们将头指针<code>newStartIndex</code>向后移一位。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在旧列表中找到 和新列表头节点key 相同的节点</span>
      <span class="token keyword">let</span> newtKey <span class="token operator">=</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
        oldIndex <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> child<span class="token punctuation">.</span>key <span class="token operator">===</span> newKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldIndex <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> oldNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">patch</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
        parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
        prevChildren<span class="token punctuation">[</span>oldIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>
      <span class="token punctuation">}</span>
      newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果在<strong>旧列表</strong>中没有找到复用节点呢？很简单，直接创建一个新的节点放到最前面就可以了，然后后移头指针<code>newStartIndex</code>。</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bbefb16b2bf4d52bb9b2a5f5ea86ec1~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在旧列表中找到 和新列表头节点key 相同的节点</span>
      <span class="token keyword">let</span> newtKey <span class="token operator">=</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
        oldIndex <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> child<span class="token punctuation">.</span>key <span class="token operator">===</span> newKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldIndex <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> oldNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">patch</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
        parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
        prevChildren<span class="token punctuation">[</span>oldIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      	<span class="token function">mount</span><span class="token punctuation">(</span>newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span><span class="token operator">++</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后当<strong>旧列表</strong>遍历到<code>undefind</code>时就跳过当前节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode <span class="token operator">===</span> undefind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode <span class="token operator">===</span> undefind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>3. 添加节点</strong></p> <p>我们先来看一个例子</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85517a9eb0a34165832394b9d4e7627d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>这个例子非常简单，几次循环都是尾节点相同，尾指针一直向前移动，直到循环结束，如下图</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/668208458312440cae49139534fd6d59~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>此时<code>oldEndIndex</code>以及小于了<code>oldStartIndex</code>，但是<strong>新列表</strong>中还有剩余的节点，我们只需要将剩余的节点依次插入到<code>oldStartNode</code>的<code>DOM</code>之前就可以了。为什么是插入<code>oldStartNode</code>之前呢？原因是剩余的节点在<strong>新列表</strong>的位置是位于<code>oldStartNode</code>之前的，如果剩余节点是在<code>oldStartNode</code>之后，<code>oldStartNode</code>就会先行对比，这个需要思考一下，其实还是与<code>第四步</code>的思路一样。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndIndex <span class="token operator">&lt;</span> oldStartIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> newStartIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> parent<span class="token punctuation">,</span> prevStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>4. 移除节点</strong></p> <p>与上一小节的情况相反，当<strong>新列表</strong>的<code>newEndIndex</code>小于<code>newStartIndex</code>时，我们将<strong>旧列表</strong>剩余的节点删除即可。这里我们需要注意，<strong>旧列表</strong>的<code>undefind</code>。在第二小节中我们提到过，当头尾节点都不相同时，我们会去<strong>旧列表</strong>中找<strong>新列表</strong>的第一个节点，移动完DOM节点后，将<strong>旧列表</strong>的那个节点改为<code>undefind</code>。所以我们在最后的删除时，需要注意这些<code>undefind</code>，遇到的话跳过当前循环即可。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldEndIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndIndex <span class="token operator">&lt;</span> oldStartIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> newStartIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> newEndIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> parent<span class="token punctuation">,</span> prevStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newEndIndex <span class="token operator">&lt;</span> newStartIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldStartIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> oldEndIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        partent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>5. 小结</strong></p> <p>至此<code>双端比较</code>全部完成，以下是全部代码。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue2diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> oldStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    newStartIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    oldStartIndex <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    newStartIndex <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span><span class="token punctuation">,</span>
    newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldStartIndex <span class="token operator">&amp;&amp;</span> newStartIndex <span class="token operator">&lt;=</span> newStartIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span><span class="token operator">--</span>oldStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldStartNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

      oldStartIndex<span class="token operator">++</span>
      newStartIndex<span class="token operator">++</span>
      oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span>
      newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldEndNode<span class="token punctuation">,</span> newEndNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>

      oldStartIndex<span class="token operator">--</span>
      newStartIndex<span class="token operator">--</span>
      oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span>
      newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newEndNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldStartNode<span class="token punctuation">,</span> newEndNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
      parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldEndNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling<span class="token punctuation">)</span>
      oldStartIndex<span class="token operator">++</span>
      newStartIndex<span class="token operator">--</span>
      oldStartNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span>
      newEndNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>oldEndNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
      parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>oldEndNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
      oldStartIndex<span class="token operator">--</span>
      newStartIndex<span class="token operator">++</span>
      oldEndNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span>
      newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> newKey <span class="token operator">=</span> newStartNode<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
        oldIndex <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> child <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>key <span class="token operator">===</span> newKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldIndex <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">mount</span><span class="token punctuation">(</span>newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>oldIndex<span class="token punctuation">]</span>
        <span class="token function">patch</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">,</span> newStartNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
        parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
        prevChildren<span class="token punctuation">[</span>oldIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>
      <span class="token punctuation">}</span>
      newStartIndex<span class="token operator">++</span>
      newStartNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newStartIndex <span class="token operator">&gt;</span> newStartIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&lt;=</span> oldStartIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oldStartIndex<span class="token operator">++</span>
        <span class="token keyword">continue</span>
      <span class="token punctuation">}</span>
      parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>oldStartIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartIndex <span class="token operator">&gt;</span> oldStartIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>newStartIndex <span class="token operator">&lt;=</span> newStartIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>newStartIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> parent<span class="token punctuation">,</span> oldStartNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_4-3-vue3-diff-最长递增子序列"><a href="#_4-3-vue3-diff-最长递增子序列" class="header-anchor">#</a> 4.3 Vue3 Diff —— 最长递增子序列</h3> <p><code>vue3</code>的<code>diff</code>借鉴于<a href="https://github.com/infernojs/inferno" target="_blank" rel="noopener noreferrer">inferno<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，该算法其中有两个理念。第一个是相同的前置与后置元素的预处理；第二个则是最长递增子序列，此思想与<code>React</code>的<code>diff</code>类似又不尽相同。下面我们来一一介绍。</p> <p><strong>1. 前置与后置的预处理</strong></p> <p>我们看这两段文字</p> <div class="language- extra-class"><pre class="language-text"><code>Hello World
Hey World
</code></pre></div><p>其实就简单的看一眼我们就能发现，这两段文字是有一部分是相同的，<strong>这些文字是不需要修改也不需要移动的</strong>，真正需要进行修改中间的几个字母，所以<code>diff</code>就变成以下部分</p> <div class="language- extra-class"><pre class="language-text"><code>text1: 'llo'
text2: 'y'
</code></pre></div><p>接下来换成<code>vnode</code>，我们以下图为例。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90a27b4fa05b434889d99ae6fe832b4d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>图中的被绿色框起来的节点，他们是不需要移动的，只需要进行打补丁<code>patch</code>就可以了。我们把该逻辑写成代码。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue3Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    prevEnd <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    nextEnd <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>
    nextNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>prevNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">,</span> nextNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
    j<span class="token operator">++</span>
    prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    nextNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  
  prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>prevEnd<span class="token punctuation">]</span>
  nextNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>nextEnd<span class="token punctuation">]</span>
  
  <span class="token keyword">while</span> <span class="token punctuation">(</span>prevNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">patch</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">,</span> nextNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
    prevEnd<span class="token operator">--</span>
    nextEnd<span class="token operator">--</span>
    prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>prevEnd<span class="token punctuation">]</span>
    nextNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>nextEnd<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这时候，我们就需要考虑边界情况了，这里有两种情况。一种是<code>j &gt; prevEnd</code>；另一种是<code>j &gt; nextEnd</code>。</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52779ed5f26a451d8098e945709132cf~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>我们以这张图为例，此时<code>j &gt; prevEnd</code>且<code>j &lt;= nextEnd</code>，我们只需要把<strong>新列表</strong>中<code>j</code>到<code>nextEnd</code>之间剩下的节点<strong>插入</strong>进去就可以了。相反， 如果<code>j &gt; nextEnd</code>时，我们把<strong>旧列表</strong>中<code>j</code>到<code>prevEnd</code>之间的节点<strong>删除</strong>就可以了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue3Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> nextpos <span class="token operator">=</span> nextEnd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
      refNode <span class="token operator">=</span> nextpos <span class="token operator">&gt;=</span> nextChildren<span class="token punctuation">.</span>length
                <span class="token operator">?</span> <span class="token keyword">null</span>
                <span class="token operator">:</span> nextChildren<span class="token punctuation">[</span>nextpos<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> parent<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
    
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">)</span> parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们再继续思考，在我们<code>while</code>循环时，指针是从两端向内逐渐靠拢的，所以我们应该在循环中就应该去判断边界情况，我们使用<code>label</code>语法，当我们触发边界情况时，退出全部的循环，直接进入判断。代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue3Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    prevEnd <span class="token operator">=</span> prevChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    nextEnd <span class="token operator">=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>
    nextNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// label语法</span>
  outer<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>prevNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">,</span> nextNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
      j<span class="token operator">++</span>
      <span class="token comment">// 循环中如果触发边界情况，直接break，执行outer之后的判断</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">||</span> j <span class="token operator">&gt;</span> nextEnd<span class="token punctuation">)</span> <span class="token keyword">break</span> outer
      prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      nextNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

    prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>prevEnd<span class="token punctuation">]</span>
    nextNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>nextEnd<span class="token punctuation">]</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>prevNode<span class="token punctuation">.</span>key <span class="token operator">===</span> nextNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">,</span> nextNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
      prevEnd<span class="token operator">--</span>
      nextEnd<span class="token operator">--</span>
      <span class="token comment">// 循环中如果触发边界情况，直接break，执行outer之后的判断</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">||</span> j <span class="token operator">&gt;</span> nextEnd<span class="token punctuation">)</span> <span class="token keyword">break</span> outer
      prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>prevEnd<span class="token punctuation">]</span>
      nextNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>nextEnd<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 边界情况的判断</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> nextpos <span class="token operator">=</span> nextEnd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
      refNode <span class="token operator">=</span> nextpos <span class="token operator">&gt;=</span> nextChildren<span class="token punctuation">.</span>length
                <span class="token operator">?</span> <span class="token keyword">null</span>
                <span class="token operator">:</span> nextChildren<span class="token punctuation">[</span>nextpos<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token function">mount</span><span class="token punctuation">(</span>nextChildren<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> parent<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
    
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">)</span> parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevChildren<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>2. 判断是否需要移动</strong></p> <p>其实几个算法看下来，套路已经很明显了，就是找到移动的节点，然后给他移动到正确的位置。把该加的新节点添加好，把该删的旧节点删了，整个算法就结束了。这个算法也不例外，我们接下来看一下它是如何做的。</p> <p>当<code>前/后置</code>的预处理结束后，我们进入真正的<code>diff</code>环节。首先，我们先根据<strong>新列表</strong>剩余的节点数量，创建一个<code>source</code>数组，并将数组填满<code>-1</code>。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75944ec3b6a245989a0eaf7e474ef174~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>我们先写这块逻辑。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue3Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  outer<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 边界情况的判断</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> prevStart <span class="token operator">=</span> j<span class="token punctuation">,</span>
      nextStart <span class="token operator">=</span> j<span class="token punctuation">,</span>
      nextLeft <span class="token operator">=</span> nextEnd <span class="token operator">-</span> nextStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>     <span class="token comment">// 新列表中剩余的节点长度</span>
      source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>nextLeft<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建数组，填满-1</span>
     
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么这个<code>source</code>数组，是要做什么的呢？他就是来做新旧节点的对应关系的，我们将<strong>新节点</strong>在<strong>旧列表</strong>的位置存储在该数组中，我们在根据<code>source</code>计算出它的<code>最长递增子序列</code>用于移动DOM节点。为此，我们先建立一个对象存储当前<strong>新列表</strong>中的<code>节点</code>与<code>index</code>的关系，再去<strong>旧列表</strong>中去找位置。</p> <p>在找节点时要注意，<strong>如果旧节点在新列表中没有的话，直接删除就好</strong>。除此之外，我们还需要一个数量表示记录我们已经<code>patch</code>过的节点，如果数量已经与<strong>新列表</strong>剩余的节点数量一样，那么剩下的<code>旧节点</code>我们就直接删除了就可以了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue3Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  outer<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 边界情况的判断</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> prevStart <span class="token operator">=</span> j<span class="token punctuation">,</span>
      nextStart <span class="token operator">=</span> j<span class="token punctuation">,</span>
      nextLeft <span class="token operator">=</span> nextEnd <span class="token operator">-</span> nextStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>     <span class="token comment">// 新列表中剩余的节点长度</span>
      source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>nextLeft<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 创建数组，填满-1</span>
      nextIndexMap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                      <span class="token comment">// 新列表节点与index的映射</span>
      patched <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                            <span class="token comment">// 已更新过的节点的数量</span>
      
    <span class="token comment">// 保存映射关系  </span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> nextStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> key <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key
      nextIndexMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
    <span class="token punctuation">}</span> 
    
    <span class="token comment">// 去旧列表找位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> prevStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
      	prevKey <span class="token operator">=</span> prevNode<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
        nextIndex <span class="token operator">=</span> nextIndexMap<span class="token punctuation">[</span>prevKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">// 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">===</span> undefind <span class="token operator">||</span> patched <span class="token operator">&gt;=</span> nextLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
        <span class="token keyword">continue</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 找到对应的节点</span>
      <span class="token keyword">let</span> nextNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>nextIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">,</span> nextNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 给source赋值</span>
      source<span class="token punctuation">[</span>nextIndex <span class="token operator">-</span> nextStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
      patched<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01f5d145e4a84e3f922b4d39f80bcb6a~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>找到位置后，我们观察这个重新赋值后的<code>source</code>，我们可以看出，如果是全新的节点的话，其在<code>source</code>数组中对应的值就是初始的<code>-1</code>，通过这一步我们可以区分出来哪个为全新的节点，哪个是可复用的。</p> <p>其次，我们要判断是否需要移动。那么如何判断移动呢？很简单，和<code>React</code>一样我们用递增法，如果我们找到的<code>index</code>是一直递增的，说明不需要移动任何节点。我们通过设置一个变量来保存是否需要移动的状态。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue3Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  outer<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 边界情况的判断</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> prevEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> nextEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> prevStart <span class="token operator">=</span> j<span class="token punctuation">,</span>
      nextStart <span class="token operator">=</span> j<span class="token punctuation">,</span>
      nextLeft <span class="token operator">=</span> nextEnd <span class="token operator">-</span> nextStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>     <span class="token comment">// 新列表中剩余的节点长度</span>
      source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>nextLeft<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 创建数组，填满-1</span>
      nextIndexMap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                      <span class="token comment">// 新列表节点与index的映射</span>
      patched <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
      move <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                           <span class="token comment">// 是否移动</span>
      lastIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                          <span class="token comment">// 记录上一次的位置</span>
      
    <span class="token comment">// 保存映射关系  </span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> nextStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> nextEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> key <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key
      nextIndexMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
    <span class="token punctuation">}</span> 
    
    <span class="token comment">// 去旧列表找位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> prevStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> prevEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> prevNode <span class="token operator">=</span> prevChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
      	prevKey <span class="token operator">=</span> prevNode<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
        nextIndex <span class="token operator">=</span> nextIndexMap<span class="token punctuation">[</span>prevKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">// 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">===</span> undefind <span class="token operator">||</span> patched <span class="token operator">&gt;=</span> nextLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
        <span class="token keyword">continue</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 找到对应的节点</span>
      <span class="token keyword">let</span> nextNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>nextIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token function">patch</span><span class="token punctuation">(</span>prevNode<span class="token punctuation">,</span> nextNode<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 给source赋值</span>
      source<span class="token punctuation">[</span>nextIndex <span class="token operator">-</span> nextStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
      patched<span class="token operator">++</span>
      
      <span class="token comment">// 递增方法，判断是否需要移动</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	move <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      	lastIndex <span class="token operator">=</span> nextIndex
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>move<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token comment">// 需要移动</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
	
    <span class="token comment">//不需要移动</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>3. DOM如何移动</strong></p> <p>判断完是否需要移动后，我们就需要考虑如何移动了。一旦需要进行DOM移动，我们首先要做的就是找到<code>source</code>的<strong>最长递增子序列</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue3Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>move<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [0, 1]</span>
  <span class="token comment">// 需要移动</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

  <span class="token comment">//不需要移动</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>什么是最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。</p> <p>例如给定数值序列为：[ 0, 8, 4, 12 ]。</p> <p>那么它的最长递增子序列就是：[0, 8, 12]。</p> <p>当然答案可能有多种情况，例如：[0, 4, 12] 也是可以的。</p></blockquote> <p>上面的代码中，我们调用<code>lis</code> 函数求出数组<code>source</code>的最长递增子序列为<code>[ 0, 1 ]</code>。我们知道 source 数组的值为 <code>[2, 3, 1, -1]</code>，很显然最长递增子序列应该是<code>[ 2, 3 ]</code>，但为什么计算出的结果是<code>[ 0, 1 ]</code>呢？其实<code>[ 0, 1 ]</code>代表的是最长递增子序列中的各个元素在<code>source</code>数组中的位置索引，如下图所示：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c80851ea784e03b3c995234c70e9a3~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>我们根据<code>source</code>，对<strong>新列表</strong>进行重新编号，并找出了<code>最长递增子序列</code>。</p> <p>我们从后向前进行遍历<code>source</code>每一项。此时会出现三种情况：</p> <ol><li>当前的值为<code>-1</code>，这说明该节点是全新的节点，又由于我们是<strong>从后向前</strong>遍历，我们直接创建好DOM节点插入到队尾就可以了。</li> <li>当前的索引为<code>最长递增子序列</code>中的值，也就是<code>i === seq[j]</code>，这说说明该节点不需要移动</li> <li>当前的索引不是<code>最长递增子序列</code>中的值，那么说明该DOM节点需要移动，这里也很好理解，我们也是直接将DOM节点插入到队尾就可以了，因为队尾是排好序的</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue3Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>move<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 需要移动</span>
	<span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [0, 1]</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 最长子序列的指针</span>
    <span class="token comment">// 从后向前遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> nextLeft <span class="token operator">-</span> <span class="token number">1</span>； i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> pos <span class="token operator">=</span> nextStart <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token comment">// 对应新列表的index</span>
        nextNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">,</span>	<span class="token comment">// 找到vnode</span>
      	nextPos <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span>，    <span class="token comment">// 下一个节点的位置，用于移动DOM</span>
        refNode <span class="token operator">=</span> nextPos <span class="token operator">&gt;=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> nextChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">,</span> <span class="token comment">//DOM节点</span>
        cur <span class="token operator">=</span> source<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前source的值，用来判断节点是否需要移动</span>
    
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况1，该节点是全新节点</span>
      	<span class="token function">mount</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">===</span> seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况2，是递增子序列，该节点不需要移动</span>
        <span class="token comment">// 让j指向下一个</span>
        j<span class="token operator">--</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况3，不是递增子序列，该节点需要移动</span>
        parent<span class="token punctuation">.</span><span class="token function">insetBefore</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">//不需要移动</span>
  
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>说完了需要移动的情况，再说说不需要移动的情况。如果不需要移动的话，我们只需要判断是否有全新的节点给他添加进去就可以了。具体代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">vue3Diff</span><span class="token punctuation">(</span><span class="token parameter">prevChildren<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>move<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [0, 1]</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 最长子序列的指针</span>
    <span class="token comment">// 从后向前遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> nextLeft <span class="token operator">-</span> <span class="token number">1</span>； i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> pos <span class="token operator">=</span> nextStart <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token comment">// 对应新列表的index</span>
        nextNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">,</span>	<span class="token comment">// 找到vnode</span>
      	nextPos <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span>，    <span class="token comment">// 下一个节点的位置，用于移动DOM</span>
        refNode <span class="token operator">=</span> nextPos <span class="token operator">&gt;=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> nextChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">,</span> <span class="token comment">//DOM节点</span>
        cur <span class="token operator">=</span> source<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前source的值，用来判断节点是否需要移动</span>
    
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况1，该节点是全新节点</span>
      	<span class="token function">mount</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">===</span> seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况2，是递增子序列，该节点不需要移动</span>
        <span class="token comment">// 让j指向下一个</span>
        j<span class="token operator">--</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况3，不是递增子序列，该节点需要移动</span>
        parent<span class="token punctuation">.</span><span class="token function">insetBefore</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">//不需要移动</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> nextLeft <span class="token operator">-</span> <span class="token number">1</span>； i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> cur <span class="token operator">=</span> source<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前source的值，用来判断节点是否需要移动</span>
    
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">let</span> pos <span class="token operator">=</span> nextStart <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token comment">// 对应新列表的index</span>
          nextNode <span class="token operator">=</span> nextChildren<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">,</span>	<span class="token comment">// 找到vnode</span>
          nextPos <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span>，    <span class="token comment">// 下一个节点的位置，用于移动DOM</span>
          refNode <span class="token operator">=</span> nextPos <span class="token operator">&gt;=</span> nextChildren<span class="token punctuation">.</span>length <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> nextChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">,</span> <span class="token comment">//DOM节点</span>
      	<span class="token function">mount</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此<code>vue3.0</code>的diff完成。</p> <p><strong>4. 最长递增子序列</strong></p> <p>我们以该数组为例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">]</span>
</code></pre></div><p>我们可以使用动态规划的思想考虑这个问题。动态规划的思想是将一个大的问题分解成多个小的子问题，并尝试得到这些子问题的最优解，子问题的最优解有可能会在更大的问题中被利用，这样通过小问题的最优解最终求得大问题的最优解。</p> <p>我们先假设只有一个值的数组<code>[13]</code>，那么该数组的最长递增子序列就是<code>[13]</code>自己本身，其长度为<code>1</code>。<strong>那么我们认为每一项的递增序列的长度值均为1</strong></p> <p>那么我们这次给数组增加一个值<code>[7, 13]</code>, 由于<code>7 &lt; 13</code>，所以该数组的最长递增子序列是<code>[7, 13]</code>，那么该长度为<code>2</code>。<strong>那么我们是否可以认为，当<code>[7]</code>小于<code>[13]</code>时，以<code>[7]</code>为头的递增序列的长度是，<code>[7]</code>的长度和<code>[13]</code>的长度的和</strong>，即<code>1 + 1 = 2</code>。</p> <p>ok，我们基于这种思想来给计算一下该数组。我们先将每个值的初始赋值为<code>1</code></p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b62114779ce647db906d73ab1a737298~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>首先 <code>7 &lt; 13</code> 那么<code>7</code>对应的长度就是<code>13</code>的长度再加1，<code>1 + 1 = 2</code></p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80dc121621324857ab806f8220f264b4~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>继续，我们对比<code>8</code>。我们首先和<code>7</code>比，发现不满足递增，但是没关系我们还可以继续和<code>13</code>比，<code>8 &lt; 13</code>满足递增，那么<code>8</code>的长度也是<code>13</code>的长度在加一，长度为<code>2</code></p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2782096530ba4f76ae05d4eece27298f~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>我们再对比<code>3</code>，我们先让其与<code>8</code>进行对比，<code>3 &lt; 8</code>，那么<code>3</code>的长度是<code>8</code>的长度加一，此时<code>3</code>的长度为<code>3</code>。但是还没结束，我们还需要让<code>3</code>与<code>7</code>对比。同样<code>3 &lt; 7</code>，此时我们需要在计算出一个长度是<code>7</code>的长度加一同样是<code>3</code>，我们对比两个长度，<strong>如果原本的长度没有本次计算出的长度值大的话，我们进行替换，反之则我们保留原本的值</strong>。由于<code>3 === 3</code>，我们选择不替换。最后，我们让<code>3</code>与<code>13</code>进行对比，同样的<code>3 &lt; 13</code>，此时计算出的长度为<code>2</code>，比原本的长度<code>3</code>要小，我们选择保留原本的值。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cca21599c47c429ab0067c093c9e8bd0~tplv-k3u1fbpfcp-watermark.image" alt="img"></p> <p>之后的计算依次类推，最后的结果是这样的</p> <p><img src="http://img-repo.poetries.top/images/image-20210220201751694.png" alt="image-20210220201751694"></p> <p>我们从中取最大的值<code>4</code>，该值代表的<strong>最长递增子序列的个数</strong>。代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">lis</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">,</span>
    dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于保存长度</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> cur <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> next <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      <span class="token comment">// 如果是递增 取更大的长度值</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;</span> next<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>dp<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此为止，我们讲完了基础的最长递增子序列。然而在<code>vue3.0</code>中，我们需要的是最长递增子序列在原本数组中的索引。所以我们还需要在创建一个数组用于保存每个值的最长子序列所对应在数组中的<code>index</code>。具体代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">lis</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">,</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 存默认index</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> cur <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
      nextIndex <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果为-1 直接跳过，因为-1代表的是新节点，不需要进行排序</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> next <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      <span class="token comment">// 满足递增条件</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> max <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token comment">// 当前长度是否比原本的长度要大</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">&gt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max
          nextIndex <span class="token operator">=</span> j
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 记录满足条件的值，对应在数组中的index</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>res<span class="token punctuation">[</span>nextIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> index <span class="token operator">=</span> dp<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> i<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> cur <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span> <span class="token operator">?</span> i <span class="token operator">:</span> prev<span class="token punctuation">,</span> dp<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token comment">// 返回最长的递增子序列的index</span>
  <span class="token keyword">return</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/FE-Interview-Questions/excellent-docs/15-设计模式.html" class="prev">15 常用设计模式</a></span> <span class="next"><a href="/FE-Interview-Questions/excellent-docs/17-排序算法.html">17 排序算法</a>
      →
    </span></p></div>  <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="请先阅读购买协议" class="el-dialog el-dialog--center" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">请先阅读购买协议</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button disabled="disabled" type="button" class="el-button el-button--danger is-disabled" style="width:100%;"><!----><!----><span>我已阅读（8s）</span></button></span></div></div></div> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="付费阅读" class="el-dialog" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">付费阅读</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button disabled="disabled" type="button" class="el-button el-button--danger is-disabled" style="width:100%;"><!----><!----><span>确 定</span></button></span></div></div></div> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="dialog" class="el-dialog" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title"></span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAU9ElEQVR4Xu1da5Ac1XX+TnfPa1crrQQiMY9YGGHAD6SdEWUjIdjVPiQgNhJa4VRBAgSIXZRRodgJOPED7DiACxts4yoHu0BKVaiYnVkJAkKPfQkBDgnSSmUIhKeEISSW0AO0O6/ue1K3R/uY2Xl0z3TPY3fuH6l2zj3n3HO+vn373nPPIdSbZQtEfnb4BmbxPRAtADAkDN5wzYbT9llmUIWEVIU6VaVKmx84usBQ9XcylBvqXj+/rSoVtqhUHQAWDdXz80OtxBjMJO9eP7+mbVjTylv0nSNkOQBwsHv9fPk6qNlW9QDg4e6rIHCEQuHdlbZyz08PbSHCVWN6EOjGtetP3VhpvUqRX5UA4Dcu9+GjxhsAbADhPAhxOi3p/aCUgTrVV84EkpemawfWbJh7wCm+leJTVQDgV9ecgqiyHky3gnCqaRTGHgqFl1TKQNNdblUAgPevOw8GfxOM60DwZxj9uxQM/2C6O6JS46soAHh4dTOE+iMQbgYouy4aXUgX9vyuUgaa7nIrBgDe030jAOn81FSftfEBCkbOnu5OqOT4yg4A3rvuM4D4FUBLCw6c8SCFwhsK0tUJirZAWQHAe6++F1DusK6tuIyCvc9ap69T2rVAWQBgru5Hlc0gWm5DQYGWsIcIwkafOqlNC7gOAN67ZhGgPAXQmbZ0Y36ZQpHP2+pTJ7ZtAVcBwHuv/nOA5PveZ1sz8GMUjFxrv1+9hx0LuAIA5lYNe0/9KQi32lEmg/ZOCobvK6F/vasFCzgOgJTz524Dqe0W5OcmIb6SWiJbS+JR71zQAo4CgN9p9esfND6v+QPBgpILEajiLFrU+14hsvrvpVnAMQDIA5zE+/yKd3bjOUCpbPkYBSNzSxtavbcVC5TqKVOGfPLjB72ve2fNOosUxYrcQjT7KBhuKURU/710C5QMAH7h4kAsNusdb2PgjxSPt3SNUhy2UTB8uVPM6nzyLLVKMQ4z1Nhg50HV6znD09BQCquMvryJghEZD1BvLlugpBkgvqvrtyz4i745cxxWU9xHwd47HWZaZ5fFAkUDIL571T1GPHlnoHkO4Mx7f0I9xt9TKPyPdY+5b4GiABAb6vqSSOhPepsaofqK2OQrPK5vUjD848JkxVPw3rUylu8qgJrBvBGKsYFathwrnmNt9rQNgNHdy/4Ecf9biqJqvubZbo16PQXDP3eLOe/pvh2EB9L4MzZQKPygWzKrla9tAEQHOt5nQ5zumzMbiqa5My7G1ygU/id3mAOpp5+uz+D/BAXDq92SWS18j3bf3AoiRjJ5cO6WjQdsASC2q+uXIqF/VfV64G1qcnNM7s4Ae7uHAFyWMYBdFAybEb/TtX247qZ9AC0aGx8LXmMZAMnnu1YkR/R+2dk/bw5IUd2zE+FvqCV8v1sCeAYCQD75gqbcbNpnGQCxgc4TwjAaNb8PnsZGt3yT4sv8bQpFfuiWkJkIgMNrb1pNCm3OsOlxSwCID3U+YiQNGcSJwLxmgBzZ7s3jX/EDCvZ+tw4A5yxwdN0tiwV4eDJHZjxREAD87PJPROOe9wFQWZ7+1BTwEAUjtzk3/HROM3EGkBY4vO4vbyCmu0D0Sel8leiuggCIDXXuFknjEvPd3zwHpLr47p/wUy8Fw2udAEBiR+tiHSTjEccvcfpmN0HxeNLYi2QS8Y8+nvgb8wENvMbbNeTY/f/L73vrdgJ/D0AzM4ZIUTds/duzHeNfjL3yAiCxe+UiPZY0FZSffPLTryyN+UUKRb7ohKzRnW1bABq/0Cl5WgJAai1yoKFr0JF7CavueWeBohhp+QUkCJ65c2FF8wvkBUBssOtVoevnS1t4Gxuh+l3Z9cvm5/cpGLYXRJoDLaM7V3DmT5YBAKChc6DgLGkFqKvueaNVUWhKfoGtdyx0hL8VHbLR5BSe3L2yIxlN7hyL7QicIuMzyqirFp1HFz59tNiBjfUb2dG2j2ji29fODMDA8cbOgeZSdZD9cwDg4NY7FlY0v0BOj8YGut4Uhn6OVF7u93tnufzpl2llRaygxb1Tnhi7zhjpa11NrKR9/lidAYhxY6BrwLH7/1fc++YWTMovAIEbt35roWP87dpG0mcFQHxXxwVGwvivsZ+zGawYYbb6OLg3Hx1sXQAdE4vAufMeJEUZ3xEzX/dC7I8fPXL7uI4aDgTahhy//y9ngpQM7cC2b53tOH9bNs4FgNhg14DQdXNxIkO8/HMdmQXt6ca8kUIRc+/B6TZTPwMtrQF4sNUf1dURgM3dHk9jAJo/4LQPCvNjHqZQpPTo4iyS6gCYMMqUV0Di2ZU/1uPJvx4j8c91ed8/NxQSaAkH3LgbWAdAHgDEBjqOCkOk5nwiBOZVMDpbNT5Piza/XHi6sEdRB0AOACSfv7wrORrfPvZzGY5983uO+TYKRR6y597C1Ly3e0sqGiitTfvj4IJrgNhg13NC15eNEXoaAtACFXj/j2vKfRSMdBZ2qT0K3tN9FwhyS3ZymxEBIZmWSlsDRPvbR1nwuMd9c5qgaOl75vZMXSI1wwDTKbSk53iJnNK683B3KzKzfhLaqCUsA0VmVBsHQLyv/UKDef/E6BmBU06pvDFIXEstvY85rQgPr14AoaXuHij6RmrZUvFvcqfHaIXfBAAGOh8xjNSZv2kTTYXz8f5WVMqgYX6cQpGvFNGz3sWCBcYBEB3oeI8NccZYn/Kd/RfQknkUPmUufa4nYWE8dRKbFjABwC+FGqJH5oxM3hg2Y/69ZTv9y682G5dTaPM2m2Ork1uwgAmAxLMrb9HjyYcn05cx+MOCmvwIBSM3WSCsk9i0gAmA+K6VTxiJ5Jcn9y378W8hxUV8Pi35t8OFyOq/27OACYDYYMebQhfm0a/ZSAZ/zrPHyW1qxt0UCt/ltpiZxt8EQOb3P2kq/I7f+C3ZtEfQNHI6nftMvGROdQYTz7pM8BAdCYxOtoni1eBrKlP8nx1nsPgqhXrT1ip2utc6rRngSsr1AC8G85aAB5uobaikC60U7busjVkdmGwc1eeFd9as6rMX89sIRhYSYUqcX/Up66xGPNjaPKrTOyRvM59szLypsWuwpEQaFBvsvF/oxjcmq6v5vfA0ViEApJKML1Eo/JSz5q1+btGdra0MJS1EjsHHGjsHSzqupdhQ13aR1LvSABDww9mUL44aeEae2mUDgLRqqVHLcgYYFrqxuIYAIOP1V1EoMn5s7Si8qpSZawCIDnS+zYaRdvnB0+CHFnAy6ZPTVuX3MF/5NJ3VE3Was1V+rcObmwPMZmBplGj/UMuakhZjheS6CICO/2NDnDZZgeoHgLkY+AkFI2lrl0JGdOr3VcObFzDEMAHmgoyBYwSlZVvLGtdOFN0DQH/7xyw4bcWnVfcaIOVHGSugGYvdCBkrBJRVwxG5IZUZUHL3tpa1rm1UuQaA0Z0rkjJIvWa+AiYrytiDIH2BqMco5DQnf181HJ6SYobBT2xv6XYsxYwZrwDtejDMewRscDMLPW2tJv+ueDwTQSzMx6BgE7VEZMibpUajO1Zw5vUQ1euFt6lKPwMzh+XgBRJLFgOwcjhyOyE9yRQDG7a3rHUkyZRZTY214q/FkX621QAXynZ5suLBoFY9kXoXxKEpF5W7tNzK4fCDxGQ+8Uy8ZXtL98StIlv6TyXm4atvACuPFs3GxrkJje5s48wbYopHg292FW4F57II410wXeh07GDRDiixIw+vXQ2eks7FOlcbs6KcAeT7My3nS9WEg1kfslwU7qBQeKWdLtVMy3u6j4FQXA5eO6+AaF97gpnTQ38VQmBuSTuMFbItf5+CkczVeYV0KU1sqqqqGbRqfmoKXV8gksnM3IYybP/ulCSWyZuOQaEt1NJjOesIRfvaTzDzlLvf5o2gHNVcSxuam72ZAe6iYG+fm1Iqwdu9z8D+9sMQPCX+2zd7FhzM/18+mzGOg/UQLdnyVvmEui/JNQBE+9rfZeazMofgaWyA5s8s5O3+QJ2RwAeg8vLpVHPINQDEBjr2CENMuYat+XzwlDsriDPeP8lleoHATQBEhCGuzrR9zX0KZgXP9AGBawCIDnX+kJPG3021HyEVGVzrbXqAQKa5YV1JSzMH5l0NXYMlJbim+K6Oa4yE+E02N9fsQnDKYKYHCDJzHjKJNY0dQ5b3/bP5mLIi6ySlvBour4hPi8b8FthYWetfB9JfwsDiBhVDpQaESr+aYeHZTgTl32tyRzAfWhkfAbh2JsYU5jLLyXsBHa+zEOdOJeLUBZGa2xDKiwJ59nEvWsLfdiP/UK3NlqmrYf2djxrCyBpeLBNEulQYqrK2YgygwbiGLtj8YWUVqaz01NWwXW1XiAQ9nU2Vqr0j4Ijd+D2wsppCPXscYVeDTFLXw+XtoBOB0ax5QyudKcxtozKSINyPuYe/T2cPxdwWV238xxNEjPa3H4LgU7MpOG1fA5MHy/x7ALfMtHDzcQDEBjufErpxZTYATLuvgfxfCptBia9T8Mn/qban1Q19xgGQ3N3RmoyJnNm5qythhBumSOMps6XchcX0QLkDTl0fWYaA9DRxfR0nmEXWvPC1fzhUjGn5VRDuo5bIpmJ610KfNADEdnVtEQk9M4NmahwyaYSMEppWewKWXSRfBz+DoF9Ol7jDsZGnASAxdNlFelL9j1xm8QQC0KbL1rBl36cRngD4kdStpN6DxbGorl5TsoVH+zqOM4scIcEyefScMtQNrC4jZdWGeTcIYajiX2nR5j9Uu8b8yrp5iOmLKbQ5LRfEFADEBzo2GYb4i1wDmplrgbzuFQA/B0YPNPF4NYGB9375dMAry+9dDcZyKPgatYR/PXk0UwDA25eeFlX8/5uvQpSsICIridRbNgvwswAiUNBPiyOvlNNGvH/NadDVS0AsE34vB+iicfmMwxQKz8/UJ2vNoOhg57+zbnwhl/LTe3vYUZfJyiv7wPSfIAxDNfY6cZmVX143C0kshOBPQcGnwCxD+pYC9Mmc2ueox5y9aFRf+2cMFq/kKxPnb54NUtPulDpquWnLjBEDZFJuOg5CDMwxEKIATfyfKQ7CLMAM128EqBEydJ9oLpjPAZG9LN5Spp/OoM/2HLE0A0iiWH/ny0IYn83liKrNJDZtkVPCwJh/QaHI17NxyFk3MLq7o5Xz7AxKZhWvJ1CCTWZQVwGVFtKinvR4wpMGyFsKNNrf8QYLsTCXsVIl5eT1tTJWFJ1BnnNmqByhYKQ7pw/zCUnsbgvpUXopn3/rC0Jn3OQKF2YdmvI5WtTz30UBQHaKDna9wLp+cT4Fqyq1vCuWrFmm/0DB8HfyaV9w7rayLyAF1PcGqgwkzG9TKDKRADyHegUBYH4RDLb/Suh8c14kqSrkp2F9PVAlQLBYBMsSAE6Wk/0Q4LzJA6umzEyV+KByavBjFIxca0W+JQBIRqN9rd1gpacQU+/sWVA93kJk9d9dswAfQ0AstBrtbBkA5qugf0VECEy5SJo2FoKZX0jR6ruErvk4L2O+iYKRR6zKtgWA1KtAeRfAlEOFTBDIghOkqlb1qNM5YQHm31Ao8md2WNkCgGQc39VxgZEw5DlB/r5E8M+R5wV1ENhxSNG0zMOYPXqx3YoqtgFgrgcGO+6ELu4pqGwdBAVN5BDBIQixiJb0fmCXX1EAkEKi/Sv6WKC9oEATBE31k8OChiqSQOZMVmkpLe7JGcqX9/O9SLFmscnYseZhZv50YR4Ef3MdBIXtVAQF820UijxURE+zS9EzgOws69hEhfI7CJxZUIH666CgiWwTFLHoy5RREgBMEMgQMq3hNQhROJ8MEXxNjbWZfs62d9ztYCQTL6pJdNIlT35ciqSSAWAuCrdfehapnteY8+8UjimaCiyVm4qOiC9l/LXXl4FkLPqah/RltHT7lAgfuwNyzAOxXZeey7pnDwtusqKE/Dz0zW6qB5daMdZJGhYCydGRd71GPERtQ46U0XUMABOvg8B+CP5jq+OSdQlkfYJ6y28BI5FEcnT0iF/TzqdLnznklL0cBYAJgueWNcXi/t+y4JzxhJnKyzL13qb6KyGrU1kgcWIUwjA+9FPyfKee/DFZjgNgjHG0r2OQWVjOYSfDy+S6oH6QNAEDoSeR+HgEikd73XfptvOceuon83ENAMyg6ED74xCcMx4t24DkIZJMSDGzt5AZyZFR6NE4tAbfv3gveeY6N5wveboGgDGFYwPt64WOn4DY1qGAGWvY0ADMsBtIRjyO5GgUzGxoAc/N3mXbNrrl/LIAQAqJ7bj0XKF4BsF8ht3BmCXsAoGCZ092+VYbvZFMIDkSBRsGSFMPKz5a7lu64zW39XR9BhgbAL8U8sQ+mvsoG8a1ticeuT5oCEDuH0y3ZiTkEx8zHS+b6vf2+pZvkxc6y9LKBoCx0cQH2q4SQn2MWdivTaso0Lxes44BqTV8OZUF9HjCnOohi5yksrIeU31qt2fptv6yeP6kkLIDQMqVgSUJ8vyzkTTWFTtYuUiUMYiaz1sz+QrkRo4+GoUej08aNrPi8f7a37r9r4q1RSn9KgKAMYUTz3cuFnH0CMPIefuo8ODYPFuQYDA/ISs6oqnayk85I6FDJBMQ+uQCpwzyaC/5VV5Ly/tklFVFWlWYKz60ap1hJB6GSFXIKqXJz0jF44HqUaFonjIvHhkiqZuOFskkjKSeKi2d0RSP9nvVo13nWbZV5hKoaKsKAIxZIDbQtV6w8Z1cCSuLsZR8VaiaCsXrMQNVSbH1NZpHJMvdObB0tq6bzh5byOXqRKp2SPVpd3iXbS2+KmgxRsjTp6oAMKZnfLDrK8x0nzCSuRMelGQIAilkzg4kQxvH/5X/VfLMGpxyuHS8EJY1UDR1P0Hc5WvrL6m4g2WBNgirEgDja4QXr1giRo17ha4vB7imToyIKK54tIiXlNudPLyx4VtLpFUNgMkjiO1u/1MY2jfkRVVmrsoNAVLUjxRVeUFV+Rfa8h1PWfJAhYlqBgBjdpJnDImhrquY+FaRFMsKXVdz2b5Mmvo+KbQVuv4jf/tAzRWrrDkAZDpUbjMzeS+GSlcCfBELcSYY6bWQHUIBESVIUQ4pqvqaIPG0L4qHaeWOEYfYV4RNzQMgm9VknGJc84dIURaBcYEgkpm0PsECTTI2Fcw+BlQwT76/ppNCMXmISQqNEHACjD8A/CYxDXlZ7KCO/mlXXeT/AQOtWhTnoNDfAAAAAElFTkSuQmCC" class="theme-float-btn"></main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/FE-Interview-Questions/assets/js/app.58edb9ce.js" defer></script><script src="/FE-Interview-Questions/assets/js/5.035c7bc0.js" defer></script><script src="/FE-Interview-Questions/assets/js/4.d083826f.js" defer></script><script src="/FE-Interview-Questions/assets/js/69.3c2cfb0d.js" defer></script><script src="/FE-Interview-Questions/assets/js/11.073738bd.js" defer></script>
  </body>
</html>
