<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1 对于MVVM的理解 | 面试指南</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/FE-Interview-Questions/logo.png">
    <link rel="manifest" href="/FE-Interview-Questions/manifest.json">
    <link rel="apple-touch-icon" href="/FE-Interview-Questions/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/FE-Interview-Questions/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="web前端面试题总结，面试指南，前端面试题整理，web面试宝典，刷题神器，按模块分类整理总结，打造最全面的前端面试题">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/FE-Interview-Questions/assets/css/0.styles.f26b5f0f.css" as="style"><link rel="preload" href="/FE-Interview-Questions/assets/js/app.0b8f873d.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/5.f68268af.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/4.1cafbbe1.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/77.68845809.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/11.3e5297f1.js" as="script"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/1.e6248e56.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/10.c76d9920.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/100.a002d42d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/101.64e615c6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/102.399345d2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/103.ec134225.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/104.6af2cf73.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/105.f9d5a028.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/106.4ad6179b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/107.3ddce516.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/108.4820d5b5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/109.2ad6b050.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/110.dfdec650.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/111.968ab790.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/112.8f287790.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/113.d1b03982.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/114.d3feb790.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/115.13932938.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/116.0dfbbff5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/117.33f90d0c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/118.318a0f2f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/119.f805bb44.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/12.a33e6292.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/120.27dbb14a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/121.76d241c2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/122.03e1bff4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/123.aaacf72d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/124.0aad522a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/125.518ca6a8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/126.12a1a4bb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/127.408c9288.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/128.aa9140a9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/129.f0a33fab.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/13.7e3168a4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/130.df205ce1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/131.391cc395.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/132.d5ce339b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/133.816be977.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/134.d836fe3f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/135.0f0fe7ac.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/136.8f192c00.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/137.8f7a9f4f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/138.29c4422a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/139.f39225fa.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/14.6ab36fa5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/140.ea981825.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/141.5c138705.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/15.a6d0032e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/16.6094fda8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/17.f17aa05b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/18.75dd707b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/19.9fa6e2c6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/20.1b85bc7c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/21.28c8a661.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/22.3222a772.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/23.8192ecea.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/24.b5156b88.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/25.034d5e81.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/26.c78d8f63.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/27.cd94c89c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/28.b2c8e24c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/29.e9a30c2c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/3.82699565.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/30.2bd67425.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/31.6333035e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/32.1a34dfa0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/33.b5863ac0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/34.cababd6c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/35.0b09d4a2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/36.8f89ed73.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/37.38d590c3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/38.4799c402.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/39.c9d13f25.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/40.21e1dcb8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/41.16e0641a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/42.9ce6fd83.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/43.8936e729.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/44.5ebdd233.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/45.ce59a54c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/46.b6f1380b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/47.5fe8aac4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/48.a31741eb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/49.16132e72.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/50.ca74d5c9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/51.f21f79ee.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/52.6ff2b7c5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/53.003482ca.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/54.2cbd9f91.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/55.c08355c1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/56.3a1e3c24.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/57.c3c2e05a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/58.f1ca8c6e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/59.6c96ed96.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/6.c2d6e084.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/60.066ecddf.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/61.bb67b9b4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/62.d8e4be2c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/63.df53bdf6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/64.19c9f010.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/65.02fae9b4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/66.4b1dd8f5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/67.0a26df5e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/68.220a258f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/69.b8e2ca21.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/7.4f359fae.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/70.de16f056.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/71.2e927d55.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/72.0b9ee279.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/73.990ed437.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/74.867ad109.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/75.4c85db91.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/76.3513c4b3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/78.950f8c33.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/79.a2d99a1f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/8.b6777e86.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/80.210e9842.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/81.b040205d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/82.89676520.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/83.14e13b33.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/84.ad03d434.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/85.f1720b60.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/86.4f2c39c8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/87.dc404ea3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/88.3d4ddb45.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/89.bcf90917.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/9.31237659.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/90.ce501cc3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/91.2e38302a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/92.6de24981.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/93.fdc7226c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/94.9e617dd9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/95.5a091063.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/96.83b945a8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/97.fe804b0e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/98.134b4c27.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/99.a2152b17.js">
    <link rel="stylesheet" href="/FE-Interview-Questions/assets/css/0.styles.f26b5f0f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/FE-Interview-Questions/" class="home-link router-link-active"><img src="/FE-Interview-Questions/logo.png" alt="面试指南" class="logo"> <span class="site-name can-hide">面试指南</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!----> <div style="padding-left:1.5rem;"><div class="qr"><img src="/FE-Interview-Questions/assets/img/qr.ee193d28.jpg" alt="poetries" width="120" height="120" loading="lazy"> <p class="we-intro">
    关注公众号，获取更多资讯
  </p></div></div> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>精选模块</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/excellent-docs/1-HTML模块.html" class="sidebar-link">1 HTML模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/2-CSS模块.html" class="sidebar-link">2 CSS模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/3-JS模块.html" class="sidebar-link">3 JS模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/4-ES6模块.html" class="sidebar-link">4 ES6模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/5-浏览器模块.html" class="sidebar-link">5 浏览器模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/6-React.html" class="sidebar-link">6 React模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html" aria-current="page" class="active sidebar-link">7 Vue模块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_1-对于mvvm的理解" class="sidebar-link">1 对于MVVM的理解</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_2-请详细说下你对vue生命周期的理解" class="sidebar-link">2 请详细说下你对vue生命周期的理解</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_3-vue实现数据双向绑定的原理-object-defineproperty" class="sidebar-link">3 Vue实现数据双向绑定的原理：Object.defineProperty()</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_4-vue组件间的参数传递" class="sidebar-link">4 Vue组件间的参数传递</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_5-vue的路由实现-hash模式-和-history模式" class="sidebar-link">5 Vue的路由实现：hash模式 和 history模式</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_5-vue路由的钩子函数" class="sidebar-link">5 vue路由的钩子函数</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_6-vuex是什么-怎么使用-哪种功能场景使用它" class="sidebar-link">6 vuex是什么？怎么使用？哪种功能场景使用它？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_7-v-if-和-v-show-区别" class="sidebar-link">7 v-if 和 v-show 区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_8-route和-router的区别" class="sidebar-link">8 $route和$router的区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_9-如何让css只在当前组件中起作用" class="sidebar-link">9 如何让CSS只在当前组件中起作用?</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_10-keep-alive-keep-alive-的作用是什么" class="sidebar-link">10 &lt;keep-alive&gt;&lt;/keep-alive&gt;的作用是什么?</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_11-指令v-el的作用是什么" class="sidebar-link">11 指令v-el的作用是什么?</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_12-在vue中使用插件的步骤" class="sidebar-link">12 在Vue中使用插件的步骤</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_13-请列举出3个vue中常用的生命周期钩子函数" class="sidebar-link">13 请列举出3个Vue中常用的生命周期钩子函数?</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_14-vue-cli-工程技术集合介绍" class="sidebar-link">14 vue-cli 工程技术集合介绍</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_15-nexttick" class="sidebar-link">15 NextTick</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_16-vue的优点是什么" class="sidebar-link">16 vue的优点是什么？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_17-路由之间跳转" class="sidebar-link">17 路由之间跳转？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_18-实现-vue-ssr" class="sidebar-link">18 实现 Vue SSR</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_19-vue-组件-data-为什么必须是函数" class="sidebar-link">19 Vue 组件 data 为什么必须是函数</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_20-vue-computed-实现" class="sidebar-link">20 Vue computed 实现</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_21-vue-complier-实现" class="sidebar-link">21 Vue complier 实现</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_22-怎么快速定位哪个组件出现性能问题" class="sidebar-link">22 怎么快速定位哪个组件出现性能问题</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_23-开发中常用的指令有哪些" class="sidebar-link">23 开发中常用的指令有哪些</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_24-proxy-相比于-defineproperty-的优势" class="sidebar-link">24 Proxy 相比于 defineProperty 的优势</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_25-vue-router-有哪几种导航守卫" class="sidebar-link">25 vue-router 有哪几种导航守卫?</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_26-组件之间的传值通信" class="sidebar-link">26 组件之间的传值通信</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_27-vue与angular以及react的区别" class="sidebar-link">27 Vue与Angular以及React的区别？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_28-vuex是什么-怎么使用-哪种功能场景使用它" class="sidebar-link">28 vuex是什么？怎么使用？哪种功能场景使用它？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_28-watch与computed的区别" class="sidebar-link">28 watch与computed的区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_29、vue是如何实现双向绑定的" class="sidebar-link">29、Vue是如何实现双向绑定的?</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_29-vue2-x-响应式原理" class="sidebar-link">29 Vue2.x 响应式原理</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_30-v-model双向绑定原理" class="sidebar-link">30 v-model双向绑定原理</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_31-scoped样式穿透" class="sidebar-link">31 scoped样式穿透</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_32-ref的作用" class="sidebar-link">32 ref的作用</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_33-computed和watch区别" class="sidebar-link">33 computed和watch区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_34-vue-router守卫" class="sidebar-link">34 vue-router守卫</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_35-vue修饰符" class="sidebar-link">35 vue修饰符</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_36-vue项目中的性能优化" class="sidebar-link">36 vue项目中的性能优化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_37-vue-extend和vue-component" class="sidebar-link">37 vue.extend和vue.component</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_38-vue的spa-如何优化加载速度" class="sidebar-link">38 Vue的SPA 如何优化加载速度</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_39-移动端如何设计一个比较友好的header组件" class="sidebar-link">39 移动端如何设计一个比较友好的Header组件？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_40-proxy与object-defineproperty的优劣对比" class="sidebar-link">40 Proxy与Object.defineProperty的优劣对比?</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_41-你是如何理解vue的响应式系统的" class="sidebar-link">41 你是如何理解Vue的响应式系统的?</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_42-既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异" class="sidebar-link">42 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_43-vue为什么没有类似于react中shouldcomponentupdate的生命周期" class="sidebar-link">43 Vue为什么没有类似于React中shouldComponentUpdate的生命周期？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_44-vue中的key到底有什么用" class="sidebar-link">44 Vue中的key到底有什么用？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_45-vue-项目性能优化" class="sidebar-link">45 vue 项目性能优化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_46-nexttick" class="sidebar-link">46 nextTick</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_47-说一下vue2-x中如何监测数组变化" class="sidebar-link">47 说一下vue2.x中如何监测数组变化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_48-你的接口请求一般放在哪个生命周期中" class="sidebar-link">48 你的接口请求一般放在哪个生命周期中</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_49-组件中的data为什么是一个函数" class="sidebar-link">49 组件中的data为什么是一个函数</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_50-说一下v-model的原理" class="sidebar-link">50 说一下v-model的原理</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_51-vue事件绑定原理说一下" class="sidebar-link">51 Vue事件绑定原理说一下</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_52-vue模版编译原理知道吗-能简单说一下吗" class="sidebar-link">52 Vue模版编译原理知道吗，能简单说一下吗？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_53-vue2-x和vue3-x渲染器的diff算法分别说一下" class="sidebar-link">53 Vue2.x和Vue3.x渲染器的diff算法分别说一下</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_54-再说一下虚拟dom以及key属性的作用" class="sidebar-link">54 再说一下虚拟Dom以及key属性的作用</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_55-vue中组件生命周期调用顺序说一下" class="sidebar-link">55 Vue中组件生命周期调用顺序说一下</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_56-ssr了解吗" class="sidebar-link">56 SSR了解吗</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_57-你都做过哪些vue的性能优化" class="sidebar-link">57 你都做过哪些Vue的性能优化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_58-vue-js特点" class="sidebar-link">58 Vue.js特点</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_59-请说出vue-cli项目中src目录每个文件夹和文件的用法" class="sidebar-link">59 请说出vue.cli项目中src目录每个文件夹和文件的用法</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_60-vue路由传参数" class="sidebar-link">60 vue路由传参数</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_61-vuex-是什么-有哪几种属性" class="sidebar-link">61 vuex 是什么？ 有哪几种属性？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_62-如何让css只在当前组件中起作用" class="sidebar-link">62 如何让CSS只在当前组件中起作用？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_63-delete和vue-delete删除数组的区别" class="sidebar-link">63 delete和Vue.delete删除数组的区别？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_64-v-on可以监听多个方法吗" class="sidebar-link">64 v-on可以监听多个方法吗？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_65-vue子组件调用父组件的方法" class="sidebar-link">65 Vue子组件调用父组件的方法</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_66-vue如何兼容ie的问题" class="sidebar-link">66 vue如何兼容ie的问题</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_67-vue-改变数组触发视图更新" class="sidebar-link">67 Vue 改变数组触发视图更新</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_68-dom-渲染在哪个周期中就已经完成" class="sidebar-link">68 DOM 渲染在哪个周期中就已经完成？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_69-简述每个周期具体适合哪些场景" class="sidebar-link">69 简述每个周期具体适合哪些场景</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_70-动态绑定class" class="sidebar-link">70 动态绑定class</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_71-vue3-0-是如何变得更快的" class="sidebar-link">71 Vue3.0 是如何变得更快的</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#diff-方法优化" class="sidebar-link">diff 方法优化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#hoiststatic-静态提升" class="sidebar-link">hoistStatic 静态提升</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#cachehandlers-事件侦听器缓存" class="sidebar-link">cacheHandlers 事件侦听器缓存</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_72-说说你对-proxy-的理解" class="sidebar-link">72 说说你对 proxy 的理解</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_73-生命周期详解" class="sidebar-link">73 生命周期详解</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_74-proxy-相比于-defineproperty-的优势" class="sidebar-link">74 Proxy 相比于 defineProperty 的优势</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_75-vue-router" class="sidebar-link">75 vue-router</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_76-vuex总结" class="sidebar-link">76 vuex总结</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_77-diff-算法" class="sidebar-link">77 diff 算法</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_78-vue-的响应式原理中-object-defineproperty-有什么缺陷" class="sidebar-link">78 Vue 的响应式原理中 Object.defineProperty 有什么缺陷</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_79-composition-api" class="sidebar-link">79 Composition API</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_80-vue中是如何检测数组变化的呢" class="sidebar-link">80 vue中是如何检测数组变化的呢</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_81-vue的事件绑定原理" class="sidebar-link">81 Vue的事件绑定原理</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_82-v-model中的实现原理及如何自定义v-model" class="sidebar-link">82 v-model中的实现原理及如何自定义v-model</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_83-为什么vue采用异步渲染呢" class="sidebar-link">83 为什么Vue采用异步渲染呢</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_84-vuex-工作原理" class="sidebar-link">84 Vuex 工作原理</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_85-如何从真实dom到虚拟dom" class="sidebar-link">85 如何从真实DOM到虚拟DOM</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_86-computed-watch-和-method" class="sidebar-link">86 Computed watch 和 method</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_87-为什么要使用异步组件" class="sidebar-link">87 为什么要使用异步组件？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_88-action-与-mutation-的区别" class="sidebar-link">88 action 与 mutation 的区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_89-插槽与作用域插槽的区别" class="sidebar-link">89 插槽与作用域插槽的区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_90-vue中相同逻辑如何抽离" class="sidebar-link">90 vue中相同逻辑如何抽离</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_91-谈谈对keep-alive的了解" class="sidebar-link">91 谈谈对keep-alive的了解</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_92-vue性能优化" class="sidebar-link">92 Vue性能优化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_93-vue3-0相对于vue2-x有哪些不同" class="sidebar-link">93 Vue3.0相对于Vue2.x有哪些不同？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_94-vue中hash模式和history模式的区别" class="sidebar-link">94 Vue中hash模式和history模式的区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_95-了解history有哪些方法吗-说下它们的区别" class="sidebar-link">95 了解history有哪些方法吗？说下它们的区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_96-如何监听-pushstate-和-replacestate-的变化呢" class="sidebar-link">96 如何监听 pushState 和 replaceState 的变化呢？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_97-vue组件内的导航守卫有哪几个" class="sidebar-link">97 Vue组件内的导航守卫有哪几个？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_98-beforerouteenter和另外两个有什么不同吗" class="sidebar-link">98 beforeRouteEnter和另外两个有什么不同吗？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_99-完整的导航解析流程" class="sidebar-link">99 完整的导航解析流程</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent-docs/7-Vue.html#_100-你是怎么看vue和react的" class="sidebar-link">100 你是怎么看Vue和React的？</a></li></ul></li><li><a href="/FE-Interview-Questions/excellent-docs/8-Node模块.html" class="sidebar-link">8 Node模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/9-前端工程模块.html" class="sidebar-link">9 前端工程相关</a></li><li><a href="/FE-Interview-Questions/excellent-docs/10-移动多端开发.html" class="sidebar-link">10 移动多端开发</a></li><li><a href="/FE-Interview-Questions/excellent-docs/11-小程序模块.html" class="sidebar-link">11 小程序模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/12-前端安全模块.html" class="sidebar-link">12 前端安全模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/13-性能优化模块.html" class="sidebar-link">13 性能优化相关</a></li><li><a href="/FE-Interview-Questions/excellent-docs/14-HTTP模块.html" class="sidebar-link">14 HTTP模块</a></li><li><a href="/FE-Interview-Questions/excellent-docs/15-设计模式.html" class="sidebar-link">15 常用设计模式</a></li><li><a href="/FE-Interview-Questions/excellent-docs/16-框架通识.html" class="sidebar-link">16 框架通识</a></li><li><a href="/FE-Interview-Questions/excellent-docs/17-排序算法.html" class="sidebar-link">17 排序算法</a></li><li><a href="/FE-Interview-Questions/excellent-docs/18-计算机通识.html" class="sidebar-link">18 计算机通识</a></li></ul></section></li></ul> </aside> <main class="page"> <div id="container" class="theme-default-content lock"><div class="content__default"><h2 id="_1-对于mvvm的理解"><a href="#_1-对于mvvm的理解" class="header-anchor">#</a> 1 对于MVVM的理解</h2> <blockquote><p><code>MVVM</code>是<code>Model-View-ViewModel</code>缩写，也就是把MVC中的Controller演变成<code>ViewModel</code>。Model层代表数据模型，<code>View</code>代表UI组件，<code>ViewModel</code>是<code>View</code>和<code>Model</code>层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p></blockquote> <ul><li><code>MVVM</code> 是 <code>Model-View-ViewModel</code> 的缩写</li> <li><code>Model</code>: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为</li> <li><code>View</code>: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View</li> <li><code>ViewModel</code>： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View.</li> <li><strong>总结</strong>： <code>MVVM</code>模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，<code>ViewModel</code> 会自动更新，而 <code>ViewModel</code> 变化时，View 也会自动变化。</li></ul> <h2 id="_2-请详细说下你对vue生命周期的理解"><a href="#_2-请详细说下你对vue生命周期的理解" class="header-anchor">#</a> 2 请详细说下你对vue生命周期的理解</h2> <blockquote><p>答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p></blockquote> <p><strong>生命周期是什么</strong></p> <blockquote><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是Vue的生命周期</p></blockquote> <p><strong>各个生命周期的作用</strong></p> <table><thead><tr><th>生命周期</th> <th>描述</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>组件实例被创建之初，组件的属性生效之前</td></tr> <tr><td>created</td> <td>组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用</td></tr> <tr><td>beforeMount</td> <td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr> <tr><td>mounted</td> <td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr> <tr><td>beforeUpdate</td> <td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr> <tr><td>update</td> <td>组件数据更新之后</td></tr> <tr><td>activited</td> <td>keep-alive专属，组件被激活时调用</td></tr> <tr><td>deadctivated</td> <td>keep-alive专属，组件被销毁时调用</td></tr> <tr><td>beforeDestory</td> <td>组件销毁前调用</td></tr> <tr><td>destoryed</td> <td>组件销毁后调用</td></tr></tbody></table> <p><img src="http://poetries1.gitee.io/img-repo/2020/07/61.png" alt=""></p> <blockquote><p>由于Vue会在初始化实例时对属性执行<code>getter/setter</code>转化，所以属性必须在<code>data</code>对象上存在才能让<code>Vue</code>将它转换为响应式的。Vue提供了<code>$set</code>方法用来触发视图更新</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            obj<span class="token operator">:</span> <span class="token punctuation">{</span>
                name<span class="token operator">:</span> <span class="token string">'fei'</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">,</span> <span class="token string">'man'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p><strong>什么是vue生命周期？</strong></p> <ul><li>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</li></ul> <p><strong>vue生命周期的作用是什么？</strong></p> <ul><li>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</li></ul> <p><strong>vue生命周期总共有几个阶段？</strong></p> <ul><li>答：它可以总共分为<code>8</code>个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。</li></ul> <p><strong>第一次页面加载会触发哪几个钩子？</strong></p> <ul><li>答：会触发下面这几个<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code> 。</li></ul> <p><strong>DOM 渲染在哪个周期中就已经完成？</strong></p> <ul><li>答：<code>DOM</code> 渲染在 <code>mounted</code> 中就已经完成了</li></ul> <h2 id="_3-vue实现数据双向绑定的原理-object-defineproperty"><a href="#_3-vue实现数据双向绑定的原理-object-defineproperty" class="header-anchor">#</a> 3 Vue实现数据双向绑定的原理：Object.defineProperty()</h2> <ul><li><code>vue</code>实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 <code>Javascript</code> 对象传给 Vue 实例来作为它的 <code>data</code> 选项时，Vue 将遍历它的属性，用 <code>Object.defineProperty()</code> 将它们转为 <code>getter/setter</code>。用户看不到 <code>getter/setter</code>，但是在内部它们让 <code>Vue</code>追踪依赖，在属性被访问和修改时通知变化。</li> <li>vue的数据双向绑定 将<code>MVVM</code>作为数据绑定的入口，整合<code>Observer</code>，<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>的数据变化，通过<code>Compile</code>来解析编译模板指令（<code>vue</code>中是用来解析 <code>{{}}</code>），最终利用<code>watcher</code>搭起<code>observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（<code>input</code>）—&gt;数据<code>model</code>变更双向绑定效果。</li></ul> <h2 id="_4-vue组件间的参数传递"><a href="#_4-vue组件间的参数传递" class="header-anchor">#</a> 4 Vue组件间的参数传递</h2> <p><strong>父组件与子组件传值</strong></p> <blockquote><p>父组件传给子组件：子组件通过<code>props</code>方法接受数据；</p></blockquote> <ul><li>子组件传给父组件： <code>$emit</code> 方法传递参数</li></ul> <p><strong>非父子组件间的数据传递，兄弟组件传值</strong></p> <blockquote><p><code>eventBus</code>，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用<code>VUEX</code>，具体来说看需求）</p></blockquote> <h2 id="_5-vue的路由实现-hash模式-和-history模式"><a href="#_5-vue的路由实现-hash模式-和-history模式" class="header-anchor">#</a> 5 Vue的路由实现：hash模式 和 history模式</h2> <ul><li><code>hash</code>模式：在浏览器中符号<code>“#”</code>，#以及#后面的字符称之为<code>hash</code>，用 <code>window.location.hash</code> 读取。特点：<code>hash</code>虽然在<code>URL</code>中，但不被包括在<code>HTTP</code>请求中；用来指导浏览器动作，对服务端安全无用，<code>hash</code>不会重加载页面。</li> <li><code>history</code>模式：h<code>istory</code>采用<code>HTML5</code>的新特性；且提供了两个新方法： <code>pushState()</code>， <code>replaceState()</code>可以对浏览器历史记录栈进行修改，以及<code>popState</code>事件的监听到状态变更</li></ul> <h2 id="_5-vue路由的钩子函数"><a href="#_5-vue路由的钩子函数" class="header-anchor">#</a> 5 vue路由的钩子函数</h2> <blockquote><p>首页可以控制导航跳转，<code>beforeEach</code>，<code>afterEach</code>等，一般用于页面<code>title</code>的修改。一些需要登录才能调整页面的重定向功能。</p></blockquote> <ul><li><code>beforeEach</code>主要有3个参数<code>to</code>，<code>from</code>，<code>next</code>。</li> <li><code>to</code>：<code>route</code>即将进入的目标路由对象。</li> <li><code>from</code>：<code>route</code>当前导航正要离开的路由。</li> <li><code>next</code>：<code>function</code>一定要调用该方法<code>resolve</code>这个钩子。执行效果依赖n<code>ext</code>方法的调用参数。可以控制网页的跳转</li></ul> <h2 id="_6-vuex是什么-怎么使用-哪种功能场景使用它"><a href="#_6-vuex是什么-怎么使用-哪种功能场景使用它" class="header-anchor">#</a> 6 vuex是什么？怎么使用？哪种功能场景使用它？</h2> <ul><li>只用来读取的状态集中放在<code>store</code>中； 改变状态的方式是提交<code>mutations</code>，这是个同步的事物； 异步逻辑应该封装在<code>action</code>中。</li> <li>在<code>main.js</code>引入<code>store</code>，注入。新建了一个目录<code>store</code>，<code>… export</code></li> <li><strong>场景有</strong>：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</li></ul> <p><img src="http://poetries1.gitee.io/img-repo/2020/07/62.png" alt=""></p> <ul><li><code>state</code>：<code>Vuex</code> 使用单一状态树,即每个应用将仅仅包含一个<code>store</code> 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</li> <li><code>mutations</code>：<code>mutations</code>定义的方法动态修改<code>Vuex</code> 的 <code>store</code> 中的状态或数据</li> <li><code>getters</code>：类似<code>vue</code>的计算属性，主要用来过滤一些数据。</li> <li><code>action</code>：<code>actions</code>可以理解为通过将<code>mutations</code>里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。<code>view</code> 层通过 <code>store.dispath</code> 来分发 <code>action</code></li></ul> <p><img src="http://poetries1.gitee.io/img-repo/2020/07/63.png" alt=""></p> <blockquote><p><code>modules</code>：项目特别复杂的时候，可以让每一个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getters</code>，使得结构非常清晰，方便管理</p></blockquote> <p><img src="http://poetries1.gitee.io/img-repo/2020/07/64.png" alt=""></p> <h2 id="_7-v-if-和-v-show-区别"><a href="#_7-v-if-和-v-show-区别" class="header-anchor">#</a> 7 v-if 和 v-show 区别</h2> <ul><li>答：<code>v-if</code>按照条件是否渲染，<code>v-show</code>是<code>display</code>的<code>block</code>或<code>none</code>；</li></ul> <h2 id="_8-route和-router的区别"><a href="#_8-route和-router的区别" class="header-anchor">#</a> 8 <code>$route</code>和<code>$router</code>的区别</h2> <ul><li><code>$route</code>是“路由信息对象”，包括<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code>等路由信息参数。</li> <li>而<code>$router</code>是“路由实例”对象包括了路由的跳转方法，钩子函数等</li></ul> <h2 id="_9-如何让css只在当前组件中起作用"><a href="#_9-如何让css只在当前组件中起作用" class="header-anchor">#</a> 9 如何让CSS只在当前组件中起作用?</h2> <blockquote><p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></p></blockquote> <h2 id="_10-keep-alive-keep-alive-的作用是什么"><a href="#_10-keep-alive-keep-alive-的作用是什么" class="header-anchor">#</a> 10 <code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>的作用是什么?</h2> <blockquote><p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载</p></blockquote> <ul><li><code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染</li></ul> <blockquote><p>比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</p></blockquote> <ul><li>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存</li> <li>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态</li></ul> <h2 id="_11-指令v-el的作用是什么"><a href="#_11-指令v-el的作用是什么" class="header-anchor">#</a> 11 指令v-el的作用是什么?</h2> <blockquote><p>提供一个在页面上已存在的 <code>DOM</code>元素作为 <code>Vue</code>实例的挂载目标.可以是 CSS 选择器，也可以是一个 <code>HTMLElement</code> 实例,</p></blockquote> <h2 id="_12-在vue中使用插件的步骤"><a href="#_12-在vue中使用插件的步骤" class="header-anchor">#</a> 12 在Vue中使用插件的步骤</h2> <ul><li>采用<code>ES6</code>的<code>import ... from ...</code>语法或<code>CommonJS</code>的<code>require()</code>方法引入插件</li> <li>使用全局方法<code>Vue.use( plugin )</code>使用插件,可以传入一个选项对象<code>Vue.use(MyPlugin, { someOption: true })</code></li></ul> <h2 id="_13-请列举出3个vue中常用的生命周期钩子函数"><a href="#_13-请列举出3个vue中常用的生命周期钩子函数" class="header-anchor">#</a> 13 请列举出3个Vue中常用的生命周期钩子函数?</h2> <ul><li><code>created</code>: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, <code>watch/event</code>事件回调. 然而, 挂载阶段还没有开始, <code>$el</code>属性目前还不可见</li> <li><code>mounted</code>: <code>el</code>被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 <code>root</code> 实例挂载了一个文档内元素，当 <code>mounted</code>被调用时 <code>vm.$el</code> 也在文档内。</li> <li><code>activated</code>: <code>keep-alive</code>组件激活时调用</li></ul> <h2 id="_14-vue-cli-工程技术集合介绍"><a href="#_14-vue-cli-工程技术集合介绍" class="header-anchor">#</a> 14 vue-cli 工程技术集合介绍</h2> <p><strong>问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</strong></p> <ul><li><code>vue.js</code>：<code>vue-cli</code>工程的核心，主要特点是 双向数据绑定 和 组件系统。</li> <li><code>vue-router</code>：<code>vue</code>官方推荐使用的路由框架。</li> <li><code>vuex</code>：专为 <code>Vue.js</code> 应用项目开发的状态管理器，主要用于维护<code>vue</code>组件间共用的一些 变量 和 方法。</li> <li><code>axios</code>（ 或者 <code>fetch</code> 、<code>ajax</code> ）：用于发起 <code>GET</code> 、或 <code>POST</code> 等 <code>http</code>请求，基于 <code>Promise</code> 设计。</li> <li><code>vuex</code>等：一个专为<code>vue</code>设计的移动端UI组件库。</li> <li>创建一个<code>emit.js</code>文件，用于<code>vue</code>事件机制的管理。</li> <li><code>webpack</code>：模块加载和<code>vue-cli</code>工程打包器。</li></ul> <p><strong>问题二：vue-cli 工程常用的 npm 命令有哪些？</strong></p> <ul><li>下载 <code>node_modules</code> 资源包的命令：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install
</code></pre></div><ul><li>启动 <code>vue-cli</code> 开发环境的 npm命令：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm run dev
</code></pre></div><ul><li><code>vue-cli</code> 生成 生产环境部署资源 的 <code>npm</code>命令：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm run build
</code></pre></div><ul><li>用于查看 <code>vue-cli</code> 生产环境部署资源文件大小的 <code>npm</code>命令：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm run build --report
</code></pre></div><blockquote><p>在浏览器上自动弹出一个 展示 <code>vue-cli</code> 工程打包后 <code>app.js</code>、<code>manifest.js</code>、<code>vendor.js</code> 文件里面所包含代码的页面。可以具此优化 <code>vue-cli</code> 生产环境部署的静态资源，提升 页面 的加载速度</p></blockquote> <h2 id="_15-nexttick"><a href="#_15-nexttick" class="header-anchor">#</a> 15 NextTick</h2> <blockquote><p>在下次<code>dom</code>更新循环结束之后执行延迟回调，可用于获取更新后的<code>dom</code>状态</p></blockquote> <ul><li>新版本中默认是<code>mincrotasks</code>, <code>v-on</code>中会使用<code>macrotasks</code></li> <li><code>macrotasks</code>任务的实现:
<ul><li><code>setImmediate / MessageChannel / setTimeout</code></li></ul></li></ul> <h2 id="_16-vue的优点是什么"><a href="#_16-vue的优点是什么" class="header-anchor">#</a> 16 vue的优点是什么？</h2> <ul><li>低耦合。视图（<code>View</code>）可以独立于<code>Model</code>变化和修改，一个<code>ViewModel</code>可以绑定到不同的<code>&quot;View&quot;</code>上，当View变化的时候Model可以不变，当<code>Model</code>变化的时候<code>View</code>也可以不变</li> <li>可重用性。你可以把一些视图逻辑放在一个<code>ViewModel</code>里面，让很多<code>view</code>重用这段视图逻辑</li> <li>可测试。界面素来是比较难于测试的，而现在测试可以针对<code>ViewModel</code>来写</li></ul> <h2 id="_17-路由之间跳转"><a href="#_17-路由之间跳转" class="header-anchor">#</a> 17 路由之间跳转？</h2> <p><strong>声明式（标签跳转）</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-link :to=&quot;index&quot;&gt;
</code></pre></div><p><strong>编程式（ js跳转）</strong></p> <div class="language- extra-class"><pre class="language-text"><code>router.push('index')
</code></pre></div><h2 id="_18-实现-vue-ssr"><a href="#_18-实现-vue-ssr" class="header-anchor">#</a> 18 实现 Vue SSR</h2> <p><strong>其基本实现原理</strong></p> <ul><li><code>app.js</code> 作为客户端与服务端的公用入口，导出 <code>Vue</code> 根实例，供客户端 <code>entry</code> 与服务端 <code>entry</code> 使用。客户端 <code>entry</code> 主要作用挂载到 <code>DOM</code> 上，服务端 <code>entry</code> 除了创建和返回实例，还进行路由匹配与数据预获取。</li> <li><code>webpack</code> 为客服端打包一个 <code>Client Bundle</code> ，为服务端打包一个 <code>Server Bundle</code> 。</li> <li>服务器接收请求时，会根据 <code>url</code>，加载相应组件，获取和解析异步数据，创建一个读取 <code>Server Bundle</code> 的 <code>BundleRenderer</code>，然后生成 <code>html</code> 发送给客户端。</li> <li>客户端混合，客户端收到从服务端传来的 <code>DOM</code> 与自己的生成的 DOM 进行对比，把不相同的 <code>DOM</code> 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 <code>stroe</code> 里，这样，在客户端挂载到 <code>DOM</code> 之前，可以直接从 <code>store</code>里取数据。首屏的动态数据通过 <code>window.__INITIAL_STATE__</code>发送到客户端</li></ul> <blockquote><p><code>Vue SSR</code> 的实现，主要就是把 <code>Vue</code> 的组件输出成一个完整 <code>HTML</code>, <code>vue-server-renderer</code> 就是干这事的</p></blockquote> <ul><li><code>Vue SSR</code>需要做的事多点（输出完整 HTML），除了<code>complier -&gt; vnode</code>，还需如数据获取填充至 <code>HTML</code>、客户端混合（<code>hydration</code>）、缓存等等。
相比于其他模板引擎（<code>ejs</code>, <code>jade</code> 等），最终要实现的目的是一样的，性能上可能要差点</li></ul> <h2 id="_19-vue-组件-data-为什么必须是函数"><a href="#_19-vue-组件-data-为什么必须是函数" class="header-anchor">#</a> 19 Vue 组件 data 为什么必须是函数</h2> <ul><li>每个组件都是 <code>Vue</code> 的实例。</li> <li>组件共享 <code>data</code> 属性，当 <code>data</code> 的值是同一个引用类型的值时，改变其中一个会影响其他</li></ul> <h2 id="_20-vue-computed-实现"><a href="#_20-vue-computed-实现" class="header-anchor">#</a> 20 Vue computed 实现</h2> <ul><li>建立与其他属性（如：<code>data</code>、 <code>Store</code>）的联系；</li> <li>属性改变后，通知计算属性重新计算</li></ul> <blockquote><p>实现时，主要如下</p></blockquote> <ul><li>初始化 <code>data</code>， 使用 <code>Object.defineProperty</code> 把这些属性全部转为 <code>getter/setter</code>。</li> <li>初始化 <code>computed</code>, 遍历 <code>computed</code> 里的每个属性，每个 <code>computed</code> 属性都是一个 <code>watch</code> 实例。每个属性提供的函数作为属性的 <code>getter</code>，使用 <code>Object.defineProperty</code> 转化。</li> <li><code>Object.defineProperty getter</code> 依赖收集。用于依赖发生变化时，触发属性重新计算。</li> <li>若出现当前 <code>computed</code> 计算属性嵌套其他 <code>computed</code> 计算属性时，先进行其他的依赖收集</li></ul> <h2 id="_21-vue-complier-实现"><a href="#_21-vue-complier-实现" class="header-anchor">#</a> 21 Vue complier 实现</h2> <ul><li>模板解析这种事，本质是将数据转化为一段 <code>html</code> ，最开始出现在后端，经过各种处理吐给前端。随着各种 <code>mv*</code> 的兴起，模板解析交由前端处理。</li> <li>总的来说，<code>Vue complier</code> 是将 <code>template</code> 转化成一个 <code>render</code> 字符串。</li></ul> <blockquote><p>可以简单理解成以下步骤：</p></blockquote> <ul><li><code>parse</code> 过程，将 <code>template</code> 利用正则转化成<code>AST</code> 抽象语法树。</li> <li><code>optimize</code> 过程，标记静态节点，后 <code>diff</code> 过程跳过静态节点，提升性能。</li> <li><code>generate</code> 过程，生成 <code>render</code> 字符串</li></ul> <h2 id="_22-怎么快速定位哪个组件出现性能问题"><a href="#_22-怎么快速定位哪个组件出现性能问题" class="header-anchor">#</a> 22 怎么快速定位哪个组件出现性能问题</h2> <blockquote><p>用 <code>timeline</code> 工具。 大意是通过 <code>timeline</code> 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p></blockquote> <h2 id="_23-开发中常用的指令有哪些"><a href="#_23-开发中常用的指令有哪些" class="header-anchor">#</a> 23 开发中常用的指令有哪些</h2> <ul><li><code>v-model</code> :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定</li> <li><code>v-html</code>: 更新元素的 <code>innerHTML</code></li> <li><code>v-show</code> 与 <code>v-if</code>: 条件渲染, 注意二者区别</li></ul> <blockquote><p>使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。 v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏</p></blockquote> <ul><li><code>v-on</code> : <code>click</code>: 可以简写为<code>@click</code>,<code>@</code>绑定一个事件。如果事件触发了，就可以指定事件的处理函数</li> <li><code>v-for</code>:基于源数据多次渲染元素或模板块</li> <li><code>v-bind</code>: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 <code>DOM</code></li></ul> <blockquote><p>语法：<code>v-bind:title=&quot;msg&quot;</code>简写：<code>:title=&quot;msg&quot;</code></p></blockquote> <h2 id="_24-proxy-相比于-defineproperty-的优势"><a href="#_24-proxy-相比于-defineproperty-的优势" class="header-anchor">#</a> 24 Proxy 相比于 defineProperty 的优势</h2> <blockquote><p>Object.defineProperty() 的问题主要有三个：</p></blockquote> <ul><li>不能监听数组的变化</li> <li>必须遍历对象的每个属性</li> <li>必须深层遍历嵌套的对象</li></ul> <blockquote><p>Proxy 在 ES2015 规范中被正式加入，它有以下几个特点</p></blockquote> <ul><li>针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题</li> <li>支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。</li></ul> <blockquote><p>除了上述两点之外，Proxy 还拥有以下优势：</p></blockquote> <ul><li>Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富</li> <li>Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。</li></ul> <h2 id="_25-vue-router-有哪几种导航守卫"><a href="#_25-vue-router-有哪几种导航守卫" class="header-anchor">#</a> 25 vue-router 有哪几种导航守卫?</h2> <ul><li>全局守卫</li> <li>路由独享守卫</li> <li>路由组件内的守卫</li></ul> <p><strong>全局守卫</strong></p> <blockquote><p>vue-router全局有三个守卫</p></blockquote> <ul><li><code>router.beforeEach</code> 全局前置守卫 进入路由之前</li> <li><code>router.beforeResolve</code> 全局解析守卫(2.5.0+) 在<code>beforeRouteEnter</code>调用之后调用</li> <li><code>router.afterEach</code> 全局后置钩子 进入路由之后</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// main.js 入口文件</span>
<span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token punctuation">;</span> <span class="token comment">// 引入路由</span>
router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
router<span class="token punctuation">.</span><span class="token function">beforeResolve</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'afterEach 全局后置钩子'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>路由独享守卫</strong></p> <blockquote><p>如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token operator">:</span> <span class="token string">'/foo'</span><span class="token punctuation">,</span>
      component<span class="token operator">:</span> Foo<span class="token punctuation">,</span>
      <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
        <span class="token comment">// 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span>
        <span class="token comment">// ...</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p><strong>路由组件内的守卫</strong></p> <ul><li>beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建</li> <li>beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this</li> <li>beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this</li></ul> <h2 id="_26-组件之间的传值通信"><a href="#_26-组件之间的传值通信" class="header-anchor">#</a> 26 组件之间的传值通信</h2> <blockquote><p>组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯</p></blockquote> <p><strong>1. 父组件给子组件传值</strong></p> <ul><li>使用<code>props</code>，父组件可以使用<code>props</code>向子组件传递数据。</li> <li>父组件<code>vue</code>模板<code>father.vue</code>:</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>message<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> child <span class="token keyword">from</span> <span class="token string">'./child.vue'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
        child
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            message<span class="token operator">:</span> <span class="token string">'father message'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><blockquote><p>子组件vue模板child.vue:</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{msg}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span>
        msg<span class="token operator">:</span> <span class="token punctuation">{</span>
            type<span class="token operator">:</span> String<span class="token punctuation">,</span>
            required<span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>2. 子组件向父组件通信</strong></p> <blockquote><p>父组件向子组件传递事件方法，子组件通过<code>$emit</code>触发事件，回调给父组件</p></blockquote> <p>父组件vue模板father.vue:</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">@msgFunc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>func<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> child <span class="token keyword">from</span> <span class="token string">'./child.vue'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
        child
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">func</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><blockquote><p>子组件vue模板child.vue:</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>点我<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span>
        msg<span class="token operator">:</span> <span class="token punctuation">{</span>
            type<span class="token operator">:</span> String<span class="token punctuation">,</span>
            required<span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">methods</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handleClick</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//........</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'msgFunc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>3. 非父子, 兄弟组件之间通信</strong></p> <blockquote><p>vue2中废弃了broadcast广播和分发事件的方法。父子组件中可以用props和$emit()。如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。Bus.js可以是这样:</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>在需要通信的组件都引入Bus.js:</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>toBus<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>子组件传给兄弟组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> Bus <span class="token keyword">from</span> <span class="token string">'../common/js/bus.js'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
	methods<span class="token operator">:</span> <span class="token punctuation">{</span>
	    <span class="token function">toBus</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	        Bus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'on'</span><span class="token punctuation">,</span> <span class="token string">'来自兄弟组件'</span><span class="token punctuation">)</span>
	    <span class="token punctuation">}</span>
	  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><blockquote><p>另一个组件也import Bus.js 在钩子函数中监听on事件</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Bus <span class="token keyword">from</span> <span class="token string">'../common/js/bus.js'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        message<span class="token operator">:</span> <span class="token string">''</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       Bus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'on'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> msg
       <span class="token punctuation">}</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre></div><h2 id="_27-vue与angular以及react的区别"><a href="#_27-vue与angular以及react的区别" class="header-anchor">#</a> 27 Vue与Angular以及React的区别？</h2> <p><strong>Vue与AngularJS的区别</strong></p> <ul><li>Angular采用TypeScript开发, 而Vue可以使用javascript也可以使用TypeScript</li> <li>AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</li> <li>AngularJS社区完善, Vue的学习成本较小</li></ul> <p><strong>Vue与React的区别</strong></p> <ul><li>vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；</li> <li>props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；</li> <li>子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；</li> <li>每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；</li> <li>使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板；</li> <li>多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法；</li> <li>Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现；</li> <li>react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。</li> <li>react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些， 比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。</li> <li>react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin</li></ul> <h2 id="_28-vuex是什么-怎么使用-哪种功能场景使用它"><a href="#_28-vuex是什么-怎么使用-哪种功能场景使用它" class="header-anchor">#</a> 28 vuex是什么？怎么使用？哪种功能场景使用它？</h2> <ul><li>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data</li> <li>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</li> <li>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</li></ul> <blockquote><p>vuex的使用借助官方提供的一张图来说明:</p></blockquote> <p><img src="http://poetries1.gitee.io/img-repo/2020/07/65.png" alt=""></p> <blockquote><p>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</p></blockquote> <p><strong>state</strong></p> <blockquote><p><code>Vuex</code> 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</p></blockquote> <p><strong>mutations</strong></p> <blockquote><p><code>mutations</code>定义的方法动态修改Vuex 的 store 中的状态或数据。</p></blockquote> <p><strong>getters</strong></p> <blockquote><p>类似vue的计算属性，主要用来过滤一些数据</p></blockquote> <p><strong>action</strong></p> <ul><li>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</li> <li>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。</li> <li>使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题</li> <li>vuex 作为数据存储中心
vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理：
1、组件之间全局共享的数据
2、通过后端异步请求的数据
比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态</li></ul> <blockquote><p>一般面试官问到这里vue基本知识就差不多了， 如果更深入的研究就是和你探讨关于vue的底层源码；或者是具体在项目中遇到的问题，下面列举几个项目中可能遇到的问题：</p></blockquote> <ul><li>开发时，改变数组或者对象的数据，但是页面没有更新如何解决？</li> <li>vue弹窗后如何禁止滚动条滚动？</li> <li>如何在 vue 项目里正确地引用 jquery 和 jquery-ui的插件</li></ul> <h2 id="_28-watch与computed的区别"><a href="#_28-watch与computed的区别" class="header-anchor">#</a> 28 watch与computed的区别</h2> <p><strong>computed:</strong></p> <ul><li>computed是计算属性,也就是计算值,它更多用于计算值的场景</li> <li>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算
computed适用于计算比较消耗性能的计算场景</li></ul> <p><strong>watch:</strong></p> <ul><li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</li> <li>无缓存性，页面重新渲染时值不变化也会执行</li></ul> <p><strong>小结:</strong></p> <ul><li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li> <li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li></ul> <h2 id="_29、vue是如何实现双向绑定的"><a href="#_29、vue是如何实现双向绑定的" class="header-anchor">#</a> 29、Vue是如何实现双向绑定的?</h2> <blockquote><p>利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,然后根据变化进行后续响应,在vue3.0中通过Proxy代理对象进行类似的操作。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这是将要被劫持的对象</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">===</span> <span class="token string">'古天乐'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'给大家推荐一款超好玩的游戏'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">===</span> <span class="token string">'渣渣辉'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'戏我演过很多,可游戏我只玩贪玩懒月'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'来做我的兄弟'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 遍历对象,对其属性值进行劫持</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当属性值发生变化时我们可以进行额外操作</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">大家好,我系</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">say</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

data<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'渣渣辉'</span><span class="token punctuation">;</span>
<span class="token comment">//大家好,我系渣渣辉</span>
<span class="token comment">//戏我演过很多,可游戏我只玩贪玩懒月</span>
</code></pre></div><h2 id="_29-vue2-x-响应式原理"><a href="#_29-vue2-x-响应式原理" class="header-anchor">#</a> 29 Vue2.x 响应式原理</h2> <blockquote><p>Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></blockquote> <p><img src="http://poetries1.gitee.io/img-repo/20190922/vue.jpeg" alt=""></p> <ul><li><code>Observer</code> 遍历数据对象，给所有属性加上 <code>setter</code> 和 <code>getter</code>，监听数据的变化</li> <li><code>compile</code> 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li></ul> <blockquote><p><code>Watcher</code> 订阅者是 <code>Observer</code> 和 <code>Compile</code> 之间通信的桥梁，主要做的事情</p></blockquote> <ul><li>在自身实例化时往属性订阅器 (<code>dep</code>) 里面添加自己</li> <li>待属性变动 <code>dep.notice()</code> 通知时，调用自身的 <code>update()</code> 方法，并触发 <code>Compile</code> 中绑定的回调</li></ul> <p><strong>Vue3.x响应式数据原理</strong></p> <blockquote><p><code>Vue3.x</code>改用<code>Proxy</code>替代<code>Object.defineProperty</code>。因为<code>Proxy</code>可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p></blockquote> <p><code>Proxy</code>只会代理对象的第一层，那么<code>Vue3</code>又是怎样处理这个问题的呢？</p> <blockquote><p>判断当前<code>Reflect.get的</code>返回值是否为<code>Object</code>，如果是则再通过<code>reactive</code>方法做代理， 这样就实现了深度观测。</p></blockquote> <p><strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong></p> <blockquote><p>我们可以判断<code>key</code>是否为当前被代理对象<code>target</code>自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行<code>trigger</code></p></blockquote> <h2 id="_30-v-model双向绑定原理"><a href="#_30-v-model双向绑定原理" class="header-anchor">#</a> 30 v-model双向绑定原理</h2> <blockquote><p><code>v-model</code>本质上是语法糖，<code>v-model</code>在内部为不同的输入元素使用不同的属性并抛出不同的事件</p></blockquote> <ul><li><code>text</code> 和 <code>textarea</code> 元素使用 value 属性和 input 事件</li> <li><code>checkbox</code> 和 <code>radio</code> 使用 checked 属性和 change 事件</li> <li><code>select</code> 字段将 value 作为 prop 并将 change 作为事件</li></ul> <p><strong>所以我们可以v-model进行如下改写：</strong></p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>sth<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
//  等同于
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>sth<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>sth = $event.target.value<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><ul><li>这个语法糖必须是固定的，也就是说属性必须为<code>value</code>，方法名必须为：<code>input</code>。</li> <li>知道了<code>v-model</code>的原理，我们可以在自定义组件上实现<code>v-model</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>//Parent
&lt;template&gt;
    {{num}}
    &lt;Child v-model=&quot;num&quot;&gt;
&lt;/template&gt;
export default {
    data(){
        return {
            num: 0
        }
    }
}

//Child
&lt;template&gt;
    &lt;div @click=&quot;add&quot;&gt;Add&lt;/div&gt;
&lt;/template&gt;
export default {
    props: ['value'],
    methods:{
        add(){
            this.$emit('input', this.value + 1)
        }
    }
}
</code></pre></div><h2 id="_31-scoped样式穿透"><a href="#_31-scoped样式穿透" class="header-anchor">#</a> 31 scoped样式穿透</h2> <blockquote><p><code>scoped</code>虽然避免了组件间样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除<code>scoped</code>属性</p></blockquote> <ol><li>使用<code>/deep/</code></li></ol> <div class="language- extra-class"><pre class="language-text"><code>//Parent
&lt;template&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;Child /&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
.wrap /deep/ .box{
    background: red;
}
&lt;/style&gt;

//Child
&lt;template&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
</code></pre></div><ol start="2"><li>使用两个style标签</li></ol> <div class="language- extra-class"><pre class="language-text"><code>//Parent
&lt;template&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;Child /&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
//其他样式
&lt;/style&gt;
&lt;style lang=&quot;scss&quot;&gt;
.wrap .box{
    background: red;
}
&lt;/style&gt;

//Child
&lt;template&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
</code></pre></div><h2 id="_32-ref的作用"><a href="#_32-ref的作用" class="header-anchor">#</a> 32 ref的作用</h2> <ul><li>获取<code>dom</code>元素<code>this.$refs.box</code></li> <li>获取子组件中的<code>datathis.$refs.box.msg</code></li> <li>调用子组件中的方法<code>this.$refs.box.open()</code></li></ul> <h2 id="_33-computed和watch区别"><a href="#_33-computed和watch区别" class="header-anchor">#</a> 33 computed和watch区别</h2> <ol><li>当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed</li></ol> <blockquote><p><code>Computed</code>本质是一个具备缓存的<code>watcher</code>，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理</p></blockquote> <p><img src="http://poetries1.gitee.io/img-repo/2020/01/25.png" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>fullName<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            firstName<span class="token operator">:</span> <span class="token string">'xie'</span><span class="token punctuation">,</span>
            lastName<span class="token operator">:</span> <span class="token string">'yu fei'</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    computed<span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token function-variable function">fullName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li><code>watch</code>用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么<code>watch</code>为最佳选择</li></ol> <blockquote><p><code>Watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开<code>deep：true</code>选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用<code>unWatch</code>手动注销</p></blockquote> <p><img src="http://poetries1.gitee.io/img-repo/2020/01/26.png" alt=""></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;{{fullName}}&lt;/template&gt;
export default {
    data(){
        return {
            firstName: 'xie',
            lastName: 'xiao fei',
            fullName: 'xie xiao fei'
        }
    },
    watch:{
        firstName(val) {
            this.fullName = val + ' ' + this.lastName
        },
        lastName(val) {
            this.fullName = this.firstName + ' ' + val
        }
    }
}
</code></pre></div><h2 id="_34-vue-router守卫"><a href="#_34-vue-router守卫" class="header-anchor">#</a> 34 vue-router守卫</h2> <blockquote><p>导航守卫 <code>router.beforeEach</code> 全局前置守卫</p></blockquote> <ul><li><code>to: Route</code>: 即将要进入的目标（路由对象）</li> <li><code>from: Route</code>: 当前导航正要离开的路由</li> <li><code>next: Function</code>: 一定要调用该方法来 <code>resolve</code> 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）</li> <li>执行效果依赖 next 方法的调用参数。</li> <li><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li> <li><code>next(false)</code>:取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// main.js 入口文件</span>
<span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token punctuation">;</span> <span class="token comment">// 引入路由</span>
router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
router<span class="token punctuation">.</span><span class="token function">beforeResolve</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'afterEach 全局后置钩子'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>路由独享的守卫 你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token operator">:</span> <span class="token string">'/foo'</span><span class="token punctuation">,</span>
      component<span class="token operator">:</span> Foo<span class="token punctuation">,</span>
      <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>组件内的守卫你可以在路由组件内直接定义以下路由导航守卫</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteEnter</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在渲染该组件的对应路由被 confirm 前调用</span>
    <span class="token comment">// 不！能！获取组件实例 `this`</span>
    <span class="token comment">// 因为当守卫执行前，组件实例还没被创建</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在当前路由改变，但是该组件被复用时调用</span>
    <span class="token comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>
    <span class="token comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>
    <span class="token comment">// 可以访问组件实例 `this`</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 导航离开该组件的对应路由时调用，我们用它来禁止用户离开</span>
    <span class="token comment">// 可以访问组件实例 `this`</span>
    <span class="token comment">// 比如还未保存草稿，或者在用户离开前，</span>
    将setInterval销毁，防止离开之后，定时器还在调用。
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_35-vue修饰符"><a href="#_35-vue修饰符" class="header-anchor">#</a> 35 vue修饰符</h2> <ul><li><code>stop</code>：阻止事件的冒泡</li> <li><code>prevent</code>：阻止事件的默认行为</li> <li><code>once</code>：只触发一次</li> <li><code>self</code>：只触发自己的事件行为时，才会执行</li></ul> <h2 id="_36-vue项目中的性能优化"><a href="#_36-vue项目中的性能优化" class="header-anchor">#</a> 36 vue项目中的性能优化</h2> <ul><li>不要在模板里面写过多表达式</li> <li>循环调用子组件时添加key</li> <li>频繁切换的使用v-show，不频繁切换的使用v-if</li> <li>尽量少用float，可以用flex</li> <li>按需加载，可以用require或者import()按需加载需要的组件</li> <li>路由懒加载</li></ul> <h2 id="_37-vue-extend和vue-component"><a href="#_37-vue-extend和vue-component" class="header-anchor">#</a> 37 vue.extend和vue.component</h2> <ul><li><code>extend</code>是构造一个组件的语法器。
然后这个组件你可以作用到Vue.component这个全局注册方法里还可以在任意vue模板里使用组件。
也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li> <li><code>Vue.component</code>你可以创建 ，也可以取组件。</li></ul> <h2 id="_38-vue的spa-如何优化加载速度"><a href="#_38-vue的spa-如何优化加载速度" class="header-anchor">#</a> 38 Vue的SPA 如何优化加载速度</h2> <ul><li>减少入口文件体积</li> <li>静态资源本地缓存</li> <li>开启Gzip压缩</li> <li>使用SSR,nuxt.js</li></ul> <h2 id="_39-移动端如何设计一个比较友好的header组件"><a href="#_39-移动端如何设计一个比较友好的header组件" class="header-anchor">#</a> 39 移动端如何设计一个比较友好的Header组件？</h2> <blockquote><p>当时的思路是头部(Header)一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过vue props的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过vue slot插槽的方式对外暴露以实现多样化，同时也可以提供default slot默认插槽来统一页面风格</p></blockquote> <h2 id="_40-proxy与object-defineproperty的优劣对比"><a href="#_40-proxy与object-defineproperty的优劣对比" class="header-anchor">#</a> 40 Proxy与Object.defineProperty的优劣对比?</h2> <p><strong>Proxy的优势如下:</strong></p> <ul><li>Proxy可以直接监听对象而非属性</li> <li>Proxy可以直接监听数组的变化</li> <li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li> <li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</li> <li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li></ul> <p><strong>Object.defineProperty的优势如下:</strong></p> <p>兼容性好,支持IE9</p> <h2 id="_41-你是如何理解vue的响应式系统的"><a href="#_41-你是如何理解vue的响应式系统的" class="header-anchor">#</a> 41 你是如何理解Vue的响应式系统的?</h2> <p><img src="http://poetries1.gitee.io/img-repo/2020/07/66.png" alt=""></p> <p><strong>响应式系统简述:</strong></p> <ul><li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li> <li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li> <li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li> <li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。</li></ul> <h2 id="_42-既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异"><a href="#_42-既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异" class="header-anchor">#</a> 42 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?</h2> <blockquote><p>现代前端框架有两种方式侦测变化,一种是pull一种是push</p></blockquote> <ul><li>pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</li> <li>push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的</li></ul> <h2 id="_43-vue为什么没有类似于react中shouldcomponentupdate的生命周期"><a href="#_43-vue为什么没有类似于react中shouldcomponentupdate的生命周期" class="header-anchor">#</a> 43 Vue为什么没有类似于React中shouldComponentUpdate的生命周期？</h2> <p>考点: Vue的变化侦测原理</p> <p>前置知识: 依赖收集、虚拟DOM、响应式系统</p> <blockquote><p>根本原因是Vue与React的变化侦测方式有所不同</p></blockquote> <ul><li>React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.</li> <li>Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.</li></ul> <h2 id="_44-vue中的key到底有什么用"><a href="#_44-vue中的key到底有什么用" class="header-anchor">#</a> 44 Vue中的key到底有什么用？</h2> <ul><li>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</li> <li>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</li></ul> <blockquote><p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p></blockquote> <blockquote><p>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug.
快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度<code>O(n)</code>,<code>Map</code>的时间复杂度仅仅为<code>O(1)</code>.</p></blockquote> <p><img src="http://poetries1.gitee.io/img-repo/2020/07/67.png" alt=""></p> <h2 id="_45-vue-项目性能优化"><a href="#_45-vue-项目性能优化" class="header-anchor">#</a> 45 vue 项目性能优化</h2> <p><strong>代码层面：</strong></p> <ul><li>合理使用 <code>v-if</code> 和 <code>v-show</code></li> <li>区分 <code>computed</code> 和 <code>watch</code> 的使用</li> <li><code>v-for</code> 遍历为 <code>item</code> 添加 <code>key</code></li> <li><code>v-for</code> 遍历避免同时使用 <code>v-if</code></li> <li>通过 <code>addEventListener</code>添加的事件在组件销毁时要用 <code>removeEventListener</code> 手动移除这些事件的监听</li> <li>图片懒加载</li> <li>路由懒加载</li> <li>第三方插件按需引入</li> <li><code>SSR</code>服务端渲染，首屏加载速度快，<code>SEO</code>效果好</li></ul> <p><strong>Webpack 层面优化：</strong></p> <ul><li>对图片进行压缩</li> <li>使用 <code>CommonsChunkPlugin</code> 插件提取公共代码</li> <li>提取组件的 CSS</li> <li>优化 <code>SourceMap</code></li> <li>构建结果输出分析，利用 <code>webpack-bundle-analyzer</code> 可视化分析工具</li></ul> <h2 id="_46-nexttick"><a href="#_46-nexttick" class="header-anchor">#</a> 46 nextTick</h2> <blockquote><p><code>nextTick</code> 可以让我们在下次 <code>DOM</code> 更新循环结束之后执行延迟回调，用于获得更新后的 <code>DOM</code></p></blockquote> <p><code>nextTick</code>主要使用了宏任务和微任务。根据执行环境分别尝试采用</p> <ul><li><code>Promise</code></li> <li><code>MutationObserver</code></li> <li><code>setImmediate</code></li> <li>如果以上都不行则采用<code>setTimeout</code></li></ul> <blockquote><p>定义了一个异步方法，多次调用<code>nextTick</code>会将方法存入队列中，通过这个异步方法清空当前队列</p></blockquote> <h2 id="_47-说一下vue2-x中如何监测数组变化"><a href="#_47-说一下vue2-x中如何监测数组变化" class="header-anchor">#</a> 47 说一下vue2.x中如何监测数组变化</h2> <blockquote><p>使用了函数劫持的方式，重写了数组的方法，<code>Vue</code>将<code>data</code>中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p></blockquote> <h2 id="_48-你的接口请求一般放在哪个生命周期中"><a href="#_48-你的接口请求一般放在哪个生命周期中" class="header-anchor">#</a> 48 你的接口请求一般放在哪个生命周期中</h2> <blockquote><p>接口请求一般放在<code>mounted</code>中，但需要注意的是服务端渲染时不支持<code>mounted</code>，需要放到<code>created</code>中</p></blockquote> <h2 id="_49-组件中的data为什么是一个函数"><a href="#_49-组件中的data为什么是一个函数" class="header-anchor">#</a> 49 组件中的data为什么是一个函数</h2> <blockquote><p>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果<code>data</code>是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间d<code>ata</code>不冲突，data必须是一个函数</p></blockquote> <h2 id="_50-说一下v-model的原理"><a href="#_50-说一下v-model的原理" class="header-anchor">#</a> 50 说一下v-model的原理</h2> <blockquote><p><code>v-model</code>本质就是一个语法糖，可以看成是<code>value + input</code>方法的语法糖。 可以通过<code>model</code>属性的<code>prop</code>和<code>event</code>属性来进行自定义。原生的<code>v-model</code>，会根据标签的不同生成不同的事件和属性</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>searchData<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>等价于</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> 
	<span class="token attr-name"><span class="token namespace">v-bind:</span>value</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span>searchData<span class="token punctuation">'</span></span>
	<span class="token attr-name"><span class="token namespace">v-on:</span>input</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span>searchData = $event.target.value<span class="token punctuation">'</span></span>
<span class="token punctuation">&gt;</span></span>
</code></pre></div><p>当在input元素中使用<code>v-model</code>实现双数据绑定，其实就是在输入的时候触发元素的input事件，通过这个语法糖，实现了数据的双向绑定。</p> <h2 id="_51-vue事件绑定原理说一下"><a href="#_51-vue事件绑定原理说一下" class="header-anchor">#</a> 51 Vue事件绑定原理说一下</h2> <blockquote><p>原生事件绑定是通过<code>addEventListener</code>绑定给真实元素的，组件事件绑定是通过<code>Vue</code>自定义的<code>$on</code>实现的</p></blockquote> <h2 id="_52-vue模版编译原理知道吗-能简单说一下吗"><a href="#_52-vue模版编译原理知道吗-能简单说一下吗" class="header-anchor">#</a> 52 Vue模版编译原理知道吗，能简单说一下吗？</h2> <blockquote><p>简单说，<code>Vue</code>的编译过程就是将<code>template</code>转化为<code>render</code>函数的过程。会经历以下阶段：</p></blockquote> <ul><li><p>生成<code>AST</code>树</p></li> <li><p>优化</p></li> <li><p><code>codegen</code></p></li> <li><p>首先解析模版，生成<code>AST</code>语法树(一种用J<code>avaScript</code>对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p></li> <li><p><code>Vue</code>的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p></li> <li><p>编译的最后一步是将优化后的<code>AST</code>树转换为可执行的代码</p></li></ul> <h2 id="_53-vue2-x和vue3-x渲染器的diff算法分别说一下"><a href="#_53-vue2-x和vue3-x渲染器的diff算法分别说一下" class="header-anchor">#</a> 53 Vue2.x和Vue3.x渲染器的diff算法分别说一下</h2> <blockquote><p>简单来说，<code>diff</code>算法有以下过程</p></blockquote> <ul><li><p>同级比较，再比较子节点</p></li> <li><p>先判断一方有子节点一方没有子节点的情况(如果新的<code>children</code>没有子节点，将旧的子节点移除)</p></li> <li><p>比较都有子节点的情况(核心<code>diff</code>)</p></li> <li><p>递归比较子节点</p></li> <li><p>正常<code>Diff</code>两个树的时间复杂度是<code>O(n^3)</code>，但实际情况下我们很少会进行跨层级的移动<code>DOM</code>，所以<code>Vue</code>将<code>Diff</code>进行了优化，从<code>O(n^3) -&gt; O(n)</code>，只有当新旧<code>children</code>都为多个子节点时才需要用核心的<code>Diff</code>算法进行同层级比较。</p></li> <li><p><code>Vue2</code>的核心<code>Diff</code>算法采用了双端比较的算法，同时从新旧<code>children</code>的两端开始进行比较，借助<code>key</code>值找到可复用的节点，再进行相关操作。相比<code>React</code>的<code>Diff</code>算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅</p></li> <li><p>在创建<code>VNode</code>时就确定其类型，以及在<code>mount/patch</code>的过程中采用位运算来判断一个<code>VNode</code>的类型，在这个基础之上再配合核心的<code>Diff</code>算法，使得性能上较<code>Vue2.x</code>有了提升</p></li></ul> <h2 id="_54-再说一下虚拟dom以及key属性的作用"><a href="#_54-再说一下虚拟dom以及key属性的作用" class="header-anchor">#</a> 54 再说一下虚拟Dom以及key属性的作用</h2> <ul><li>由于在浏览器中操作<code>DOM</code>是很昂贵的。频繁的操作<code>DOM</code>，会产生一定的性能问题。这就是虚拟Dom的产生原因</li> <li><code>Virtual DOM</code>本质就是用一个原生的JS对象去描述一个<code>DOM</code>节点。是对真实DOM的一层抽象</li> <li><code>VirtualDOM</code>映射到真实DOM要经历<code>VNode</code>的<code>create</code>、<code>diff</code>、<code>patch</code>等阶段</li></ul> <p><strong>key的作用是尽可能的复用 DOM 元素</strong></p> <ul><li>新旧 <code>children</code> 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的</li> <li>需要在新旧 <code>children</code> 的节点中保存映射关系，以便能够在旧 <code>children</code> 的节点中找到可复用的节点。<code>key</code>也就是<code>children</code>中节点的唯一标识</li></ul> <h2 id="_55-vue中组件生命周期调用顺序说一下"><a href="#_55-vue中组件生命周期调用顺序说一下" class="header-anchor">#</a> 55 Vue中组件生命周期调用顺序说一下</h2> <ul><li>渲染顺序：先父后子，完成顺序：先子后父</li> <li>更新顺序：父更新导致子更新，子更新完成后父</li> <li>销毁顺序：先父后子，完成顺序：先子后父</li></ul> <p><strong>加载渲染过程</strong></p> <blockquote><p><code>父beforeCreate</code>-&gt;<code>父created</code>-&gt;<code>父beforeMount</code>-&gt;<code>子beforeCreate</code>-&gt;<code>子created</code>-&gt;<code>子beforeMount</code>- &gt;<code>子mounted</code>-&gt;<code>父mounted</code></p></blockquote> <p><strong>子组件更新过程</strong></p> <blockquote><p><code>父beforeUpdate</code>-&gt;<code>子beforeUpdate</code>-&gt;<code>子updated</code>-&gt;<code>父updated</code></p></blockquote> <p><strong>父组件更新过程</strong></p> <blockquote><p><code>父 beforeUpdate</code> -&gt; <code>父 updated</code></p></blockquote> <p><strong>销毁过程</strong></p> <blockquote><p><code>父beforeDestroy</code>-&gt;<code>子beforeDestroy</code>-&gt;<code>子destroyed</code>-&gt;<code>父destroyed</code></p></blockquote> <h2 id="_56-ssr了解吗"><a href="#_56-ssr了解吗" class="header-anchor">#</a> 56 SSR了解吗</h2> <blockquote><p><code>SSR</code>也就是服务端渲染，也就是将<code>Vue</code>在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p></blockquote> <p><code>SSR</code>有着更好的<code>SEO</code>、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持<code>beforeCreate</code>和<code>created</code>两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于<code>Node.js</code>的运行环境。还有就是服务器会有更大的负载需求</p> <h2 id="_57-你都做过哪些vue的性能优化"><a href="#_57-你都做过哪些vue的性能优化" class="header-anchor">#</a> 57 你都做过哪些Vue的性能优化</h2> <p><strong>编码阶段</strong></p> <ul><li>尽量减少<code>data</code>中的数据，<code>data</code>中的数据都会增加<code>getter</code>和<code>setter</code>，会收集对应的<code>watcher</code></li> <li><code>v-if</code>和<code>v-for</code>不能连用</li> <li>如果需要使用<code>v-for</code>给每项元素绑定事件时使用事件代理</li> <li><code>SPA</code> 页面采用<code>keep-alive</code>缓存组件</li> <li>在更多的情况下，使用<code>v-if</code>替代<code>v-show</code></li> <li><code>key</code>保证唯一</li> <li>使用路由懒加载、异步组件</li> <li>防抖、节流</li> <li>第三方模块按需导入</li> <li>长列表滚动到可视区域动态加载</li> <li>图片懒加载</li></ul> <p><strong>SEO优化</strong></p> <ul><li>预渲染</li> <li>服务端渲染<code>SSR</code></li></ul> <p><strong>打包优化</strong></p> <ul><li>压缩代码</li> <li><code>Tree Shaking/Scope Hoisting</code></li> <li>使用<code>cdn</code>加载第三方模块</li> <li>多线程打包<code>happypack</code></li> <li><code>splitChunks</code>抽离公共文件</li> <li><code>sourceMap</code>优化</li></ul> <p><strong>用户体验</strong></p> <ul><li>骨架屏</li> <li><code>PWA</code></li></ul> <blockquote><p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启<code>gzip</code>压缩等。</p></blockquote> <h2 id="_58-vue-js特点"><a href="#_58-vue-js特点" class="header-anchor">#</a> 58 Vue.js特点</h2> <ul><li>简洁：页面由<code>HTML</code>模板+Json数据+<code>Vue</code>实例组成</li> <li>数据驱动：自动计算属性和追踪依赖的模板表达式</li> <li>组件化：用可复用、解耦的组件来构造页面</li> <li>轻量：代码量小，不依赖其他库</li> <li>快速：精确有效批量DOM更新</li> <li>模板友好：可通过npm，bower等多种方式安装，很容易融入</li></ul> <h2 id="_59-请说出vue-cli项目中src目录每个文件夹和文件的用法"><a href="#_59-请说出vue-cli项目中src目录每个文件夹和文件的用法" class="header-anchor">#</a> 59 请说出vue.cli项目中src目录每个文件夹和文件的用法</h2> <ul><li><code>assets</code>文件夹是放静态资源；</li> <li><code>components</code>是放组件；</li> <li><code>router</code>是定义路由相关的配置;</li> <li><code>view</code>视图；</li> <li><code>app.vue</code>是一个应用主组件；</li> <li><code>main.js</code>是入口文件</li></ul> <h2 id="_60-vue路由传参数"><a href="#_60-vue路由传参数" class="header-anchor">#</a> 60 vue路由传参数</h2> <ul><li>使用<code>query</code>方法传入的参数使用<code>this.$route.query</code>接受</li> <li>使用<code>params</code>方式传入的参数使用<code>this.$route.params</code>接受</li></ul> <h2 id="_61-vuex-是什么-有哪几种属性"><a href="#_61-vuex-是什么-有哪几种属性" class="header-anchor">#</a> 61 vuex 是什么？ 有哪几种属性？</h2> <blockquote><ul><li><code>Vuex</code> 是一个专为 <code>Vue.js</code> 应用程序开发的状态管理模式。</li> <li>有 5 种，分别是 <code>state</code>、<code>getter</code>、<code>mutation</code>、<code>action</code>、<code>module</code></li></ul></blockquote> <ul><li><code>Vuex</code> 是一个专为 <code>Vue.js</code> 应用程序开发的状态管理模式。</li> <li>有 5 种，分别是 <code>state</code>、<code>getter</code>、<code>mutation</code>、<code>action</code>、<code>module</code></li> <li><code>vuex</code> 的 <code>store</code> 是什么？</li> <li><code>vuex</code> 就是一个仓库，仓库里放了很多对象。其中 <code>state</code> 就是数据源存放地，对应于一般 vue 对象里面的 <code>datastate</code> 里面存放的数据是响应式的，<code>vue</code> 组件从 <code>store</code> 读取数据，若是 <code>store</code> 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 <code>mapState</code> 把全局的 <code>state</code> 和 <code>getters</code> 映射到当前组件的 <code>computed</code> 计算属性</li></ul> <p><strong>vuex 的 getter 是什么？</strong></p> <ul><li><code>getter</code> 可以对 <code>state</code> 进行计算操作，它就是 <code>store</code> 的计算属性虽然在组件内也可以做计算属性，但是 <code>getters</code> 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 <code>getters</code></li></ul> <p><strong>vuex 的 mutation 是什么？</strong></p> <ul><li>更改<code>Vuex</code>的<code>store</code>中的状态的唯一方法是提交<code>mutation</code></li></ul> <p><strong>vuex 的 action 是什么？</strong></p> <ul><li><code>action</code> 类似于 <code>muation</code>, 不同在于：<code>action</code> 提交的是 <code>mutation</code>,而不是直接变更状态<code>action</code> 可以包含任意异步操作</li> <li><code>vue</code> 中 <code>ajax</code> 请求代码应该写在组件的 <code>methods</code> 中还是 <code>vuex</code> 的 <code>action</code> 中</li> <li><code>vuex</code> 的 <code>module</code> 是什么？</li></ul> <blockquote><p>面对复杂的应用程序，当管理的状态比较多时；我们需要将<code>vuex</code>的<code>store</code>对象分割成模块(<code>modules</code>)。</p></blockquote> <blockquote><p>如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 <code>vuex</code> 的 <code>state</code> 里如果被其他地方复用，请将请求放入 <code>action</code> 里，方便复用，并包装成 <code>promise</code> 返回</p></blockquote> <h2 id="_62-如何让css只在当前组件中起作用"><a href="#_62-如何让css只在当前组件中起作用" class="header-anchor">#</a> 62 如何让CSS只在当前组件中起作用？</h2> <blockquote><p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></p></blockquote> <h2 id="_63-delete和vue-delete删除数组的区别"><a href="#_63-delete和vue-delete删除数组的区别" class="header-anchor">#</a> 63 delete和Vue.delete删除数组的区别？</h2> <ul><li><code>delete</code>只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li> <li><code>Vue.delete</code>直接删除了数组 改变了数组的键值。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> b<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token keyword">delete</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">//[empty,2,3,4]</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$<span class="token keyword">delete</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment">//[2,3,4]</span>
</code></pre></div><h2 id="_64-v-on可以监听多个方法吗"><a href="#_64-v-on可以监听多个方法吗" class="header-anchor">#</a> 64 v-on可以监听多个方法吗？</h2> <p>可以</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onInput<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@focus</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onFocus<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@blur</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onBlur<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p><strong>v-on 常用修饰符</strong></p> <ul><li><code>.stop</code> 该修饰符将阻止事件向上冒泡。同理于调用 <code>event.stopPropagation()</code> 方法</li> <li><code>.prevent</code> 该修饰符会阻止当前事件的默认行为。同理于调用 <code>event.preventDefault()</code> 方法</li> <li><code>.self</code> 该指令只当事件是从事件绑定的元素本身触发时才触发回调</li> <li><code>.once</code> 该修饰符表示绑定的事件只会被触发一次</li></ul> <h2 id="_65-vue子组件调用父组件的方法"><a href="#_65-vue子组件调用父组件的方法" class="header-anchor">#</a> 65 Vue子组件调用父组件的方法</h2> <ul><li>第一种方法是直接在子组件中通过<code>this.$parent.event</code>来调用父组件的方法</li> <li>第二种方法是在子组件里用<code>$emit</code>向父组件触发一个事件，父组件监听这个事件就行了。</li></ul> <h2 id="_66-vue如何兼容ie的问题"><a href="#_66-vue如何兼容ie的问题" class="header-anchor">#</a> 66 vue如何兼容ie的问题</h2> <blockquote><p>babel-polyfill插件</p></blockquote> <h2 id="_67-vue-改变数组触发视图更新"><a href="#_67-vue-改变数组触发视图更新" class="header-anchor">#</a> 67 Vue 改变数组触发视图更新</h2> <blockquote><p>以下方法调用会改变原始数组：<code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code>, <code>sort()</code>, <code>reverse()</code>,<code>Vue.set( target, key, value )</code></p></blockquote> <ul><li>调用方法：<code>Vue.set( target, key, value )</code> <ul><li><code>target</code>：要更改的数据源(可以是对象或者数组)</li> <li><code>key</code>：要更改的具体数据</li> <li><code>value</code> ：重新赋的值</li></ul></li></ul> <h2 id="_68-dom-渲染在哪个周期中就已经完成"><a href="#_68-dom-渲染在哪个周期中就已经完成" class="header-anchor">#</a> 68 DOM 渲染在哪个周期中就已经完成？</h2> <blockquote><p>在<code>mounted</code></p></blockquote> <p>注意 <code>mounted</code> 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <code>vm.$nextTick</code> 替换掉 <code>mounted</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">mounted</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Code that will run only after the</span>
    <span class="token comment">// entire view has been rendered</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_69-简述每个周期具体适合哪些场景"><a href="#_69-简述每个周期具体适合哪些场景" class="header-anchor">#</a> 69 简述每个周期具体适合哪些场景</h2> <ul><li><code>beforecreate</code> : 可以在这加个<code>loading</code>事件，在加载实例时触发</li> <li><code>created</code> : 初始化完成时的事件写在这里，如在这结束<code>loading</code>事件，异步请求也适宜在这里调用</li> <li><code>mounted</code> : 挂载元素，获取到DOM节点 <code>updated</code> : 如果对数据统一处理，在这里写上相应函数</li> <li><code>beforeDestroy</code> : 可以做一个确认停止事件的确认框</li></ul> <p><strong>第一次加载会触发哪几个钩子</strong></p> <blockquote><p>会触发<code>beforeCreate</code> , <code>created</code> ,<code>beforeMount</code> ,<code>mounted</code></p></blockquote> <h2 id="_70-动态绑定class"><a href="#_70-动态绑定class" class="header-anchor">#</a> 70 动态绑定class</h2> <blockquote><p><code>active</code> <code>classname</code>， <code>isActive</code> 变量</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ active: isActive }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="_71-vue3-0-是如何变得更快的"><a href="#_71-vue3-0-是如何变得更快的" class="header-anchor">#</a> 71 Vue3.0 是如何变得更快的</h2> <h3 id="diff-方法优化"><a href="#diff-方法优化" class="header-anchor">#</a> diff 方法优化</h3> <ul><li><code>Vue2.x</code> 中的虚拟 dom 是进行全量的对比。</li> <li><code>Vue3.0</code> 中新增了静态标记(PatchFlag):在与上次虚拟结点进行对比的时候，值对比 带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化</li></ul> <h3 id="hoiststatic-静态提升"><a href="#hoiststatic-静态提升" class="header-anchor">#</a> hoistStatic 静态提升</h3> <ul><li><code>Vue2.x</code> : 无论元素是否参与更新，每次都会重新创建。</li> <li><code>Vue3.0</code> : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用</li></ul> <h3 id="cachehandlers-事件侦听器缓存"><a href="#cachehandlers-事件侦听器缓存" class="header-anchor">#</a> cacheHandlers 事件侦听器缓存</h3> <p>默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一 个函数，所以没有追踪变化，直接缓存起来复用即可</p> <h2 id="_72-说说你对-proxy-的理解"><a href="#_72-说说你对-proxy-的理解" class="header-anchor">#</a> 72 说说你对 proxy 的理解</h2> <p>vue 的数据劫持有两个缺点</p> <ul><li>无法监听通过索引修改数组的值的变化</li> <li>无法监听 object 也就是对象的值的变化</li> <li>所以 vue2.x 中才会有<code>$set</code> 属性的存在</li> <li>proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 <code>object.defineproperty</code>。</li></ul> <h2 id="_73-生命周期详解"><a href="#_73-生命周期详解" class="header-anchor">#</a> 73 生命周期详解</h2> <p><strong><em>init</em></strong></p> <ul><li><code>initLifecycle/Event</code>，往vm上挂载各种属性</li> <li><code>callHook: beforeCreated</code>: 实例刚创建</li> <li><code>initInjection/initState</code>: 初始化注入和 <code>data</code> 响应性</li> <li><code>created: 创建完成，属性已经绑定， 但还未生成真实</code>dom`</li> <li>进行元素的挂载： <code>$el / vm.$mount()</code></li> <li>是否有<code>template</code>: 解析成 <code>render function</code> <ul><li><code>*.vue</code>文件: <code>vue-loader</code>会将<code>&lt;template&gt;</code>编译成<code>render function</code></li></ul></li> <li><code>beforeMount</code>: 模板编译/挂载之前</li> <li>执行<code>render function</code>，生成真实的<code>dom</code>，并替换到<code>dom tree</code>中</li> <li><code>mounted</code>: 组件已挂载</li></ul> <p><strong>update</strong></p> <ul><li>执行<code>diff</code>算法，比对改变是否需要触发<code>UI</code>更新</li> <li><code>flushScheduleQueue</code></li> <li><code>watcher.before</code>: 触发<code>beforeUpdate</code>钩子	- <code>watcher.run()</code>: 执行<code>watcher</code>中的 <code>notify</code>，通知所有依赖项更新UI</li> <li>触发<code>updated</code>钩子: 组件已更新</li> <li><code>actived / deactivated(keep-alive)</code>: 不销毁，缓存，组件激活与失活</li> <li><code>destroy</code> <ul><li><code>beforeDestroy</code>: 销毁开始</li> <li>销毁自身且递归销毁子组件以及事件监听
<ul><li><code>remove()</code>: 删除节点</li> <li><code>watcher.teardown()</code>: 清空依赖</li> <li><code>vm.$off()</code>: 解绑监听</li></ul></li> <li><code>destroyed</code>: 完成后触发钩子</li></ul></li></ul> <blockquote><p>上面是vue的声明周期的简单梳理，接下来我们直接以代码的形式来完成vue的初始化</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 初始化Vue实例</span>
<span class="token keyword">function</span> <span class="token function">_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 挂载属性</span>
    <span class="token function">initLifeCycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> 
    <span class="token comment">// 初始化事件系统，钩子函数等</span>
    <span class="token function">initEvent</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> 
    <span class="token comment">// 编译slot、vnode</span>
    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> 
    <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
    <span class="token comment">// 添加inject功能</span>
    <span class="token function">initInjection</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 完成数据响应性 props/data/watch/computed/methods</span>
    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 添加 provide 功能</span>
    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>
		
	 <span class="token comment">// 挂载节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 挂载节点实现</span>
<span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 获取 render function</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// template to render</span>
        <span class="token comment">// Vue.compile = compileToFunctions</span>
        <span class="token keyword">let</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">compileToFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>render <span class="token operator">=</span> render
    <span class="token punctuation">}</span>
    <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span><span class="token string">'beforeMounte'</span><span class="token punctuation">)</span>
    <span class="token comment">// 初始化观察者</span>
    <span class="token comment">// render 渲染 vdom， </span>
    vdom <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// update: 根据 diff 出的 patchs 挂载成真实的 dom </span>
    vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vdom<span class="token punctuation">)</span>
    <span class="token comment">// 触发钩子  </span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'mounted'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 更新节点实现</span>
funtion <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">nextTick</span><span class="token punctuation">(</span>flushScheduleQueue<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 清空队列</span>
<span class="token keyword">function</span> <span class="token function">flushScheduleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 遍历队列中所有修改</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token comment">// beforeUpdate</span>
        watcher<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         
        <span class="token comment">// 依赖局部更新节点</span>
        watcher<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
        <span class="token function">callHook</span><span class="token punctuation">(</span><span class="token string">'updated'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 销毁实例实现</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$destory</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeDestory'</span><span class="token punctuation">)</span>
    <span class="token comment">// 自身及子节点</span>
    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token comment">// 删除依赖</span>
    watcher<span class="token punctuation">.</span><span class="token function">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token comment">// 删除监听</span>
    vm<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'destoryed'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_74-proxy-相比于-defineproperty-的优势"><a href="#_74-proxy-相比于-defineproperty-的优势" class="header-anchor">#</a> 74 Proxy 相比于 defineProperty 的优势</h2> <ul><li>数组变化也能监听到</li> <li>不需要深度遍历监听</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> reactiveData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
	<span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// ...</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_75-vue-router"><a href="#_75-vue-router" class="header-anchor">#</a> 75 vue-router</h2> <p><strong>mode</strong></p> <ul><li><code>hash</code></li> <li><code>history</code></li></ul> <p><strong>跳转</strong></p> <ul><li><code>this.$router.push()</code></li> <li><code>&lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;</code></li></ul> <p><strong>占位</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-view&gt;&lt;/router-view&gt;
</code></pre></div><h2 id="_76-vuex总结"><a href="#_76-vuex总结" class="header-anchor">#</a> 76 vuex总结</h2> <ul><li><code>state</code>: 状态中心</li> <li><code>mutations</code>: 更改状态</li> <li><code>actions</code>: 异步更改状态</li> <li><code>getters</code>: 获取状态</li> <li><code>modules</code>: 将<code>state</code>分成多个<code>modules</code>，便于管理</li></ul> <h2 id="_77-diff-算法"><a href="#_77-diff-算法" class="header-anchor">#</a> 77 diff 算法</h2> <p><strong>时间复杂度：</strong> 个树的完全<code>diff</code> 算法是一个时间复杂度为<code>O(n*3）</code> ，vue进行优化转化成<code>O(n)</code> 。</p> <p><strong>理解：</strong></p> <ul><li>最小量更新，<code>key</code> 很重要。这个可以是这个节点的唯一标识，告诉<code>diff</code> 算法，在更改前后它们是同一个DOM节点
<ul><li>扩展<code>v-for</code> 为什么要有<code>key</code> ，没有<code>key</code> 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改DOM），加<code>key</code> 只会移动减少操作DOM。</li></ul></li> <li>只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。</li> <li>只进行同层比较，不会进行跨层比较。</li></ul> <p><strong>diff算法的优化策略</strong>：四种命中查找，四个指针</p> <ol><li>旧前与新前（先比开头，后插入和删除节点的这种情况）</li> <li>旧后与新后（比结尾，前插入或删除的情况）</li> <li>旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）</li> <li>旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）</li></ol> <h2 id="_78-vue-的响应式原理中-object-defineproperty-有什么缺陷"><a href="#_78-vue-的响应式原理中-object-defineproperty-有什么缺陷" class="header-anchor">#</a> 78 Vue 的响应式原理中 Object.defineProperty 有什么缺陷</h2> <ul><li><code>Object.defineProperty</code> 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li> <li><code>Object.defineProperty</code> 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象</li> <li><code>Proxy</code> 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性</li></ul> <h2 id="_79-composition-api"><a href="#_79-composition-api" class="header-anchor">#</a> 79 Composition API</h2> <ul><li><code>Composition API</code>出现就是为了解决Options API导致相同功能代码分散的现象</li></ul> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e78168afbb094679a7ff6209aa7b734c~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p><strong>compositon api提供了以下几个函数：</strong></p> <ul><li><code>setup</code></li> <li><code>ref</code></li> <li><code>reactive</code></li> <li><code>watchEffect</code></li> <li><code>watch</code></li> <li><code>computed</code></li> <li><code>toRefs</code></li> <li>生命周期的<code>hooks</code></li></ul> <h2 id="_80-vue中是如何检测数组变化的呢"><a href="#_80-vue中是如何检测数组变化的呢" class="header-anchor">#</a> 80 vue中是如何检测数组变化的呢</h2> <blockquote><p>数组就是使用 <code>object.defineProperty</code> 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， <code>pop</code> 、 <code>push</code> 、 <code>shift</code> 、 <code>unshift</code> 、 <code>splice</code> 、 <code>sort</code> 、 <code>reverse</code> 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解</p></blockquote> <ul><li>是用函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新</li> <li>数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测）</li></ul> <blockquote><p><code>vue3</code>：改用 <code>proxy</code> ，可直接监听对象数组的变化</p></blockquote> <h2 id="_81-vue的事件绑定原理"><a href="#_81-vue的事件绑定原理" class="header-anchor">#</a> 81 Vue的事件绑定原理</h2> <ul><li>原生 DOM 的绑定：Vue在创建真实DOM时会调用 <code>createElm</code> ，默认会调用 <code>invokeCreateHooks</code> 。会遍历当前平台下相对的属性处理代码，其中就有 <code>updateDOMLListeners</code>方法，内部会传入 <code>add（）</code> 方法</li> <li>组件绑定事件，原生事件，自定义事件；组件绑定之间是通过<code>Vue</code>中自定义的 <code>$on</code> 方法实现的</li></ul> <blockquote><p>可以理解为：组件的 <code>nativeOnOn</code> 等价于 普通元素on 组件的on会单独处理</p></blockquote> <h2 id="_82-v-model中的实现原理及如何自定义v-model"><a href="#_82-v-model中的实现原理及如何自定义v-model" class="header-anchor">#</a> 82 v-model中的实现原理及如何自定义v-model</h2> <blockquote><p><code>v-model</code> 可以看成是 <code>value+input</code> 方法的语法糖（组件）。原生的 <code>v-model</code> ，会根据标签的不同生成不同的事件与属性。解析一个指令来</p></blockquote> <p>自定义：自己写 <code>model</code> 属性，里面放上 <code>prop</code> 和 <code>event</code></p> <h2 id="_83-为什么vue采用异步渲染呢"><a href="#_83-为什么vue采用异步渲染呢" class="header-anchor">#</a> 83 为什么Vue采用异步渲染呢</h2> <blockquote><p>Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 <code>nextTick</code></p></blockquote> <p><code>dep.notify（）</code> 通知 <code>watcher</code>进行更新， subs[i].update 依次调用 <code>watcher</code> 的 <code>update</code> ， <code>queueWatcher</code> 将<code>watcher</code> 去重放入队列， nextTick（ flushSchedulerQueue ）在下一<code>tick</code>中刷新<code>watcher</code>队列（异步）</p> <h2 id="_84-vuex-工作原理"><a href="#_84-vuex-工作原理" class="header-anchor">#</a> 84 Vuex 工作原理</h2> <p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</p> <p>状态自管理应用包含以下几个部分：</p> <ul><li>state，驱动应用的数据源；</li> <li>view，以声明方式将 state 映射到视图；</li> <li>actions，响应在 view 上的用户输入导致的状态变化。下图单向数据流示意图：</li></ul> <p><img src="http://img-repo.poetries.top/images/image-20210220193818922.png" alt="image-20210220193818922"></p> <p>vuex，多组件共享状态，因-单向数据流简洁性很容易被破坏：</p> <ul><li>多个视图依赖于同一状态。</li> <li>来自不同视图的行为需要变更同一状态</li></ul> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17eb2230b3f46729cbfbe7144873065~tplv-k3u1fbpfcp-watermark.image?imageslim" alt="img"></p> <h2 id="_85-如何从真实dom到虚拟dom"><a href="#_85-如何从真实dom到虚拟dom" class="header-anchor">#</a> 85 如何从真实DOM到虚拟DOM</h2> <p>涉及到Vue中的模板编译原理，主要过程：</p> <ol><li>将模板转换成<code>ast</code> 树，<code>ast</code> 用对象来描述真实的JS语法（将真实DOM转换成虚拟DOM）</li> <li>优化树</li> <li>将<code>ast</code> 树生成代码</li></ol> <h2 id="_86-computed-watch-和-method"><a href="#_86-computed-watch-和-method" class="header-anchor">#</a> 86 Computed watch 和 method</h2> <ul><li><strong>computed</strong>：默认<code>computed</code>也是一个<code>watcher</code>具备缓存，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。如果一个数据依赖于其他数据，使用<code>computed</code></li> <li><strong>watch</strong>：每次都需要执行函数。 <code>watch</code> 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。</li> <li><strong>method</strong>：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大</li></ul> <h2 id="_87-为什么要使用异步组件"><a href="#_87-为什么要使用异步组件" class="header-anchor">#</a> 87 为什么要使用异步组件？</h2> <ol><li>节省打包出的结果，异步组件分开打包，采用<code>jsonp</code>的方式进行加载，有效解决文件过大的问题。</li> <li>核心就是包组件定义变成一个函数，依赖<code>import（）</code> 语法，可以实现文件的分割加载。</li></ol> <h2 id="_88-action-与-mutation-的区别"><a href="#_88-action-与-mutation-的区别" class="header-anchor">#</a> 88 action 与 mutation 的区别</h2> <ul><li><code>mutation</code> 是同步更新，<code>$watch</code> 严格模式下会报错</li> <li><code>action</code> 是同步操作，可以获取数据后调用<code>mutation</code> 提交最终数据</li></ul> <h2 id="_89-插槽与作用域插槽的区别"><a href="#_89-插槽与作用域插槽的区别" class="header-anchor">#</a> 89 插槽与作用域插槽的区别</h2> <p><strong>插槽</strong></p> <ul><li>创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类<code>{a:[vnode],b[vnode]}</code></li> <li>渲染组件时会拿对应的<code>slot</code> 属性的节点进行替换操作。（插槽的作用域为父组件）</li></ul> <p><strong>作用域插槽</strong></p> <ul><li>作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。</li> <li>普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。</li></ul> <h2 id="_90-vue中相同逻辑如何抽离"><a href="#_90-vue中相同逻辑如何抽离" class="header-anchor">#</a> 90 vue中相同逻辑如何抽离</h2> <blockquote><p>其实就是考察<code>vue.mixin</code> 用法，给组件每个生命周期，函数都混入一些公共逻辑。</p></blockquote> <h2 id="_91-谈谈对keep-alive的了解"><a href="#_91-谈谈对keep-alive的了解" class="header-anchor">#</a> 91 谈谈对keep-alive的了解</h2> <blockquote><p><code>keep-alive</code> 可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。常用的2个属性<code>include/exclude</code> ，2个生命周期<code>activated</code> ，<code>deactivated</code></p></blockquote> <h2 id="_92-vue性能优化"><a href="#_92-vue性能优化" class="header-anchor">#</a> 92 Vue性能优化</h2> <p><strong>编码优化</strong>：</p> <ul><li>事件代理</li> <li><code>keep-alive</code></li> <li>拆分组件</li> <li><code>key</code> 保证唯一性</li> <li>路由懒加载、异步组件</li> <li>防抖节流</li></ul> <p><strong>Vue加载性能优化</strong></p> <ul><li>第三方模块按需导入（<code>babel-plugin-component</code> ）</li> <li>图片懒加载</li></ul> <p><strong>用户体验</strong></p> <ul><li><code>app-skeleton</code>  骨架屏</li> <li><code>shellap</code> p壳</li> <li><code>pwa</code></li></ul> <p><strong>SEO优化</strong></p> <ul><li>预渲染</li></ul> <h2 id="_93-vue3-0相对于vue2-x有哪些不同"><a href="#_93-vue3-0相对于vue2-x有哪些不同" class="header-anchor">#</a> 93 Vue3.0相对于Vue2.x有哪些不同？</h2> <p><strong>performance</strong></p> <p>首先在性能(performance)上有了更多的优化，一方面表现在<code>virtual dom</code>的生成上更快了，另外在底层还做了一些监听的缓存，也就是事件在被创建的时候会被推进一个缓存中，后续没有改变会直接取缓存。</p> <p><strong>tree-shaking</strong></p> <p>tree-shaking它表示的是在打包的时候会去除一些无用的代码。而在Vue3中对它的支持更加友好了，例如像transition、v-model、computed等功能没有用到的话，那么最后打包产生的代码就会将它们去除。也就是说，如果你的Vue项目只写了一个Hello Word的话，那么最后打包的代码中就只有一些核心的代码，如更新算法、响应式等，打包生成的文件可能就只有13.5kb。</p> <p><strong>Fragments</strong></p> <p>碎片(Fragments)，原本在Vue2.x中每个template下只能允许有一个根节点，但是在Vue3中它可以允许你有多个，用尤大大的话来说就是会将这些内容自动变为一个碎片。</p> <p><strong>TS</strong></p> <p>再者就是对TS的支持度很好。虽然Vue3本来就是用TS写的，但是不一定要用TS。另外它也支持Class Component，不过不是第一推荐。</p> <p><strong>Component API</strong></p> <p>语法上，对模版语法是零改变的。只不过更加推荐用Component API来写JS部分。Component API它并不是语法，而是新增的API。它带来的好处一个是逻辑重用，方便我们把一些功能的部分抽离出来。另一个它相对于options来说更加集中，用options来写代码想要追寻一个变量的变化比较麻烦。</p> <p><strong>关于兼容性</strong></p> <p>目前的Vue3.beta版本是不支持IE11的，因为核心的响应式原理用到了ES6的Proxy，但是以后会去兼容IE11。后面我们在创建一个Vue项目的时候，可以选择不同的版本，支持IE11和不支持IE11的。</p> <p><strong>什么时候能使用</strong></p> <p>现在的beta版本其实已经可以用了，对于一些新的小的项目可以试试水，这个可以自己评估。正式能够投入到生产使用中可能要等到年中 (终？)。</p> <h2 id="_94-vue中hash模式和history模式的区别"><a href="#_94-vue中hash模式和history模式的区别" class="header-anchor">#</a> 94 Vue中hash模式和history模式的区别</h2> <ul><li>最明显的是在显示上，<code>hash</code>模式的<code>URL</code>中会夹杂着<code>#</code>号，而<code>history</code>没有。</li> <li><code>Vue</code>底层对它们的实现方式不同。<code>hash</code>模式是依靠<code>onhashchange</code>事件(监听<code>location.hash</code>的改变)，而<code>history</code>模式是主要是依靠的<code>HTML5 history</code>中新增的两个方法，<code>pushState()</code>可以改变<code>url</code>地址且不会发送请求，<code>replaceState()</code>可以读取历史记录栈,还可以对浏览器记录进行修改。</li> <li>当真正需要通过<code>URL</code>向后端发送<code>HTTP</code>请求的时候，比如常见的用户手动输入<code>URL</code>后回车，或者是刷新(重启)浏览器，这时候<code>history</code>模式需要后端的支持。因为<code>history</code>模式下，前端的<code>URL</code>必须和实际向后端发送请求的<code>URL</code>一致，例如有一个<code>URL</code>是带有路径<code>path</code>的(例如<code>www.lindaidai.wang/blogs/id</code>)，如果后端没有对这个路径做处理的话，就会返回<code>404</code>错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个<code>404</code>页面。</li></ul> <p><code>hash:</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// location.hash获取到的是包括#号的，如&quot;#heading-3&quot;</span>
  <span class="token comment">// 所以可以截取一下</span>
	<span class="token keyword">let</span> hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_95-了解history有哪些方法吗-说下它们的区别"><a href="#_95-了解history有哪些方法吗-说下它们的区别" class="header-anchor">#</a> 95 了解history有哪些方法吗？说下它们的区别</h2> <p>history 这个对象在html5的时候新加入两个api <strong>history.pushState() 和 history.repalceState()</strong> 这两个 API可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。</p> <p>从参数上来说：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span>title<span class="token punctuation">,</span>url<span class="token punctuation">)</span>
<span class="token comment">//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取</span>
<span class="token comment">//title：标题，基本没用，一般传null</span>
<span class="token comment">//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。</span>
<span class="token comment">//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/，</span>
<span class="token comment">//执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/</span>

window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span>title<span class="token punctuation">,</span>url<span class="token punctuation">)</span>
<span class="token comment">//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录</span>
</code></pre></div><p>另外还有：</p> <ul><li><code>window.history.back()</code> 后退</li> <li><code>window.history.forward()</code>前进</li> <li><code>window.history.go(1)</code> 前进或者后退几步</li></ul> <p>从触发事件的监听上来说：</p> <ul><li><code>pushState()</code>和<code>replaceState()</code>不能被<code>popstate</code>事件所监听</li> <li>而后面三者可以，且用户点击浏览器前进后退键时也可以</li></ul> <h2 id="_96-如何监听-pushstate-和-replacestate-的变化呢"><a href="#_96-如何监听-pushstate-和-replacestate-的变化呢" class="header-anchor">#</a> 96 如何监听 pushState 和 replaceState 的变化呢？</h2> <p>利用自定义事件<code>new Event()</code>创建这两个事件，并全局监听：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>goPage2()<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>去page2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Page1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">goPage2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> count<span class="token operator">++</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">bb</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span><span class="token string">'page1.html'</span><span class="token punctuation">)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>history<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 这个不能监听到 pushState</span>
    <span class="token comment">// window.addEventListener('popstate', function (event) {</span>
    <span class="token comment">//   console.log(event)</span>
    <span class="token comment">// })</span>
    <span class="token keyword">function</span> <span class="token function">createHistoryEvent</span> <span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> fn <span class="token operator">=</span> history<span class="token punctuation">[</span>type<span class="token punctuation">]</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里的 arguments 就是调用 pushState 时的三个参数集合</span>
        <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
        <span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span>
        e<span class="token punctuation">.</span>arguments <span class="token operator">=</span> arguments
        window<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    history<span class="token punctuation">.</span>pushState <span class="token operator">=</span> <span class="token function">createHistoryEvent</span><span class="token punctuation">(</span><span class="token string">'pushState'</span><span class="token punctuation">)</span>
    history<span class="token punctuation">.</span>replaceState <span class="token operator">=</span> <span class="token function">createHistoryEvent</span><span class="token punctuation">(</span><span class="token string">'replaceState'</span><span class="token punctuation">)</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'pushState'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// { type: 'pushState', arguments: [...], target: Window, ... }</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'replaceState'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="_97-vue组件内的导航守卫有哪几个"><a href="#_97-vue组件内的导航守卫有哪几个" class="header-anchor">#</a> 97 Vue组件内的导航守卫有哪几个？</h2> <ul><li><code>beforeRouteEnter</code></li> <li><code>beforeRouteUpdate</code></li> <li><code>beforeLeave</code></li></ul> <h2 id="_98-beforerouteenter和另外两个有什么不同吗"><a href="#_98-beforerouteenter和另外两个有什么不同吗" class="header-anchor">#</a> 98 beforeRouteEnter和另外两个有什么不同吗？</h2> <p><code>beforeRouteEnter</code>是支持给<code>next</code>传递参数的唯一守卫，因为在这个路由守卫中还<strong>不能访问this</strong>，而为了能让我们访问组件实例，可以通过传一个回调给<code>next</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">vm</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		<span class="token comment">// vm 就是组件实例</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>	
<span class="token punctuation">}</span>
</code></pre></div><p>而对于另外两个，<code>this</code>已经可用，所以<strong>不支持传递回调</strong>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// just use `this`</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> to<span class="token punctuation">.</span>params<span class="token punctuation">.</span>name
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>离开守卫<code>beforeRouteLeave</code>通常用来禁止用户还未保存修改之前离开，可以通过<code>next(false)</code>来取消：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> answer <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Do you really want to leave? you have unsaved changes!'</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>answer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_99-完整的导航解析流程"><a href="#_99-完整的导航解析流程" class="header-anchor">#</a> 99 完整的导航解析流程</h2> <ol><li>导航被触发。</li> <li>在失活的组件里调用离开守卫。</li> <li>调用全局的 <code>beforeEach</code> 守卫。</li> <li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li> <li>在路由配置里调用 <code>beforeEnter</code>。</li> <li>解析异步路由组件。</li> <li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li> <li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li> <li>导航被确认。</li> <li>调用全局的 <code>afterEach</code> 钩子。</li> <li>触发 DOM 更新。</li> <li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ol> <h2 id="_100-你是怎么看vue和react的"><a href="#_100-你是怎么看vue和react的" class="header-anchor">#</a> 100 你是怎么看Vue和React的？</h2> <p>首先它们都是当今比较流行的前端框架。</p> <p><strong>相同点：</strong></p> <ol><li><code>Virtual DOM</code>。其中最大的一个相似之处就是都使用了<code>Virtual DOM</code>。(当然<code>Vue</code>是在<code>Vue2.x</code>才引用的)也就是能让我们通过操作数据的方式来改变真实的<code>DOM</code>状态。因为其实<code>Virtual DOM</code>的本质就是一个<code>JS</code>对象，它保存了对真实<code>DOM</code>的所有描述，是真实<code>DOM</code>的一个映射，所以当我们在进行频繁更新元素的时候，改变这个<code>JS</code>对象的开销远比直接改变真实<code>DOM</code>要小得多。</li> <li>组件化的开发思想。第二点来说就是它们都提倡这种组件化的开发思想，也就是建议将应用分拆成一个个功能明确的模块，再将这些模块整合在一起以满足我们的业务需求。</li> <li><code>Props</code>。<code>Vue</code>和<code>React</code>中都有<code>props</code>的概念，允许父组件向子组件传递数据。</li> <li>构建工具、Chrome插件、配套框架。还有就是它们的构建工具以及Chrome插件、配套框架都很完善。比如构建工具，<code>React</code>中可以使用<code>CRA</code>，<code>Vue</code>中可以使用对应的脚手架<code>vue-cli</code>。对于配套框架<code>Vue</code>中有<code>vuex、vue-router</code>，<code>React</code>中有<code>react-router、redux</code>。</li></ol> <p><strong>不同点</strong></p> <ol><li>模版的编写。最大的不同就是模版的编写，<code>Vue</code>鼓励你去写近似常规<code>HTML</code>的模板，<code>React</code>推荐你使用<code>JSX</code>去书写。</li> <li>状态管理与对象属性。在<code>React</code>中，应用的状态是比较关键的概念，也就是<code>state</code>对象，它允许你使用<code>setState</code>去更新状态。但是在<code>Vue</code>中，<code>state</code>对象并不是必须的，数据是由<code>data</code>属性在<code>Vue</code>对象中进行管理。</li> <li>虚拟<code>DOM</code>的处理方式不同。<code>Vue</code>中的虚拟<code>DOM</code>控制了颗粒度，组件层面走<code>watcher</code>通知，而组件内部走<code>vdom</code>做<code>diff</code>，这样，既不会有太多<code>watcher</code>，也不会让<code>vdom</code>的规模过大。而<code>React</code>走了类似于<code>CPU</code>调度的逻辑，把<code>vdom</code>这棵树，微观上变成了链表，然后利用浏览器的空闲时间来做<code>diff</code>。</li></ol></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/FE-Interview-Questions/excellent-docs/6-React.html" class="prev">6 React模块</a></span> <span class="next"><a href="/FE-Interview-Questions/excellent-docs/8-Node模块.html">8 Node模块</a>
      →
    </span></p></div>  <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="请先阅读购买协议" class="el-dialog el-dialog--center" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">请先阅读购买协议</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button disabled="disabled" type="button" class="el-button el-button--danger is-disabled" style="width:100%;"><!----><!----><span>我已阅读（8s）</span></button></span></div></div></div> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="付费阅读" class="el-dialog" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">付费阅读</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button disabled="disabled" type="button" class="el-button el-button--danger is-disabled" style="width:100%;"><!----><!----><span>确 定</span></button></span></div></div></div> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="dialog" class="el-dialog" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title"></span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div> <img src="data:image/png;base64,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" class="theme-float-btn"></main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/FE-Interview-Questions/assets/js/app.0b8f873d.js" defer></script><script src="/FE-Interview-Questions/assets/js/5.f68268af.js" defer></script><script src="/FE-Interview-Questions/assets/js/4.1cafbbe1.js" defer></script><script src="/FE-Interview-Questions/assets/js/77.68845809.js" defer></script><script src="/FE-Interview-Questions/assets/js/11.3e5297f1.js" defer></script>
  </body>
</html>
