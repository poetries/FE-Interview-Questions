<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>FE-Interview | 第五部分：高频考点</title>
    <meta name="description" content="前端面试题整理">
    
    
    <link rel="preload" href="/FE-Interview-Questions/assets/css/8.styles.ff8c914c.css" as="style"><link rel="preload" href="/FE-Interview-Questions/assets/js/app.c4dcc72c.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/2.64fabc8e.js" as="script"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/5.c5b0184c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/1.6ed79994.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/3.e4aa7d6f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/4.e94e271a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/0.2de76f9d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/6.456b61dd.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/7.fde83003.js">
    <link rel="stylesheet" href="/FE-Interview-Questions/assets/css/8.styles.ff8c914c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container custom-code-highlight"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/FE-Interview-Questions/" class="home-link router-link-active"><!----><span class="site-name">
      FE-Interview
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/FE-Interview-Questions/base/" class="nav-link">基础</a></div><div class="nav-item"><a href="/FE-Interview-Questions/improve/" class="nav-link">进阶</a></div><div class="nav-item"><a href="/FE-Interview-Questions/advance/" class="nav-link">高级</a></div><div class="nav-item"><a href="/FE-Interview-Questions/computed-base/" class="nav-link">通识</a></div><div class="nav-item"><a href="/FE-Interview-Questions/excellent/" class="nav-link router-link-exact-active router-link-active">精华</a></div><div class="nav-item"><a href="/FE-Interview-Questions/simply/" class="nav-link">简版</a></div><div class="nav-item"><a href="/FE-Interview-Questions/comprehensive/" class="nav-link">综合</a></div><div class="nav-item"><a href="http://blog.poetries.top/" target="_blank" rel="noopener noreferrer" class="nav-link">Blog</a></div><div class="nav-item"><a href="https://github.com/poetries/" target="_blank" rel="noopener noreferrer" class="nav-link">Github</a></div><a href="https://github.com/poetries/FE-Interview-Questions" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/FE-Interview-Questions/base/" class="nav-link">基础</a></div><div class="nav-item"><a href="/FE-Interview-Questions/improve/" class="nav-link">进阶</a></div><div class="nav-item"><a href="/FE-Interview-Questions/advance/" class="nav-link">高级</a></div><div class="nav-item"><a href="/FE-Interview-Questions/computed-base/" class="nav-link">通识</a></div><div class="nav-item"><a href="/FE-Interview-Questions/excellent/" class="nav-link router-link-exact-active router-link-active">精华</a></div><div class="nav-item"><a href="/FE-Interview-Questions/simply/" class="nav-link">简版</a></div><div class="nav-item"><a href="/FE-Interview-Questions/comprehensive/" class="nav-link">综合</a></div><div class="nav-item"><a href="http://blog.poetries.top/" target="_blank" rel="noopener noreferrer" class="nav-link">Blog</a></div><div class="nav-item"><a href="https://github.com/poetries/" target="_blank" rel="noopener noreferrer" class="nav-link">Github</a></div><a href="https://github.com/poetries/FE-Interview-Questions" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>基础</span><!----></p><ul class="sidebar-group-items"><li><a href="/FE-Interview-Questions/base/" class="sidebar-link">第一部分：基础篇</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>进阶</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>高级</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>通识</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>精华</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/FE-Interview-Questions/excellent/" class="active sidebar-link">第五部分：高频考点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_1-typeof类型判断" class="sidebar-link">1 typeof类型判断</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_2-类型转换" class="sidebar-link">2 类型转换</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_3-this" class="sidebar-link">3 This</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_4-和-有什么区别" class="sidebar-link">4 == 和 === 有什么区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_5-闭包" class="sidebar-link">5 闭包</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_6-深浅拷贝" class="sidebar-link">6 深浅拷贝</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_7-原型" class="sidebar-link">7 原型</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_8-var、let-及-const-区别" class="sidebar-link">8 var、let 及 const 区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_9-原型继承和-class-继承" class="sidebar-link">9 原型继承和 Class 继承</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_10-模块化" class="sidebar-link">10 模块化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_11-实现一个简洁版的promise" class="sidebar-link">11 实现一个简洁版的promise</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_12-event-loop" class="sidebar-link">12 Event Loop</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_12-1-进程与线程" class="sidebar-link">12.1 进程与线程</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_12-2-执行栈" class="sidebar-link">12.2 执行栈</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_12-3-浏览器中的-event-loop" class="sidebar-link">12.3 浏览器中的 Event Loop</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_12-4-node-中的-event-loop" class="sidebar-link">12.4 Node 中的 Event loop</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_13-手写-call、apply-及-bind-函数" class="sidebar-link">13 手写 call、apply 及 bind 函数</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_14-new" class="sidebar-link">14 new</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_15-instanceof-的原理" class="sidebar-link">15 instanceof 的原理</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_16-为什么-0-1-0-2-0-3" class="sidebar-link">16 为什么 0.1 + 0.2 != 0.3</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_17-事件机制" class="sidebar-link">17 事件机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_17-1-事件触发三阶段" class="sidebar-link">17.1 事件触发三阶段</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_17-2-注册事件" class="sidebar-link">17.2 注册事件</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_17-3-事件代理" class="sidebar-link">17.3 事件代理</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_18-跨域" class="sidebar-link">18 跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_18-1-jsonp" class="sidebar-link">18.1 JSONP</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_18-2-cors" class="sidebar-link">18.2 CORS</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_18-3-document-domain" class="sidebar-link">18.3 document.domain</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_18-4-postmessage" class="sidebar-link">18.4 postMessage</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_19-存储" class="sidebar-link">19 存储</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_20-浏览器缓存机制" class="sidebar-link">20 浏览器缓存机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_20-1-缓存位置" class="sidebar-link">20.1 缓存位置</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_20-2-缓存策略" class="sidebar-link">20.2 缓存策略</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_20-3-实际场景应用缓存策略" class="sidebar-link">20.3 实际场景应用缓存策略</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_21-浏览器渲染原理" class="sidebar-link">21 浏览器渲染原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_21-1-渲染过程" class="sidebar-link">21.1 渲染过程</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_21-2-为什么操作-dom-慢" class="sidebar-link">21.2 为什么操作 DOM 慢</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_21-3-什么情况阻塞渲染" class="sidebar-link">21.3 什么情况阻塞渲染</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_21-4-重绘（repaint）和回流（reflow）" class="sidebar-link">21.4 重绘（Repaint）和回流（Reflow）</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_21-5-减少重绘和回流" class="sidebar-link">21.5 减少重绘和回流</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_22-安全防范" class="sidebar-link">22 安全防范</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_22-1-xss" class="sidebar-link">22.1 XSS</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_22-2-csrf" class="sidebar-link">22.2 CSRF</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_22-3-点击劫持" class="sidebar-link">22.3 点击劫持</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_23-从-v8-中看-js-性能优化" class="sidebar-link">23 从 V8 中看 JS 性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_23-1-测试性能工具" class="sidebar-link">23.1 测试性能工具</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_23-2-js-性能优化" class="sidebar-link">23.2 JS 性能优化</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-性能优化" class="sidebar-link">24 性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-1-图片优化" class="sidebar-link">24.1 图片优化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-2-图片加载优化" class="sidebar-link">24.2 图片加载优化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-3-dns-预解析" class="sidebar-link">24.3 DNS 预解析</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-4-节流" class="sidebar-link">24.4 节流</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-5-防抖" class="sidebar-link">24.5 防抖</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-6-预加载" class="sidebar-link">24.6 预加载</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-7-预渲染" class="sidebar-link">24.7 预渲染</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-8-懒执行" class="sidebar-link">24.8 懒执行</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-9-懒加载" class="sidebar-link">24.9 懒加载</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_24-10-cdn" class="sidebar-link">24.10 CDN</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_25-webpack-性能优化" class="sidebar-link">25 Webpack 性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_25-1-减少-webpack-打包时间" class="sidebar-link">25.1 减少 Webpack 打包时间</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_25-2-减少-webpack-打包后的文件体积" class="sidebar-link">25.2 减少 Webpack 打包后的文件体积</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_26-实现小型打包工具" class="sidebar-link">26 实现小型打包工具</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_27-mvvm-虚拟dom-前端路由" class="sidebar-link">27 MVVM/虚拟DOM/前端路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_27-1-mvvm" class="sidebar-link">27.1 MVVM</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_27-2-virtual-dom" class="sidebar-link">27.2 Virtual DOM</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_27-3-路由原理" class="sidebar-link">27.3 路由原理</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_27-4-vue-和-react-之间的区别" class="sidebar-link">27.4 Vue 和 React 之间的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-vue常考知识点" class="sidebar-link">28 Vue常考知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-1-生命周期钩子函数" class="sidebar-link">28.1 生命周期钩子函数</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-2-组件通信" class="sidebar-link">28.2 组件通信</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-3-extend-能做什么" class="sidebar-link">28.3 extend 能做什么</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-4-mixin-和-mixins-区别" class="sidebar-link">28.4 mixin 和 mixins 区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-5-computed-和-watch-区别" class="sidebar-link">28.5 computed 和 watch 区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-6-keep-alive-组件有什么作用" class="sidebar-link">28.6 keep-alive 组件有什么作用</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-7-v-show-与-v-if-区别" class="sidebar-link">28.7 v-show 与 v-if 区别</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-8-组件中-data-什么时候可以使用对象" class="sidebar-link">28.8 组件中 data 什么时候可以使用对象</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_28-9-响应式原理" class="sidebar-link">28.9 响应式原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_29-react常考知识点" class="sidebar-link">29 React常考知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_29-1-生命周期" class="sidebar-link">29.1 生命周期</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_29-2-setstate" class="sidebar-link">29.2 setState</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_29-3-性能优化" class="sidebar-link">29.3 性能优化</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_29-4-通信" class="sidebar-link">29.4 通信</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_30-监控" class="sidebar-link">30 监控</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_31-tcp-udp" class="sidebar-link">31 TCP/UDP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_31-1-udp" class="sidebar-link">31.1 UDP</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_31-2-tcp" class="sidebar-link">31.2 TCP</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_32-http-tls" class="sidebar-link">32 HTTP/TLS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_32-1-http-请求中的内容" class="sidebar-link">32.1 HTTP 请求中的内容</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_32-2-tls" class="sidebar-link">32.2 TLS</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_33-http2-0" class="sidebar-link">33 HTTP2.0</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_33-1-http-2" class="sidebar-link">33.1 HTTP/2</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_33-2-二进制传输" class="sidebar-link">33.2 二进制传输</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_33-3-多路复用" class="sidebar-link">33.3 多路复用</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_33-4-header-压缩" class="sidebar-link">33.4 Header 压缩</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_33-5-服务端-push" class="sidebar-link">33.5 服务端 Push</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_33-6-http-3" class="sidebar-link">33.6  HTTP/3</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_34-设计模式" class="sidebar-link">34 设计模式</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_35-常见数据结构" class="sidebar-link">35 常见数据结构</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_37-常考算法题解析" class="sidebar-link">37 常考算法题解析</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/excellent/#_38-css常考面试题解析" class="sidebar-link">38 css常考面试题解析</a></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>简版</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>综合</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="第五部分：高频考点"><a href="#第五部分：高频考点" aria-hidden="true" class="header-anchor">#</a> 第五部分：高频考点</h1><blockquote><p><a href="https://upload-images.jianshu.io/upload_images/1480597-1f247397539045cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener noreferrer">如果您觉得有帮助，可以打赏我</a><img src="!%5B%5D(https://upload-images.jianshu.io/upload_images/1480597-1f247397539045cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)" alt></p></blockquote><blockquote><p><a href="https://upload-images.jianshu.io/upload_images/1480597-933c7247ddac5ed4.png" target="_blank" rel="noopener noreferrer">关注微信公众号获取更多面试题：@静观流叶</a><img src="!%5B%5D(https://upload-images.jianshu.io/upload_images/1480597-933c7247ddac5ed4.png)" alt></p></blockquote><blockquote><p>来自掘金小册笔记</p></blockquote><h2 id="_1-typeof类型判断"><a href="#_1-typeof类型判断" aria-hidden="true" class="header-anchor">#</a> 1 typeof类型判断</h2><blockquote><p><code>typeof</code> 是否能正确判断类型？<code>instanceof</code> 能正确判断对象的原理是什么</p></blockquote><ul><li><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型</li></ul><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment">// 'number'</span>
<span class="token keyword">typeof</span> <span class="token string">'1'</span> <span class="token comment">// 'string'</span>
<span class="token keyword">typeof</span> undefined <span class="token comment">// 'undefined'</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment">// 'boolean'</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'symbol'</span>
</code></pre><blockquote><p><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型</p></blockquote><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 'object'</span>
<span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log <span class="token comment">// 'function'</span>
</code></pre><blockquote><p>如果我们想判断一个对象的正确类型，这时候可以考虑使用 <code>instanceof</code>，因为内部机制是通过原型链来判断的</p></blockquote><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
p1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span> <span class="token comment">// true</span>

<span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'hello world'</span>
str <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// false</span>

<span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>
str1 <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// true</span>
</code></pre><blockquote><p>对于原始类型来说，你想直接通过 <code>instanceof</code>来判断类型是不行的</p></blockquote><h2 id="_2-类型转换"><a href="#_2-类型转换" aria-hidden="true" class="header-anchor">#</a> 2 类型转换</h2><blockquote><p>首先我们要知道，在 <code>JS</code> 中类型转换只有三种情况，分别是：</p></blockquote><ul><li>转换为布尔值</li><li>转换为数字</li><li>转换为字符串</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-c1ede6d7eb711a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>转Boolean</strong></p><blockquote><p>在条件判断时，除了 <code>undefined</code>，<code>null</code>， <code>false</code>， <code>NaN</code>， <code>''</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象</p></blockquote><p><strong>对象转原始类型</strong></p><blockquote><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下</p></blockquote><ul><li>如果已经是原始类型了，那就不需要转换了</li><li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li><li>调用 <code>x.toString()</code>，如果转换为基础类型，就返回转换的值</li><li>如果都没有返回原始类型，就会报错</li></ul><blockquote><p>当然你也可以重写 <code>Symbol.toPrimitive</code>，该方法在转原始类型时调用优先级最高。</p></blockquote><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'1'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token number">1</span> <span class="token operator">+</span> a <span class="token comment">// =&gt; 3</span>
</code></pre><p><strong>四则运算符</strong></p><blockquote><p>它有以下几个特点：</p></blockquote><ul><li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li><li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li></ul><pre class="language-js"><code><span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'1'</span> <span class="token comment">// '11'</span>
<span class="token boolean">true</span> <span class="token operator">+</span> <span class="token boolean">true</span> <span class="token comment">// 2</span>
<span class="token number">4</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">// &quot;41,2,3&quot;</span>
</code></pre><ul><li>对于第一行代码来说，触发特点一，所以将数字 <code>1</code> 转换为字符串，得到结果 <code>'11'</code></li><li>对于第二行代码来说，触发特点二，所以将 <code>true</code> 转为数字 <code>1</code></li><li>对于第三行代码来说，触发特点二，所以将数组通过 <code>toString</code>转为字符串 <code>1,2,3</code>，得到结果 <code>41,2,3</code></li></ul><blockquote><p>另外对于加法还需要注意这个表达式 <code>'a' + + 'b'</code></p></blockquote><pre class="language-text"><code>'a' + + 'b' // -&gt; &quot;aNaN&quot;
</code></pre><ul><li>因为 <code>+ 'b'</code> 等于 <code>NaN</code>，所以结果为 <code>&quot;aNaN&quot;</code>，你可能也会在一些代码中看到过 <code>+ '1'</code>的形式来快速获取 <code>number</code> 类型。</li><li>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</li></ul><pre class="language-js"><code><span class="token number">4</span> <span class="token operator">*</span> <span class="token string">'3'</span> <span class="token comment">// 12</span>
<span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 0</span>
<span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">// NaN</span>
</code></pre><p><strong>比较运算符</strong></p><ul><li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li><li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li></ul><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'1'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
a <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// true</span>
</code></pre><blockquote><p>在以上代码中，因为 <code>a</code> 是对象，所以会通过 <code>valueOf</code> 转换为原始类型再比较值。</p></blockquote><h2 id="_3-this"><a href="#_3-this" aria-hidden="true" class="header-anchor">#</a> 3 This</h2><blockquote><p>我们先来看几个函数调用的场景</p></blockquote><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><ul><li>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是<code>window</code></li><li>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</li><li>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>c</code> 上面，不会被任何方式改变 <code>this</code></li></ul><blockquote><p>说完了以上几种情况，其实很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p></blockquote><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><ul><li>首先箭头函数其实是没有 <code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code>这类函数是无效的。</li><li>最后种情况也就是 <code>bind</code> 这些改变上下文的 <code>API</code> 了，对于这些函数来说，<code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</li><li>那么说到 <code>bind</code>，不知道大家是否考虑过，如果对一个函数进行多次 <code>bind</code>，那么上下文会是什么呢？</li></ul><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; ?</span>
</code></pre><blockquote><p>如果你认为输出结果是 <code>a</code>，那么你就错了，其实我们可以把上述代码转换成另一种形式</p></blockquote><pre class="language-js"><code><span class="token comment">// fn.bind().bind(a) 等于</span>
<span class="token keyword">let</span> <span class="token function-variable function">fn2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><blockquote><p>可以从上述代码中发现，不管我们给函数 <code>bind</code> 几次，<code>fn</code> 中的 <code>this</code> 永远由第一次 <code>bind</code> 决定，所以结果永远是 <code>window</code></p></blockquote><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'poetries'</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; 'poetries'</span>
</code></pre><blockquote><p>以上就是 <code>this</code> 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 <code>this</code> 最终指向哪里。</p></blockquote><blockquote><p>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ce6e82dfdc1b3415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="_4-和-有什么区别"><a href="#_4-和-有什么区别" aria-hidden="true" class="header-anchor">#</a> 4 == 和 === 有什么区别</h2><blockquote><p>对于 <code>==</code> 来说，如果对比双方的类型不一样的话，就会进行类型转换</p></blockquote><p><strong>假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程</strong></p><ol><li>首先会判断两者类型是否相同。相同的话就是比大小了</li><li>类型不相同的话，那么就会进行类型转换</li><li>会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></li><li>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></li></ol><pre class="language-text"><code>1 == '1'
      ↓
1 ==  1
</code></pre><ol start="5"><li>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</li></ol><pre class="language-text"><code>'1' == true
        ↓
'1' ==  1
        ↓
 1  ==  1
</code></pre><ol start="6"><li>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</li></ol><pre class="language-text"><code>'1' == { name: 'yck' }
        ↓
'1' == '[object Object]'
</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1480597-88daf8ffd440c0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>对于 <code>===</code> 来说就简单多了，就是判断两者类型和值是否相同</p></blockquote><h2 id="_5-闭包"><a href="#_5-闭包" aria-hidden="true" class="header-anchor">#</a> 5 闭包</h2><blockquote><p>闭包的定义其实很简单：函数 <code>A</code> 内部有一个函数 <code>B</code>，函数 <code>B</code> 可以访问到函数 <code>A</code> 中的变量，那么函数 <code>B</code> 就是闭包</p></blockquote><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>
  window<span class="token punctuation">.</span><span class="token function-variable function">B</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre><p><strong>闭包存在的意义就是让我们可以间接访问函数内部的变量</strong></p><blockquote><p>经典面试题，循环中使用闭包解决 <code>var</code> 定义函数的问题</p></blockquote><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre><blockquote><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code>就是 <code>6</code> 了，所以会输出一堆 <code>6</code></p></blockquote><p><strong>解决办法有三种</strong></p><ol><li>第一种是使用闭包的方式</li></ol><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>在上述代码中，我们首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的</p></blockquote><ol start="2"><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入</li></ol><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span>
    <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span>
    i
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><ol start="3"><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ol><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="_6-深浅拷贝"><a href="#_6-深浅拷贝" aria-hidden="true" class="header-anchor">#</a> 6 深浅拷贝</h2><p><strong>浅拷贝</strong></p><blockquote><p>首先可以通过 <code>Object.assign</code> 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，<code>Object.assign</code> 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝</p></blockquote><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre><blockquote><p>另外我们还可以通过展开运算符 <code>...</code> 来实现浅拷贝</p></blockquote><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>a <span class="token punctuation">}</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre><blockquote><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了</p></blockquote><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  jobs<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    first<span class="token punctuation">:</span> <span class="token string">'FE'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>a <span class="token punctuation">}</span>
a<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token string">'native'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token comment">// native</span>
</code></pre><blockquote><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。</p></blockquote><p><strong>深拷贝</strong></p><blockquote><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。</p></blockquote><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  jobs<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    first<span class="token punctuation">:</span> <span class="token string">'FE'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
a<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token string">'native'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token comment">// FE</span>
</code></pre><p><strong>但是该方法也是有局限性的</strong>：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    d<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>c <span class="token operator">=</span> obj<span class="token punctuation">.</span>b
obj<span class="token punctuation">.</span>e <span class="token operator">=</span> obj<span class="token punctuation">.</span>a
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> obj<span class="token punctuation">.</span>c
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>d <span class="token operator">=</span> obj<span class="token punctuation">.</span>b
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>e <span class="token operator">=</span> obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c
<span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span>

</code></pre><blockquote><p>更多详情 https://www.jianshu.com/p/2d8a26b3958f</p></blockquote><h2 id="_7-原型"><a href="#_7-原型" aria-hidden="true" class="header-anchor">#</a> 7 原型</h2><blockquote><p>原型链就是多个对象通过 <code>__proto__</code> 的方式连接了起来。为什么 <code>obj</code> 可以访问到 <code>valueOf</code> 函数，就是因为 <code>obj</code> 通过原型链找到了 <code>valueOf</code> 函数</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671d387e4189ec8" alt></p><ul><li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code>找到它</li><li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li><li>函数的 <code>prototype</code> 是一个对象</li><li>对象的<code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li></ul><h2 id="_8-var、let-及-const-区别"><a href="#_8-var、let-及-const-区别" aria-hidden="true" class="header-anchor">#</a> 8 var、let 及 const 区别</h2><blockquote><p>涉及面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？</p></blockquote><ul><li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li><li><code>var</code> 存在提升，我们能在声明之前使用。<code>let</code>、<code>const</code> 因为暂时性死区的原因，不能在声明前使用</li><li><code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code>上，其他两者不会</li><li><code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值</li></ul><h2 id="_9-原型继承和-class-继承"><a href="#_9-原型继承和-class-继承" aria-hidden="true" class="header-anchor">#</a> 9 原型继承和 Class 继承</h2><blockquote><p>涉及面试题：原型如何实现继承？<code>Class</code> 如何实现继承？<code>Class</code> 本质是什么？</p></blockquote><p>首先先来讲下 <code>class</code>，其实在 <code>JS</code>中并不存在类，<code>class</code> 只是语法糖，本质还是函数</p><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Person <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token comment">// true</span>
</code></pre><p><strong>组合继承</strong></p><blockquote><p>组合继承是最常用的继承方式</p></blockquote><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

child<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span> <span class="token comment">// true</span>
</code></pre><ul><li>以上继承的方式核心是在子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后改变子类的原型为 <code>new Parent()</code> 来继承父类的函数。</li><li>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672aeb24a2e2cae" alt></p><p><strong>寄生组合继承</strong></p><blockquote><p>这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了</p></blockquote><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> Child<span class="token punctuation">,</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

child<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span> <span class="token comment">// true</span>
</code></pre><blockquote><p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672afb8dfa21361" alt></p><p><strong>Class 继承</strong></p><blockquote><p>以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单</p></blockquote><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
  <span class="token punctuation">}</span>
  <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
child<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span> <span class="token comment">// true</span>
</code></pre><blockquote><p><code>class</code> 实现继承的核心在于使用 <code>extends</code> 表明继承自哪个父类，并且在子类构造函数中必须调用 <code>super</code>，因为这段代码可以看成 <code>Parent.call(this, value)</code>。</p></blockquote><h2 id="_10-模块化"><a href="#_10-模块化" aria-hidden="true" class="header-anchor">#</a> 10 模块化</h2><blockquote><p>涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</p></blockquote><p>使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处</p><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li></ul><p><strong>立即执行函数</strong></p><blockquote><p>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题</p></blockquote><pre class="language-text"><code>(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
</code></pre><p><strong>AMD 和 CMD</strong></p><blockquote><p>鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。</p></blockquote><pre class="language-js"><code><span class="token comment">// AMD</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./a'</span><span class="token punctuation">,</span> <span class="token string">'./b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 加载模块完毕可以使用</span>
  a<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  b<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// CMD</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 加载模块</span>
  <span class="token comment">// 可以把 require 写在函数体的任意地方实现延迟加载</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span>
  a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p><strong>CommonJS</strong></p><blockquote><p><code>CommonJS</code> 最早是 <code>Node</code> 在使用，目前也仍然广泛使用，比如在 <code>Webpack</code> 中你就能见到它，当然目前在 <code>Node</code> 中的模块管理已经和 <code>CommonJS</code>有一些区别了</p></blockquote><pre class="language-js"><code><span class="token comment">// a.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token comment">// or</span>
exports<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment">// b.js</span>
<span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>a <span class="token comment">// -&gt; log 1</span>
</code></pre><pre class="language-js"><code>ar module <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>a
<span class="token comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span>
<span class="token comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token comment">// module 基本实现</span>
<span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token punctuation">{</span>
  id<span class="token punctuation">:</span> <span class="token string">'xxxx'</span><span class="token punctuation">,</span> <span class="token comment">// 我总得知道怎么去找到他吧</span>
  exports<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// exports 就是个空对象</span>
<span class="token punctuation">}</span>
<span class="token comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span>
<span class="token keyword">var</span> exports <span class="token operator">=</span> module<span class="token punctuation">.</span>exports
<span class="token keyword">var</span> <span class="token function-variable function">load</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 导出的东西</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> a
    <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 然后当我 require 的时候去找到独特的</span>
<span class="token comment">// id，然后将要使用的东西用立即执行函数包装下，over</span>
</code></pre><blockquote><p>另外虽然 <code>exports</code> 和 <code>module.exports</code> 用法相似，但是不能对 <code>exports</code> 直接赋值。因为 <code>var exports = module.exports</code> 这句代码表明了 <code>exports</code> 和 <code>module.exports</code>享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 <code>exports</code> 赋值就会导致两者不再指向同一个内存地址，修改并不会对 <code>module.exports</code> 起效</p></blockquote><p><strong>ES Module</strong></p><blockquote><p><code>ES Module</code> 是原生实现的模块化方案，与 <code>CommonJS</code> 有以下几个区别</p></blockquote><ol><li><code>CommonJS</code> 支持动态导入，也就是 <code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案</li><li><code>CommonJS</code> 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li><code>CommonJS</code> 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 <code>ES Module</code> 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li><code>ES Module</code> 会编译成 <code>require/exports</code>来执行的</li></ol><pre class="language-js"><code><span class="token comment">// 引入模块 API</span>
<span class="token keyword">import</span> <span class="token constant">XXX</span> <span class="token keyword">from</span> <span class="token string">'./a.js'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">XXX</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./a.js'</span>
<span class="token comment">// 导出模块 API</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><h2 id="_11-实现一个简洁版的promise"><a href="#_11-实现一个简洁版的promise" aria-hidden="true" class="header-anchor">#</a> 11 实现一个简洁版的promise</h2><pre class="language-js"><code><span class="token comment">// 三个常量用于表示状态</span>
<span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>
<span class="token keyword">const</span> <span class="token constant">RESOLVED</span> <span class="token operator">=</span> <span class="token string">'resolved'</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span>

<span class="token keyword">function</span> <span class="token function">MyPromise</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">PENDING</span>

    <span class="token comment">// value 变量用于保存 resolve 或者 reject 中传入的值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span>

    <span class="token comment">// 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用</span>
    that<span class="token punctuation">.</span>resolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    that<span class="token punctuation">.</span>rejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>


    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 首先两个函数都得判断当前状态是否为等待中</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            that<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">RESOLVED</span>
            that<span class="token punctuation">.</span>value <span class="token operator">=</span> value

            <span class="token comment">// 遍历回调数组并执行</span>
            that<span class="token punctuation">.</span>resolvedCallbacks<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>cb<span class="token operator">=&gt;</span><span class="token function">cb</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            that<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">REJECTED</span>
            that<span class="token punctuation">.</span>value <span class="token operator">=</span> value
            that<span class="token punctuation">.</span>rejectedCallbacks<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>cb<span class="token operator">=&gt;</span><span class="token function">cb</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token function">cach</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 最后我们来实现较为复杂的 then 函数</span>
MyPromise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> that <span class="token operator">=</span> <span class="token keyword">this</span>

  <span class="token comment">// 判断两个参数是否为函数类型，因为这两个参数是可选参数</span>
  onFulfilled <span class="token operator">=</span> <span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onFulfilled <span class="token punctuation">:</span> v<span class="token operator">=&gt;</span>v
  onRejected <span class="token operator">=</span> <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onRejected <span class="token punctuation">:</span> e<span class="token operator">=&gt;</span><span class="token keyword">throw</span> e

  <span class="token comment">// 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>resolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>rejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">RESOLVED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">onFulfilled</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">onRejected</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><h2 id="_12-event-loop"><a href="#_12-event-loop" aria-hidden="true" class="header-anchor">#</a> 12 Event Loop</h2><h3 id="_12-1-进程与线程"><a href="#_12-1-进程与线程" aria-hidden="true" class="header-anchor">#</a> 12.1 进程与线程</h3><blockquote><p>涉及面试题：进程与线程区别？<code>JS</code> 单线程带来的好处？</p></blockquote><ul><li><code>JS</code> 是单线程执行的，但是你是否疑惑过什么是线程？</li><li>讲到线程，那么肯定也得说一下进程。本质上来说，两个名词都是 <code>CPU</code> 工作时间片的一个描述。</li><li>进程描述了 <code>CPU</code> 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间</li></ul><blockquote><p>把这些概念拿到浏览器中来说，当你打开一个 <code>Tab</code> 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、<code>JS</code> 引擎线程、<code>HTTP</code> 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁</p></blockquote><ul><li>上文说到了 <code>JS</code> 引擎线程和渲染线程，大家应该都知道，在 <code>JS</code> 运行的时候可能会阻止 <code>UI</code> 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 <code>DOM</code>，如果在 <code>JS</code> 执行的时候 <code>UI</code> 线程还在工作，就可能导致不能安全的渲染 <code>UI</code>。这其实也是一个单线程的好处，得益于 <code>JS</code> 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处</li></ul><h3 id="_12-2-执行栈"><a href="#_12-2-执行栈" aria-hidden="true" class="header-anchor">#</a> 12.2 执行栈</h3><blockquote><p>涉及面试题：什么是执行栈？</p></blockquote><p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670d2d20ead32ec" alt></p><blockquote><p>当开始执行 <code>JS</code> 代码时，首先会执行一个 <code>main</code> 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了</p></blockquote><p>在开发中，大家也可以在报错中找到执行栈的痕迹</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670c0e21540090c" alt></p><blockquote><p>大家可以在上图清晰的看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的</p></blockquote><p>当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670c128acce975f" alt></p><h3 id="_12-3-浏览器中的-event-loop"><a href="#_12-3-浏览器中的-event-loop" aria-hidden="true" class="header-anchor">#</a> 12.3 浏览器中的 Event Loop</h3><blockquote><p>涉及面试题：异步代码执行顺序？解释一下什么是 <code>Event Loop</code> ？</p></blockquote><blockquote><p>众所周知 <code>JS</code> 是门非阻塞单线程语言，因为在最初 <code>JS</code> 就是为了和浏览器交互而诞生的。如果 <code>JS</code> 是门多线程的语言话，我们在多个线程中处理 <code>DOM</code> 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p></blockquote><ul><li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code><code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/16740fa4cd9c6937" alt></p><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><blockquote><p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 <code>jobs</code>，<code>macrotask</code> 称为 <code>task</code></p></blockquote><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span>
</code></pre><blockquote><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p></blockquote><p><strong>微任务</strong></p><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li></ul><p><strong>宏任务</strong></p><ul><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code></li><li><code>UI rendering</code></li></ul><blockquote><p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><h3 id="_12-4-node-中的-event-loop"><a href="#_12-4-node-中的-event-loop" aria-hidden="true" class="header-anchor">#</a> 12.4 Node 中的 Event loop</h3><ul><li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li><li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li></ul><pre class="language-text"><code>┌───────────────────────┐
┌─&gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │&lt;──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
</code></pre><p><strong>timer</strong></p><ul><li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li><li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li></ul><p><strong>I/O</strong></p><ul><li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li></ul><p><strong>poll</strong></p><ul><li><p><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情</p><ul><li>执行到点的定时器</li><li>执行 <code>poll</code> 队列中的事件</li></ul></li><li><p>并且当 <code>poll</code> 中没有定时器的情况下，会发现以下两件事情</p><ul><li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果 <code>poll</code> 队列为空，会有两件事发生</li><li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li><li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li><li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li></ul></li></ul><p><strong>check</strong></p><ul><li><code>check</code> 阶段执行 <code>setImmediate</code></li></ul><p><strong>close callbacks</strong></p><ul><li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li><li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li></ul><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 这里可能会输出 setTimeout，setImmediate</span>
<span class="token comment">// 可能也会相反的输出，这取决于性能</span>
<span class="token comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span>
<span class="token comment">// 否则会执行 setTimeout</span>
</code></pre><blockquote><p>上面介绍的都是 <code>macrotask</code> 的执行情况，<code>microtask</code> 会在以上每个阶段完成后立即执行</p></blockquote><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span>

    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span>

    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment">// 以上代码在浏览器和 node 中打印情况是不同的</span>
<span class="token comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span>
<span class="token comment">// node 中可能打印 timer1, timer2, promise1, promise2</span>
<span class="token comment">// 也可能打印 timer1, promise1, timer2, promise2</span>
</code></pre><blockquote><p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p></blockquote><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;timer1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;nextTick&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// nextTick, timer1, promise1</span>
</code></pre><blockquote><p>对于 <code>microtask</code> 来说，它会在以上每个阶段完成前清空 <code>microtask</code> 队列，下图中的 <code>Tick</code> 就代表了 <code>microtask</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/14/16710fb80dd42d27" alt></p><h2 id="_13-手写-call、apply-及-bind-函数"><a href="#_13-手写-call、apply-及-bind-函数" aria-hidden="true" class="header-anchor">#</a> 13 手写 call、apply 及 bind 函数</h2><blockquote><p>首先从以下几点来考虑如何实现这几个函数</p></blockquote><ul><li>不传入第一个参数，那么上下文默认为 <code>window</code></li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数，并能接受参数</li></ul><p><strong>实现 call</strong></p><ul><li>首先 <code>context</code>为可选参数，如果不传的话默认上下文为 <code>window</code></li><li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数</li><li>因为 <code>call</code> 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</li><li>然后调用函数并将对象上的函数删除</li></ul><pre class="language-js"><code>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre><p><strong>apply实现</strong></p><blockquote><p><code>apply</code> 的实现也类似，区别在于对参数的处理</p></blockquote><pre class="language-js"><code>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result
  <span class="token comment">// 处理参数和 call 有区别</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre><p><strong>bind 的实现</strong></p><blockquote><p><code>bind</code> 的实现对比其他两个函数略微地复杂了一点，因为 <code>bind</code> 需要返回一个函数，需要判断一些边界问题，以下是 <code>bind</code> 的实现</p></blockquote><ul><li><code>bind</code> 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 <code>new</code> 的方式，我们先来说直接调用的方式</li><li>对于直接调用来说，这里选择了 <code>apply</code> 的方式实现，但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 <code>args.concat(...arguments)</code></li><li>最后来说通过 <code>new</code> 的方式，在之前的章节中我们学习过如何判断 <code>this</code>，对于 <code>new</code> 的情况来说，不会被任何方式改变 <code>this</code>，所以对于这种情况我们需要忽略传入的 <code>this</code></li></ul><pre class="language-js"><code>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token comment">// 返回一个函数</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">_this</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> _this<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="_14-new"><a href="#_14-new" aria-hidden="true" class="header-anchor">#</a> 14 new</h2><blockquote><p>涉及面试题：<code>new</code> 的原理是什么？通过 <code>new</code>的方式创建对象和通过字面量创建有什么区别？</p></blockquote><p><strong>在调用 new 的过程中会发生四件事情</strong></p><ul><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 <code>this</code></li><li>返回新对象</li></ul><blockquote><p>根据以上几个过程，我们也可以试着来自己实现一个 new</p></blockquote><ul><li>创建一个空对象</li><li>获取构造函数</li><li>设置空对象的原型</li><li>绑定 <code>this</code> 并执行构造函数</li><li>确保返回值为对象</li></ul><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">let</span> Con <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Con<span class="token punctuation">.</span>prototype
  <span class="token keyword">let</span> result <span class="token operator">=</span> Con<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
  <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> result <span class="token punctuation">:</span> obj
<span class="token punctuation">}</span>
</code></pre><ul><li>对于对象来说，其实都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code>。</li><li>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题</li></ul><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// function 就是个语法糖</span>
<span class="token comment">// 内部等同于 new Function()</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token comment">// 这个字面量内部也是使用了 new Object()</span>
</code></pre><h2 id="_15-instanceof-的原理"><a href="#_15-instanceof-的原理" aria-hidden="true" class="header-anchor">#</a> 15 instanceof 的原理</h2><blockquote><p>涉及面试题：<code>instanceof</code> 的原理是什么？</p></blockquote><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></p><p><strong>实现一下 instanceof</strong></p><ul><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ul><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> prototype <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype
  left <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> left <span class="token operator">===</span> undefined<span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prototype <span class="token operator">===</span> left<span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    left <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="_16-为什么-0-1-0-2-0-3"><a href="#_16-为什么-0-1-0-2-0-3" aria-hidden="true" class="header-anchor">#</a> 16 为什么 0.1 + 0.2 != 0.3</h2><blockquote><p>涉及面试题：为什么 <code>0.1 + 0.2 != 0.3</code>？如何解决这个问题？</p></blockquote><p><strong>原因</strong>，因为 <code>JS</code> 采用 <code>IEEE 754</code>双精度版本（<code>64</code>位），并且只要采用 <code>IEEE 754</code>的语言都有该问题</p><blockquote><p>我们都知道计算机是通过二进制来存储东西的，那么 <code>0.1</code> 在二进制中会表示为</p></blockquote><pre class="language-js"><code><span class="token comment">// (0011) 表示循环</span>
<span class="token number">0.1</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1.10011</span><span class="token punctuation">(</span><span class="token number">0011</span><span class="token punctuation">)</span>
</code></pre><blockquote><p>我们可以发现，<code>0.1</code> 在二进制中是无限循环的一些数字，其实不只是 <code>0.1</code>，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 <code>JS</code>采用的浮点数标准却会裁剪掉我们的数字。</p></blockquote><p><strong>IEEE 754 双精度版本（64位）将 64 位分为了三段</strong></p><ul><li>第一位用来表示符号</li><li>接下去的 <code>11</code> 位用来表示指数</li><li>其他的位数用来表示有效位，也就是用二进制表示 <code>0.1</code> 中的 <code>10011(0011)</code></li></ul><blockquote><p>那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 <code>0.1</code> 不再是 <code>0.1</code> 了，而是变成了 <code>0.100000000000000002</code></p></blockquote><pre class="language-text"><code>0.100000000000000002 === 0.1 // true
</code></pre><blockquote><p>那么同样的，<code>0.2</code> 在二进制也是无限循环的，被裁剪后也失去了精度变成了 <code>0.200000000000000002</code></p></blockquote><pre class="language-text"><code>0.200000000000000002 === 0.2 // true
</code></pre><blockquote><p>所以这两者相加不等于 <code>0.3</code> 而是 <code>0.300000000000000004</code></p></blockquote><pre class="language-text"><code>0.1 + 0.2 === 0.30000000000000004 // true
</code></pre><blockquote><p>那么可能你又会有一个疑问，既然 <code>0.1</code> 不是 <code>0.1</code>，那为什么 <code>console.log(0.1)</code> 却是正确的呢？</p></blockquote><blockquote><p>因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证</p></blockquote><pre class="language-text"><code>console.log(0.100000000000000002) // 0.1
</code></pre><p><strong>解决</strong></p><pre class="language-js"><code><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0.3</span> <span class="token comment">// true</span>
</code></pre><h2 id="_17-事件机制"><a href="#_17-事件机制" aria-hidden="true" class="header-anchor">#</a> 17 事件机制</h2><blockquote><p>涉及面试题：事件的触发过程是怎么样的？知道什么是事件代理嘛？</p></blockquote><h3 id="_17-1-事件触发三阶段"><a href="#_17-1-事件触发三阶段" aria-hidden="true" class="header-anchor">#</a> 17.1 事件触发三阶段</h3><p><strong>事件触发有三个阶段</strong>：</p><ul><li><code>window</code>往事件触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li></ul><blockquote><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 <code>body</code> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</p></blockquote><pre class="language-js"><code><span class="token comment">// 以下会先打印冒泡然后是捕获</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  event <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'冒泡'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  event <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获 '</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">true</span>
<span class="token punctuation">)</span>
</code></pre><h3 id="_17-2-注册事件"><a href="#_17-2-注册事件" aria-hidden="true" class="header-anchor">#</a> 17.2 注册事件</h3><blockquote><p>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性</p></blockquote><ul><li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li><li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li><li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li></ul><blockquote><p>一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code>来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件<code>。stopImmediatePropagation</code>同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p></blockquote><pre class="language-js"><code>node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  event <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    event<span class="token punctuation">.</span><span class="token function">stopImmediatePropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'冒泡'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span>
<span class="token comment">// 点击 node 只会执行上面的函数，该函数不会执行</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  event <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获 '</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">true</span>
<span class="token punctuation">)</span>
</code></pre><h3 id="_17-3-事件代理"><a href="#_17-3-事件代理" aria-hidden="true" class="header-anchor">#</a> 17.3 事件代理</h3><blockquote><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p></blockquote><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>ul<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
	<span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#ul'</span><span class="token punctuation">)</span>
	ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><p><strong>事件代理的方式相较于直接给目标注册事件来说，有以下优点</strong>：</p><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h2 id="_18-跨域"><a href="#_18-跨域" aria-hidden="true" class="header-anchor">#</a> 18 跨域</h2><blockquote><p>涉及面试题：什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？</p></blockquote><ul><li>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，<code>Ajax</code> 请求会失败。</li><li>那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 <code>CSRF</code> 攻击的。简单点说，<code>CSRF</code> 攻击是利用用户的登录态发起恶意请求。</li><li>也就是说，没有同源策略的情况下，<code>A</code> 网站可以被任意其他来源的 <code>Ajax</code> 访问到内容。如果你当前 <code>A</code> 网站还存在登录态，那么对方就可以通过 <code>Ajax</code> 获得你的任何信息。当然跨域并不能完全阻止 <code>CSRF</code>。</li></ul><blockquote><p>然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器拦截了响应。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 <code>Ajax</code>就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，<code>Ajax</code> 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 <code>CSRF</code>，因为请求毕竟是发出去了。</p></blockquote><p>接下来我们将来学习几种常见的方式来解决跨域的问题</p><h3 id="_18-1-jsonp"><a href="#_18-1-jsonp" aria-hidden="true" class="header-anchor">#</a> 18.1 JSONP</h3><blockquote><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p></blockquote><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
    <span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    

</code></pre><blockquote><p><code>JSONP</code> 使用简单且兼容性不错，但是只限于 <code>get</code> 请求。</p></blockquote><blockquote><p>在开发中可能会遇到多个 <code>JSONP</code> 请求的回调函数名是相同的，这时候就需要自己封装一个 <code>JSONP</code>，以下是简单实现</p></blockquote><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> jsonpCallback<span class="token punctuation">,</span> success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url
  script<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token operator">=</span> <span class="token boolean">true</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span>
  window<span class="token punctuation">[</span>jsonpCallback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    success <span class="token operator">&amp;&amp;</span> <span class="token function">success</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token string">'http://xxx'</span><span class="token punctuation">,</span> <span class="token string">'callback'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h3 id="_18-2-cors"><a href="#_18-2-cors" aria-hidden="true" class="header-anchor">#</a> 18.2 CORS</h3><ul><li><code>CORS</code> 需要浏览器和后端同时支持。<code>IE 8</code> 和 <code>9</code> 需要通过 <code>XDomainRequest</code> 来实现。</li><li>浏览器会自动进行 <code>CORS</code> 通信，实现 <code>CORS</code> 通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li><li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
虽然设置 <code>CORS</code>和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</li></ul><p><strong>简单请求</strong></p><blockquote><p>以 <code>Ajax</code> 为例，当满足以下条件时，会触发简单请求</p></blockquote><ol><li>使用下列方法之一：</li></ol><ul><li><code>GET</code></li><li><code>HEAD</code></li><li><code>POST</code></li></ul><ol start="2"><li><code>Content-Type</code> 的值仅限于下列三者之一：</li></ol><ul><li>text/plain</li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><blockquote><p>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器； <code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问</p></blockquote><p><strong>复杂请求</strong></p><blockquote><p>对于复杂请求来说，首先会发起一个预检请求，该请求是 <code>option</code> 方法的，通过该请求来知道服务端是否允许跨域请求。</p></blockquote><p>对于预检请求来说，如果你使用过 <code>Node</code> 来设置 <code>CORS</code> 的话，可能会遇到过这么一个坑。</p><p>以下以 <code>express</code>框架举例</p><pre class="language-js"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT, GET, POST, DELETE, OPTIONS'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span>
    <span class="token string">'Access-Control-Allow-Headers'</span><span class="token punctuation">,</span>
    <span class="token string">'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials'</span>
  <span class="token punctuation">)</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><ul><li>该请求会验证你的 <code>Authorization</code> 字段，没有的话就会报错。</li><li>当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 <code>next</code> 方法，因为预检请求并不包含 <code>Authorization</code> 字段，所以服务端会报错。</li></ul><blockquote><p>想解决这个问题很简单，只需要在回调中过滤 <code>option</code> 方法即可</p></blockquote><pre class="language-js"><code>res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">204</span>
res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span>
res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><h3 id="_18-3-document-domain"><a href="#_18-3-document-domain" aria-hidden="true" class="header-anchor">#</a> 18.3 document.domain</h3><ul><li>该方式只能用于主域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li><li>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示主域名都相同就可以实现跨域</li></ul><h3 id="_18-4-postmessage"><a href="#_18-4-postmessage" aria-hidden="true" class="header-anchor">#</a> 18.4 postMessage</h3><blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p></blockquote><pre class="language-js"><code><span class="token comment">// 发送消息端</span>
window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span>
<span class="token comment">// 接收消息端</span>
<span class="token keyword">var</span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> event <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> origin <span class="token operator">=</span> event<span class="token punctuation">.</span>origin <span class="token operator">||</span> event<span class="token punctuation">.</span>originalEvent<span class="token punctuation">.</span>origin
  <span class="token keyword">if</span> <span class="token punctuation">(</span>origin <span class="token operator">===</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'验证通过'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h2 id="_19-存储"><a href="#_19-存储" aria-hidden="true" class="header-anchor">#</a> 19 存储</h2><blockquote><p>涉及面试题：有几种方式可以实现存储功能，分别有什么优缺点？什么是 <code>Service Worker</code>？</p></blockquote><p><strong>cookie，localStorage，sessionStorage，indexDB</strong></p><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sessionStorage</th><th>indexDB</th></tr></thead><tbody><tr><td>数据生命周期</td><td>一般由服务器生成，可以设置过期时间</td><td>除非被清理，否则一直存在</td><td>页面关闭就清理</td><td>除非被清理，否则一直存在</td></tr><tr><td>数据存储大小</td><td><code>4K</code></td><td><code>5M</code></td><td><code>5M</code></td><td>无限</td></tr><tr><td>与服务端通信</td><td>每次都会携带在 <code>header</code> 中，对于请求性能影响</td><td>不参与</td><td>不参与</td><td>不参与</td></tr></tbody></table><blockquote><p>从上表可以看到，<code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code>存储</p></blockquote><p><strong>对于 cookie 来说，我们还需要注意安全性。</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>value</code></td><td>如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td></tr><tr><td><code>http-only</code></td><td>不能通过 <code>JS</code> 访问 <code>Cookie</code>，减少 <code>XSS</code> 攻击</td></tr><tr><td><code>secure</code></td><td>只能在协议为 <code>HTTPS</code> 的请求中携带</td></tr><tr><td><code>same-site</code></td><td>规定浏览器不能在跨域请求中携带 <code>Cookie</code>，减少 <code>CSRF</code> 攻击</td></tr></tbody></table><p><strong>Service Worker</strong></p><ul><li><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 <code>Service Worker</code>的话，传输协议必须为 <code>HTTPS</code>。因为 <code>Service Worker</code> 中涉及到请求拦截，所以必须使用 <code>HTTPS</code> 协议来保障安全</li><li><code>Service Worker</code> 实现缓存功能一般分为三个步骤：首先需要先注册 <code>Service Worker</code>，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</li></ul><pre class="language-js"><code><span class="token comment">// index.js</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>navigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  navigator<span class="token punctuation">.</span>serviceWorker
    <span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'sw.js'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>registration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'service worker 注册成功'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'servcie worker 注册失败'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// sw.js</span>
<span class="token comment">// 监听 `install` 事件，回调中缓存所需文件</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'install'</span><span class="token punctuation">,</span> e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'my-cache'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./index.html'</span><span class="token punctuation">,</span> <span class="token string">'./index.js'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 拦截所有请求事件</span>
<span class="token comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'fetch'</span><span class="token punctuation">,</span> e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> response
      <span class="token punctuation">}</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fetch source'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><blockquote><p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 <code>Service Worker</code> 已经启动了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c" alt></p><blockquote><p>在 <code>Cache</code> 中也可以发现我们所需的文件已被缓存</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26" alt></p><blockquote><p>当我们重新刷新页面可以发现我们缓存的数据是从 <code>Service Worker</code> 中读取的</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20e4f8f3257" alt></p><h2 id="_20-浏览器缓存机制"><a href="#_20-浏览器缓存机制" aria-hidden="true" class="header-anchor">#</a> 20 浏览器缓存机制</h2><blockquote><p>注意：该知识点属于性能优化领域，并且整一章节都是一个面试题</p></blockquote><ul><li>缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。</li><li>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</li></ul><blockquote><p>接下来的内容中我们将通过以下几个部分来探讨浏览器缓存机制：</p></blockquote><ul><li>缓存位置</li><li>缓存策略</li><li>实际场景应用缓存策略</li></ul><h3 id="_20-1-缓存位置"><a href="#_20-1-缓存位置" aria-hidden="true" class="header-anchor">#</a> 20.1 缓存位置</h3><blockquote><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络</p></blockquote><ol><li><code>Service Worker</code></li><li><code>Memory Cache</code></li><li><code>Disk Cache</code></li><li><code>Push Cache</code></li><li>网络请求</li></ol><p><strong>1. Service Worker</strong></p><ul><li><code>service Worker</code> 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</li><li>当 <code>Service Worker</code> 没有命中缓存的时候，我们需要去调用 <code>fetch</code> 函数获取数据。也就是说，如果我们没有在 <code>Service Worker</code> 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 <code>Memory Cache</code> 中还是从网络请求中获取的数据，浏览器都会显示我们是从 <code>Service Worker</code> 中获取的内容。</li></ul><p><strong>2. Memory Cache</strong></p><ul><li><code>Memory Cache</code> 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 <code>Tab</code> 页面，内存中的缓存也就被释放了。</li><li>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/5/1677db8003dc8311" alt></p><blockquote><p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</p></blockquote><ul><li>先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 <code>JS</code>、<code>HTML</code>、<code>CSS</code>、图片等等</li><li>当然，我通过一些实践和猜测也得出了一些结论：</li><li>对于大文件来说，大概率是不存储在内存中的，反之优先当前系统内存使用率高的话，文件优先存储进硬盘</li></ul><p><strong>3. Disk Cache</strong></p><ul><li><code>Disk Cache</code> 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 <code>Memory Cache</code> 胜在容量和存储时效性上。</li><li>在所有浏览器缓存中，<code>Disk Cache</code> 覆盖面基本是最大的。它会根据 ·HTTP Herder· 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据</li></ul><p><strong>4. Push Cache</strong></p><ul><li><code>Push Cache</code> 是 <code>HTTP/2</code> 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（<code>Session</code>）中存在，一旦会话结束就被释放。</li><li><code>Push Cache</code> 在国内能够查到的资料很少，也是因为 <code>HTTP/2</code> 在国内不够普及，但是 <code>HTTP/2</code> 将会是日后的一个趋势</li></ul><blockquote><p>结论</p></blockquote><ul><li>所有的资源都能被推送，但是 <code>Edge</code> 和 <code>Safari</code> 浏览器兼容性不怎么好</li><li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li><li>一旦连接被关闭，<code>Push Cache</code> 就被释放</li><li>多个页面可以使用相同的 <code>HTTP/2</code> 连接，也就是说能使用同样的缓存</li><li><code>Push Cache</code> 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>你可以给其他域名推送资源</li></ul><p><strong>5. 网络请求</strong></p><ul><li>如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</li><li>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容</li></ul><h3 id="_20-2-缓存策略"><a href="#_20-2-缓存策略" aria-hidden="true" class="header-anchor">#</a> 20.2 缓存策略</h3><blockquote><p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 <code>HTTP Header</code> 来实现的</p></blockquote><h4 id="_20-2-1-强缓存"><a href="#_20-2-1-强缓存" aria-hidden="true" class="header-anchor">#</a> 20.2.1 强缓存</h4><blockquote><p>强缓存可以通过设置两种 <code>HTTP Header</code> 实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code>为 <code>200</code></p></blockquote><p><strong>Expires</strong></p><pre class="language-text"><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT
</code></pre><blockquote><p><code>Expires</code> 是 <code>HTTP/1</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p></blockquote><p><strong>Cache-control</strong></p><pre class="language-text"><code>Cache-control: max-age=30
</code></pre><ul><li><code>Cache-Control</code> 出现于 <code>HTTP/1.1</code>，优先级高于 <code>Expires</code> 。该属性值表示资源会在 <code>30</code> 秒后过期，需要再次请求。</li><li><code>Cache-Control</code> 可以在请求头或者响应头中设置，并且可以组合使用多种指令</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/6/1678234a1ed20487" alt></p><blockquote><p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等</p></blockquote><p><strong>一些常见指令的作用</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/5/1677ef2cd7bf1bba" alt></p><h4 id="_20-2-2-协商缓存"><a href="#_20-2-2-协商缓存" aria-hidden="true" class="header-anchor">#</a> 20.2.2 协商缓存</h4><ul><li>如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 <code>HTTP Header</code> 实现：<code>Last-Modified</code> 和 <code>ETag</code></li><li>当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 <code>304</code> 状态码，并且更新浏览器缓存有效期。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/6/16782357baddf1c6" alt></p><p><strong>Last-Modified 和 If-Modified-Since</strong></p><blockquote><p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 <code>304</code> 状态码。</p></blockquote><p>但是 <code>Last-Modified</code>存在一些弊端：</p><ul><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</li><li>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
因为以上这些弊端，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code></li></ul><p><strong>ETag 和 If-None-Match</strong></p><ul><li><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code>优先级比 <code>Last-Modified</code> 高。</li></ul><blockquote><p>以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。如果什么缓存策略都没设置，那么浏览器会怎么处理？</p></blockquote><p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 值的 <code>10%</code> 作为缓存时间。</p><h3 id="_20-3-实际场景应用缓存策略"><a href="#_20-3-实际场景应用缓存策略" aria-hidden="true" class="header-anchor">#</a> 20.3 实际场景应用缓存策略</h3><p><strong>频繁变动的资源</strong></p><blockquote><p>对于频繁变动的资源，首先需要使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p></blockquote><p><strong>代码文件</strong></p><blockquote><p>这里特指除了 <code>HTML</code> 外的代码文件，因为 <code>HTML</code> 文件一般不缓存或者缓存时间很短。</p></blockquote><p>一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 <code>Cache-Control: max-age=31536000</code>，这样只有当 <code>HTML</code> 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存</p><blockquote><p>更多缓存知识详解 http://blog.poetries.top/2019/01/02/browser-cache</p></blockquote><h2 id="_21-浏览器渲染原理"><a href="#_21-浏览器渲染原理" aria-hidden="true" class="header-anchor">#</a> 21 浏览器渲染原理</h2><blockquote><p>注意：该章节都是一个面试题。</p></blockquote><h3 id="_21-1-渲染过程"><a href="#_21-1-渲染过程" aria-hidden="true" class="header-anchor">#</a> 21.1 渲染过程</h3><p><strong>1. 浏览器接收到 HTML 文件并转换为 DOM 树</strong></p><blockquote><p>当我们打开一个网页时，浏览器都会去请求对应的 <code>HTML</code> 文件。虽然平时我们写代码时都会分为 <code>JS</code>、<code>CSS</code>、<code>HTML</code> 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 <code>0</code> 和 <code>1</code> 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754281e59587f3" alt></p><blockquote><p>当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（<code>token</code>），这一过程在词法分析中叫做标记化（<code>tokenization</code>）</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754288f37a5347" alt></p><blockquote><p>那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167540a7b5cef612" alt></p><blockquote><p>当结束标记化后，这些标记会紧接着转换为 <code>Node</code>，最后这些 <code>Node</code> 会根据不同 <code>Node</code> 之前的联系构建为一颗 <code>DOM</code> 树</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/1675416cbea98c3c" alt></p><blockquote><p>以上就是浏览器从网络中接收到 <code>HTML</code> 文件然后一系列的转换过程</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542b09875a74a" alt></p><blockquote><p>当然，在解析 <code>HTML</code> 文件的时候，浏览器还会遇到 <code>CSS</code> 和 <code>JS</code> 文件，这时候浏览器也会去下载并解析这些文件，接下来就让我们先来学习浏览器如何解析 <code>CSS</code> 文件</p></blockquote><p><strong>2. 将 CSS 文件转换为 CSSOM 树</strong></p><blockquote><p>其实转换 <code>CSS</code> 到 <code>CSSOM</code> 树的过程和上一小节的过程是极其类似的</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f" alt></p><ul><li>在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 <code>CSSOM</code> 树，然后确定具体的元素到底是什么样式。</li></ul><p>如果你有点不理解为什么会消耗资源的话，我这里举个例子</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">
  <span class="token selector">span</span> <span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">div &gt; a &gt; span</span> <span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre><blockquote><p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <code>span</code> 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <code>span</code> 标签，然后找到 <code>span</code> 标签上的 <code>a</code> 标签，最后再去找到 <code>div</code> 标签，然后给符合这种条件的 <code>span</code> 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 <code>CSS</code> 选择器，然后对于 <code>HTML</code> 来说也尽量少的添加无意义标签，保证层级扁平</p></blockquote><p><strong>3. 生成渲染树</strong></p><blockquote><p>当我们生成 <code>DOM</code> 树和 <code>CSSOM</code> 树以后，就需要将这两棵树组合为渲染树</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754488529c48bd" alt></p><ul><li>在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</li><li>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 <code>GPU</code>绘制，合成图层，显示在屏幕上。对于这一部分的内容因为过于底层，还涉及到了硬件相关的知识，这里就不再继续展开内容了。</li></ul><h3 id="_21-2-为什么操作-dom-慢"><a href="#_21-2-为什么操作-dom-慢" aria-hidden="true" class="header-anchor">#</a> 21.2 为什么操作 DOM 慢</h3><blockquote><p>想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？</p></blockquote><ul><li>因为 <code>DOM</code>是属于渲染引擎中的东西，而 <code>JS</code> 又是 <code>JS</code> 引擎中的东西。当我们通过 <code>JS</code> 操作 <code>DOM</code> 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 <code>DOM</code> 次数一多，也就等同于一直在进行线程之间的通信，并且操作 <code>DOM</code> 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</li></ul><blockquote><p>经典面试题：插入几万个 DOM，如何实现页面不卡顿？</p></blockquote><ul><li>对于这道题目来说，首先我们肯定不能一次性把几万个 <code>DOM</code> 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 <code>DOM</code>。大部分人应该可以想到通过 <code>requestAnimationFrame</code> 的方式去循环的插入 <code>DOM</code>，其实还有种方式去解决这个问题：虚拟滚动（<code>virtualized scroller</code>）。</li><li>这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/15/167b1c6887ecbba7" alt></p><blockquote><p>从上图中我们可以发现，即使列表很长，但是渲染的 <code>DOM</code> 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 <code>DOM</code>，这个技术就能顺利解决这道经典面试题</p></blockquote><h3 id="_21-3-什么情况阻塞渲染"><a href="#_21-3-什么情况阻塞渲染" aria-hidden="true" class="header-anchor">#</a> 21.3 什么情况阻塞渲染</h3><ul><li>首先渲染的前提是生成渲染树，所以 <code>HTML</code> 和 <code>CSS</code> 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。</li><li>然后当浏览器在解析到 <code>script</code> 标签时，会暂停构建 <code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <code>JS</code>文件，这也是都建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。</li><li>当然在当下，并不是说 <code>script</code> 标签必须放在底部，因为你可以给 <code>script</code> 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</li><li>当 <code>script</code> 标签加上 <code>defer</code> 属性以后，表示该 <code>JS</code> 文件会并行下载，但是会放到 <code>HTML</code> 解析完成后顺序执行，所以对于这种情况你可以把 <code>script</code>标签放在任意位置。</li><li>对于没有任何依赖的 <code>JS</code> 文件可以加上 <code>async</code> 属性，表示 <code>JS</code> 文件下载和解析不会阻塞渲染。</li></ul><h3 id="_21-4-重绘（repaint）和回流（reflow）"><a href="#_21-4-重绘（repaint）和回流（reflow）" aria-hidden="true" class="header-anchor">#</a> 21.4 重绘（Repaint）和回流（Reflow）</h3><blockquote><p>重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。</p></blockquote><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流。</li><li>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</li></ul><p><strong>以下几个动作可能会导致性能问题</strong>：</p><ul><li>改变 <code>window</code> 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><blockquote><p>并且很多人不知道的是，重绘和回流其实也和 <code>Eventloop</code> 有关。</p></blockquote><ul><li>当 <code>Eventloop</code> 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新，因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16.6ms</code> 才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> 事件，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li><li>判断是否触发了 <code>media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code>回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code>回调</li></ul><h3 id="_21-5-减少重绘和回流"><a href="#_21-5-减少重绘和回流" aria-hidden="true" class="header-anchor">#</a> 21.5 减少重绘和回流</h3><ol><li>使用 <code>transform</code> 替代 <code>top</code></li></ol><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>test<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">
  <span class="token selector">.test</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 引起回流</span>
    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token string">'100px'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

</code></pre><ol start="2"><li>使用 <code>visibility</code> 替换<code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要把节点的属性值放在一个循环里当成循环里的变量</li></ol><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>offsetTop<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><ol start="4"><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code> 选择符从右往左匹配查找，避免节点层级过多</li><li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/3/29/1626fb6f33a6f9d7" alt></p><blockquote><p>设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层</p></blockquote><ul><li><code>will-change</code></li><li><code>video</code>、<code>iframe</code> 标签</li></ul><h2 id="_22-安全防范"><a href="#_22-安全防范" aria-hidden="true" class="header-anchor">#</a> 22 安全防范</h2><h3 id="_22-1-xss"><a href="#_22-1-xss" aria-hidden="true" class="header-anchor">#</a> 22.1 XSS</h3><blockquote><p>涉及面试题：什么是 <code>XSS</code> 攻击？如何防范 <code>XSS</code> 攻击？什么是 <code>CSP</code>？</p></blockquote><ul><li><code>XSS</code> 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。</li><li><code>XSS</code> 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。</li><li>持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。</li></ul><blockquote><p>举个例子，对于评论功能来说，就得防范持久型 <code>XSS</code> 攻击，因为我可以在评论中输入以下内容</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-4d0534470dcfe615.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。</li><li>非持久型相比于前者危害就小的多了，一般通过修改 <code>URL</code> 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。</li></ul><blockquote><p>举个例子，如果页面需要从 <code>URL</code> 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</p></blockquote><pre class="language-html"><code><span class="token comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>                                                  
</code></pre><blockquote><p>但是对于这种攻击方式来说，如果用户使用 <code>Chrome</code> 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/2/1676d5e1a09c8367" alt></p><blockquote><p>对于 <code>XSS</code> 攻击来说，通常有两种方式可以用来防御。</p></blockquote><ol><li><strong>转义字符</strong></li></ol><blockquote><p>首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</p></blockquote><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">escape</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&amp;/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;amp;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&lt;/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;lt;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&gt;/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;gt;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&quot;/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;quto;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/'/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;#39;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/`/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;#96;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\//g</span><span class="token punctuation">,</span> <span class="token string">'&amp;#x2F;'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> str
<span class="token punctuation">}</span>
</code></pre><blockquote><p>通过转义可以将攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 变成</p></blockquote><pre class="language-js"><code><span class="token comment">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span>
<span class="token function">escape</span><span class="token punctuation">(</span><span class="token string">'&lt;script&gt;alert(1)&lt;/script&gt;'</span><span class="token punctuation">)</span>
</code></pre><blockquote><p>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式</p></blockquote><pre class="language-js"><code><span class="token keyword">const</span> xss <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token function">xss</span><span class="token punctuation">(</span><span class="token string">'&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;'</span><span class="token punctuation">)</span>
<span class="token comment">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>
</code></pre><blockquote><p>以上示例使用了 <code>js-xss</code> 来实现，可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code>标签</p></blockquote><ol start="2"><li><strong>CSP</strong></li></ol><blockquote><p><code>CSP</code> 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 <code>XSS</code> 攻击。</p></blockquote><p><strong>通常可以通过两种方式来开启 CSP</strong>：</p><ul><li>设置 <code>HTTP Header</code> 中的 <code>Content-Security-Policy</code></li><li>设置 <code>meta</code> 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ul><p>这里以设置 <code>HTTP Header</code> 来举例</p><p><strong>只允许加载本站资源</strong></p><pre class="language-text"><code>Content-Security-Policy: default-src ‘self’
</code></pre><p><strong>只允许加载 HTTPS 协议图片</strong></p><pre class="language-text"><code>Content-Security-Policy: img-src https://*
</code></pre><p><strong>允许加载任何来源框架</strong></p><pre class="language-text"><code>Content-Security-Policy: child-src 'none'
</code></pre><blockquote><p>当然可以设置的属性远不止这些，你可以通过查阅 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener noreferrer">文档</a> 的方式来学习，这里就不过多赘述其他的属性了。</p></blockquote><blockquote><p>对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 <code>CSP</code> 的兼容性也不错。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/2/1676d8215a3d1f5b" alt></p><h3 id="_22-2-csrf"><a href="#_22-2-csrf" aria-hidden="true" class="header-anchor">#</a> 22.2 CSRF</h3><blockquote><p>涉及面试题：什么是 <code>CSRF</code> 攻击？如何防范 <code>CSRF</code> 攻击？</p></blockquote><blockquote><p><code>CSRF</code> 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。</p></blockquote><p>举个例子，假设网站中有一个通过 <code>GET</code> 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://www.domain.com/xxx?comment=<span class="token punctuation">'</span>attack<span class="token punctuation">'</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><blockquote><p>那么你是否会想到使用 <code>POST</code> 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 <code>POST</code> 请求。</p></blockquote><p><strong>如何防御</strong></p><ul><li><code>Get</code> 请求不对数据进行修改</li><li>不让第三方网站访问到用户 <code>Cookie</code></li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者 <code>Token</code></li></ul><p><strong>SameSite</strong></p><blockquote><p>可以对 <code>Cookie</code> 设置 <code>SameSite</code> 属性。该属性表示 <code>Cookie</code> 不随着跨域请求发送，可以很大程度减少 <code>CSRF</code> 的攻击，但是该属性目前并不是所有浏览器都兼容。</p></blockquote><p><strong>验证 Referer</strong></p><blockquote><p>对于需要防范 <code>CSRF</code> 的请求，我们可以通过验证 <code>Referer</code> 来判断该请求是否为第三方网站发起的。</p></blockquote><p><strong>Token</strong></p><blockquote><p>服务器下发一个随机 <code>Token</code>，每次发起请求时将 <code>Token</code> 携带上，服务器验证 <code>Token</code> 是否有效</p></blockquote><h3 id="_22-3-点击劫持"><a href="#_22-3-点击劫持" aria-hidden="true" class="header-anchor">#</a> 22.3 点击劫持</h3><blockquote><p>涉及面试题：什么是点击劫持？如何防范点击劫持？</p></blockquote><blockquote><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-e2fd2624a105fce7.png" alt="image.png"></p><blockquote><p>对于这种攻击方式，推荐防御的方法有两种</p></blockquote><p><strong>1. X-FRAME-OPTIONS</strong></p><blockquote><p><code>X-FRAME-OPTIONS</code> 是一个 <code>HTTP</code> 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用<code>iframe</code> 嵌套的点击劫持攻击。</p></blockquote><blockquote><p>该响应头有三个值可选，分别是</p></blockquote><ul><li><code>DENY</code>，表示页面不允许通过 <code>iframe</code> 的方式展示</li><li><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过 <code>iframe</code> 的方式展示</li><li><code>ALLOW-FROM</code>，表示页面可以在指定来源的 <code>iframe</code> 中展示</li></ul><p><strong>2. JS 防御</strong></p><blockquote><p>对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。</p></blockquote><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>click-jack<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token style language-css">
    <span class="token selector">html</span> <span class="token punctuation">{</span>
      <span class="token property">display</span><span class="token punctuation">:</span> none <span class="token important">!important</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
    <span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">==</span> top<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> style <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'click-jack'</span><span class="token punctuation">)</span>
      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>style<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      top<span class="token punctuation">.</span>location <span class="token operator">=</span> self<span class="token punctuation">.</span>location
    <span class="token punctuation">}</span>
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre><blockquote><p>以上代码的作用就是当通过 <code>iframe</code> 的方式加载页面时，攻击者的网页直接不显示所有内容了</p></blockquote><h2 id="_23-从-v8-中看-js-性能优化"><a href="#_23-从-v8-中看-js-性能优化" aria-hidden="true" class="header-anchor">#</a> 23 从 V8 中看 JS 性能优化</h2><blockquote><p>注意：该知识点属于性能优化领域。</p></blockquote><h3 id="_23-1-测试性能工具"><a href="#_23-1-测试性能工具" aria-hidden="true" class="header-anchor">#</a> 23.1 测试性能工具</h3><blockquote><p><code>Chrome</code> 已经提供了一个大而全的性能测试工具 <code>Audits</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772c479b194d48" alt></p><blockquote><p>点我们点击 <code>Audits</code> 后，可以看到如下的界面</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772c52e83d97c7" alt></p><blockquote><p>在这个界面中，我们可以选择想测试的功能然后点击 <code>Run audits</code> ，工具就会自动运行帮助我们测试问题并且给出一个完整的报告</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772ca3d13a68ab" alt></p><blockquote><p>上图是给掘金首页测试性能后给出的一个报告，可以看到报告中分别为性能、体验、SEO 都给出了打分，并且每一个指标都有详细的评估</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772cae50f7eb81" alt></p><p>评估结束后，工具还提供了一些建议便于我们提高这个指标的分数</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772cbdcdaccf15" alt></p><p>我们只需要一条条根据建议去优化性能即可。</p><blockquote><p>除了 <code>Audits</code> 工具之外，还有一个 <code>Performance</code>工具也可以供我们使用。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772cf78a4fa18f" alt></p><blockquote><p>在这张图中，我们可以详细的看到每个时间段中浏览器在处理什么事情，哪个过程最消耗时间，便于我们更加详细的了解性能瓶颈</p></blockquote><h3 id="_23-2-js-性能优化"><a href="#_23-2-js-性能优化" aria-hidden="true" class="header-anchor">#</a> 23.2 JS 性能优化</h3><blockquote><p><code>JS</code> 是编译型还是解释型语言其实并不固定。首先 <code>JS</code> 需要有引擎才能运行起来，无论是浏览器还是在 <code>Node</code> 中，这是解释型语言的特性。但是在 V8 引擎下，又引入了 <code>TurboFan</code> 编译器，他会在特定的情况下进行优化，将代码编译成执行效率更高的 <code>Machine Code</code>，当然这个编译器并不是 <code>JS</code> 必须需要的，只是为了提高代码执行性能，所以总的来说 <code>JS</code> 更偏向于解释型语言。</p></blockquote><p>那么这一小节的内容主要会针对于 <code>Chrome</code> 的 <code>V8</code> 引擎来讲解。</p><blockquote><p>在这一过程中，<code>JS</code> 代码首先会解析为抽象语法树（<code>AST</code>），然后会通过解释器或者编译器转化为 <code>Bytecode</code> 或者<code>Machine Code</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/167736409eebe688" alt></p><blockquote><p>从上图中我们可以发现，<code>JS</code> 会首先被解析为 <code>AST</code>，解析的过程其实是略慢的。代码越多，解析的过程也就耗费越长，这也是我们需要压缩代码的原因之一。另外一种减少解析时间的方式是预解析，会作用于未执行的函数，这个我们下面再谈</p></blockquote><p>这里需要注意一点，对于函数来说，应该尽可能避免声明嵌套函数（类也是函数），因为这样会造成函数的重复解析</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 会被重复解析</span>
  <span class="token keyword">function</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>然后 <code>Ignition</code> 负责将 <code>AST</code> 转化为 <code>Bytecode</code>，<code>TurboFan</code> 负责编译出优化后的 <code>Machine Code</code>，并且 <code>Machine Code</code> 在执行效率上优于 <code>Bytecode</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16773b904cfb732f" alt></p><blockquote><p>那么我们就产生了一个疑问，什么情况下代码会编译为 <code>Machine Code</code>？</p></blockquote><blockquote><p><code>JS</code> 是一门动态类型的语言，并且还有一大堆的规则。简单的加法运算代码，内部就需要考虑好几种规则，比如数字相加、字符串相加、对象和字符串相加等等。这样的情况也就势必导致了内部要增加很多判断逻辑，降低运行效率。</p></blockquote><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> x
<span class="token punctuation">}</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre><ul><li>对于以上代码来说，如果一个函数被多次调用并且参数一直传入 <code>number</code> 类型，那么 <code>V8</code> 就会认为该段代码可以编译为 <code>Machine Code</code>，因为你固定了类型，不需要再执行很多判断逻辑了。</li><li>但是如果一旦我们传入的参数类型改变，那么 <code>Machine Code</code> 就会被 <code>DeOptimized</code>为 <code>Bytecode</code>，这样就有性能上的一个损耗了。所以如果我们希望代码能多的编译为 <code>Machine Code</code> 并且 <code>DeOptimized</code>的次数减少，就应该尽可能保证传入的类型一致。</li><li>那么你可能会有一个疑问，到底优化前后有多少的提升呢，接下来我们就来实践测试一下到底有多少的提升</li></ul><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> performance<span class="token punctuation">,</span> PerformanceObserver <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'perf_hooks'</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> x
<span class="token punctuation">}</span>
<span class="token comment">// node 10 中才有 PerformanceObserver</span>
<span class="token comment">// 在这之前的 node 版本可以直接使用 performance 中的 API</span>
<span class="token keyword">const</span> obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> observer<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">getEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  observer<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
obs<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">{</span> entryTypes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'measure'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buffered<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

performance<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token number">10000000</span>
<span class="token comment">// 不优化代码</span>
<span class="token operator">%</span><span class="token function">NeverOptimizeFunction</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>number<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

performance<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span>
performance<span class="token punctuation">.</span><span class="token function">measure</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token string">'start'</span><span class="token punctuation">,</span> <span class="token string">'end'</span><span class="token punctuation">)</span>
</code></pre><blockquote><p>以上代码中我们使用了 <code>performance API</code>，这个 <code>API</code> 在性能测试上十分好用。不仅可以用来测量代码的执行时间，还能用来测量各种网络连接中的时间消耗等等，并且这个 API 也可以在浏览器中使</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/4/16778338eb8b7130" alt></p><blockquote><p>从上图中我们可以发现，优化过的代码执行时间只需要 <code>9ms</code>，但是不优化过的代码执行时间却是前者的二十倍，已经接近 <code>200ms</code> 了。在这个案例中，我相信大家已经看到了 <code>V8</code> 的性能优化到底有多强，只需要我们符合一定的规则书写代码，引擎底层就能帮助我们自动优化代码。</p></blockquote><blockquote><p>另外，编译器还有个骚操作 <code>Lazy-Compile</code>，当函数没有被执行的时候，会对函数进行一次预解析，直到代码被执行以后才会被解析编译。对于上述代码来说，<code>test</code> 函数需要被预解析一次，然后在调用的时候再被解析编译。但是对于这种函数马上就被调用的情况来说，预解析这个过程其实是多余的，那么有什么办法能够让代码不被预解析呢？</p></blockquote><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> x
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><blockquote><p>但是不可能我们为了性能优化，给所有的函数都去套上括号，并且也不是所有函数都需要这样做。我们可以通过 <code>optimize-js</code> 实现这个功能，这个库会分析一些函数的使用情况，然后给需要的函数添加括号，当然这个库很久没人维护了，如果需要使用的话，还是需要测试过相关内容的。</p></blockquote><p>其实很简单，我们只需要给函数套上括号就可以了</p><h2 id="_24-性能优化"><a href="#_24-性能优化" aria-hidden="true" class="header-anchor">#</a> 24 性能优化</h2><blockquote><p>总的来说性能优化这个领域的很多内容都很碎片化，这一章节我们将来学习这些碎片化的内容。</p></blockquote><h3 id="_24-1-图片优化"><a href="#_24-1-图片优化" aria-hidden="true" class="header-anchor">#</a> 24.1 图片优化</h3><p><strong>计算图片大小</strong></p><blockquote><p>对于一张 <code>100 * 100</code> 像素的图片来说，图像上有 <code>10000</code> 个像素点，如果每个像素的值是 <code>RGBA</code> 存储的话，那么也就是说每个像素有 <code>4</code> 个通道，每个通道 <code>1</code> 个字节（<code>8</code> 位 = <code>1</code>个字节），所以该图片大小大概为 <code>39KB</code>（<code>10000 * 1 * 4 / 1024</code>）。</p></blockquote><ul><li>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</li><li>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</li></ul><ol><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ol><h3 id="_24-2-图片加载优化"><a href="#_24-2-图片加载优化" aria-hidden="true" class="header-anchor">#</a> 24.2 图片加载优化</h3><ul><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 <code>CSS</code> 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 <code>CDN</code> 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 <code>base64</code> 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：
<ul><li>对于能够显示 <code>WebP</code>格式的浏览器尽量使用 <code>WebP</code> 格式。因为 <code>WebP</code> 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 <code>PNG</code>，其实对于大部分图标这类图片，完全可以使用 <code>SVG</code>代替</li><li>照片使用 <code>JPEG</code></li></ul></li></ul><h3 id="_24-3-dns-预解析"><a href="#_24-3-dns-预解析" aria-hidden="true" class="header-anchor">#</a> 24.3 DNS 预解析</h3><blockquote><p><code>DNS</code> 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 <code>IP</code>。</p></blockquote><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>//blog.poetries.top<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><h3 id="_24-4-节流"><a href="#_24-4-节流" aria-hidden="true" class="header-anchor">#</a> 24.4 节流</h3><blockquote><p>考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。</p></blockquote><p>理解了节流的用途，我们就来实现下这个函数</p><pre class="language-js"><code><span class="token comment">// func是用户传入需要防抖的函数</span>
<span class="token comment">// wait是等待时间</span>
<span class="token keyword">const</span> <span class="token function-variable function">throttle</span> <span class="token operator">=</span> <span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 上一次执行该函数的时间</span>
  <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前时间</span>
    <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 将当前时间和上一次执行函数时间对比</span>
    <span class="token comment">// 如果差值大于设置的等待时间就执行函数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime <span class="token operator">&gt;</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      lastTime <span class="token operator">=</span> now
      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">setInterval</span><span class="token punctuation">(</span>
  <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token number">1</span>
<span class="token punctuation">)</span>

</code></pre><h3 id="_24-5-防抖"><a href="#_24-5-防抖" aria-hidden="true" class="header-anchor">#</a> 24.5 防抖</h3><blockquote><p>考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。</p></blockquote><p>理解了防抖的用途，我们就来实现下这个函数</p><pre class="language-js"><code><span class="token comment">// func是用户传入需要防抖的函数</span>
<span class="token comment">// wait是等待时间</span>
<span class="token keyword">const</span> <span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存一个定时器id</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment">// 这里返回的函数是每次用户实际调用的防抖函数</span>
  <span class="token comment">// 如果已经设定过定时器了就清空上一次的定时器</span>
  <span class="token comment">// 开始一个新的定时器，延迟执行用户传入的方法</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="_24-6-预加载"><a href="#_24-6-预加载" aria-hidden="true" class="header-anchor">#</a> 24.6 预加载</h3><ul><li>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</li><li>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</li></ul><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://blog.poetries.top<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><blockquote><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p></blockquote><h3 id="_24-7-预渲染"><a href="#_24-7-预渲染" aria-hidden="true" class="header-anchor">#</a> 24.7 预渲染</h3><blockquote><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p></blockquote><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>prerender<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://blog.poetries.top<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><blockquote><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。</p></blockquote><h3 id="_24-8-懒执行"><a href="#_24-8-懒执行" aria-hidden="true" class="header-anchor">#</a> 24.8 懒执行</h3><blockquote><p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p></blockquote><h3 id="_24-9-懒加载"><a href="#_24-9-懒加载" aria-hidden="true" class="header-anchor">#</a> 24.9 懒加载</h3><ul><li>懒加载就是将不关键的资源延后加载。</li><li>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载。</li><li>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</li></ul><h3 id="_24-10-cdn"><a href="#_24-10-cdn" aria-hidden="true" class="header-anchor">#</a> 24.10 CDN</h3><blockquote><p><code>CDN</code>的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。</p></blockquote><blockquote><p>因此，我们可以将静态资源尽量使用 <code>CDN</code> 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 <code>CDN</code> 域名。并且对于 <code>CDN</code> 加载静态资源需要注意 <code>CDN</code>  域名要与主站不同，否则每次请求都会带上主站的 <code>Cookie</code>，平白消耗流量</p></blockquote><h2 id="_25-webpack-性能优化"><a href="#_25-webpack-性能优化" aria-hidden="true" class="header-anchor">#</a> 25 Webpack 性能优化</h2><blockquote><p>在这部分的内容中，我们会聚焦于以下两个知识点，并且每一个知识点都属于高频考点：</p></blockquote><ul><li>有哪些方式可以减少 <code>Webpack</code> 的打包时间</li><li>有哪些方式可以让 <code>Webpack</code> 打出来的包更小</li></ul><h3 id="_25-1-减少-webpack-打包时间"><a href="#_25-1-减少-webpack-打包时间" aria-hidden="true" class="header-anchor">#</a> 25.1 减少 Webpack 打包时间</h3><p><strong>1. 优化 Loader</strong></p><blockquote><p>对于 <code>Loader</code> 来说，影响打包效率首当其冲必属 <code>Babel</code> 了。因为 <code>Babel</code> 会将代码转为字符串生成 <code>AST</code>，然后对 <code>AST</code> 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的</p></blockquote><blockquote><p>首先我们可以优化 <code>Loader</code> 的文件搜索范围</p></blockquote><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// js 文件才使用 babel</span>
        test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>
        loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>
        <span class="token comment">// 只在 src 文件夹下查找</span>
        include<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token comment">// 不会去查找的路径</span>
        exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>对于 <code>Babel</code> 来说，我们肯定是希望只作用在 <code>JS</code>代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍</p></blockquote><ul><li>当然这样做还不够，我们还可以将 <code>Babel</code> 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</li></ul><pre class="language-js"><code>loader<span class="token punctuation">:</span> <span class="token string">'babel-loader?cacheDirectory=true'</span>
</code></pre><p><strong>2. HappyPack</strong></p><blockquote><p>受限于 <code>Node</code> 是单线程运行的，所以 <code>Webpack</code> 在打包的过程中也是单线程的，特别是在执行<code>Loader</code> 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p></blockquote><blockquote><p><code>HappyPack</code> 可以将 <code>Loader</code> 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</p></blockquote><pre class="language-js"><code>module<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  loaders<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>
      include<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>
      <span class="token comment">// id 后面的内容对应下面</span>
      loader<span class="token punctuation">:</span> <span class="token string">'happypack/loader?id=happybabel'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
  <span class="token keyword">new</span> <span class="token class-name">HappyPack</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    id<span class="token punctuation">:</span> <span class="token string">'happybabel'</span><span class="token punctuation">,</span>
    loaders<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'babel-loader?cacheDirectory'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// 开启 4 个线程</span>
    threads<span class="token punctuation">:</span> <span class="token number">4</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre><p><strong>3. DllPlugin</strong></p><blockquote><p><code>DllPlugin</code> 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</p></blockquote><p>接下来我们就来学习如何使用 <code>DllPlugin</code></p><pre class="language-js"><code><span class="token comment">// 单独配置在一个文件中</span>
<span class="token comment">// webpack.dll.conf.js</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 想统一打包的类库</span>
    vendor<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'react'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    filename<span class="token punctuation">:</span> <span class="token string">'[name].dll.js'</span><span class="token punctuation">,</span>
    library<span class="token punctuation">:</span> <span class="token string">'[name]-[hash]'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// name 必须和 output.library 一致</span>
      name<span class="token punctuation">:</span> <span class="token string">'[name]-[hash]'</span><span class="token punctuation">,</span>
      <span class="token comment">// 该属性需要与 DllReferencePlugin 中一致</span>
      context<span class="token punctuation">:</span> __dirname<span class="token punctuation">,</span>
      path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">,</span> <span class="token string">'[name]-manifest.json'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中</p></blockquote><pre class="language-js"><code><span class="token comment">// webpack.conf.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...省略其他配置</span>
  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllReferencePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      context<span class="token punctuation">:</span> __dirname<span class="token punctuation">,</span>
      <span class="token comment">// manifest 就是之前打包出来的 json 文件</span>
      manifest<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./dist/vendor-manifest.json'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>4. 代码压缩</strong></p><blockquote><p>在 <code>Webpack3</code> 中，我们一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p></blockquote><blockquote><p>在 <code>Webpack4</code> 中，我们就不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 <code>JS</code> 代码，还可以压缩 <code>HTML</code>、<code>CSS</code> 代码，并且在压缩 <code>JS</code> 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p></blockquote><p><strong>5. 一些小的优化点</strong></p><blockquote><p>我们还可以通过一些小的优化点来加快打包速度</p></blockquote><ul><li><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>['.js', '.json']</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li><li><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 <code>Webpack</code> 更快找到路径</li><li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li></ul><h3 id="_25-2-减少-webpack-打包后的文件体积"><a href="#_25-2-减少-webpack-打包后的文件体积" aria-hidden="true" class="header-anchor">#</a> 25.2 减少 Webpack 打包后的文件体积</h3><p><strong>1. 按需加载</strong></p><blockquote><p>想必大家在开发 <code>SPA</code> 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 <code>JS</code>文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p></blockquote><blockquote><p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code>成功以后去执行回调。</p></blockquote><p><strong>2. Scope Hoisting</strong></p><blockquote><p><code>Scope Hoisting</code> 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p></blockquote><p>比如我们希望打包两个文件</p><pre class="language-js"><code><span class="token comment">// test.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment">// index.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> a <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./test.js'</span>
</code></pre><blockquote><p>对于这种情况，我们打包出来的代码会类似这样</p></blockquote><pre class="language-js"><code><span class="token punctuation">[</span>
  <span class="token comment">/* 0 */</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">/* 1 */</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre><blockquote><p>但是如果我们使用 <code>Scope Hoisting</code> 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p></blockquote><pre class="language-js"><code><span class="token punctuation">[</span>
  <span class="token comment">/* 0 */</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>

</code></pre><blockquote><p>这样的打包方式生成的代码明显比之前的少多了。如果在 <code>Webpack4</code> 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code>就可以了。</p></blockquote><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    concatenateModules<span class="token punctuation">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>3. Tree Shaking</strong></p><blockquote><p><code>Tree Shaking</code> 可以实现删除项目中未被引用的代码，比如</p></blockquote><pre class="language-js"><code><span class="token comment">// test.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">2</span>
<span class="token comment">// index.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> a <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./test.js'</span>
</code></pre><ul><li>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</li><li>如果你使用 <code>Webpack 4</code> 的话，开启生产环境就会自动启动这个优化功能。</li></ul><h2 id="_26-实现小型打包工具"><a href="#_26-实现小型打包工具" aria-hidden="true" class="header-anchor">#</a> 26 实现小型打包工具</h2><blockquote><p>该工具可以实现以下两个功能</p></blockquote><ul><li>将 <code>ES6</code> 转换为 <code>ES5</code></li><li>支持在 <code>JS</code> 文件中 <code>import CSS</code> 文件</li></ul><blockquote><p>通过这个工具的实现，大家可以理解到打包工具的原理到底是什么</p></blockquote><p><strong>实现</strong></p><blockquote><p>因为涉及到 <code>ES6</code> 转 <code>ES5</code>，所以我们首先需要安装一些 <code>Babel</code> 相关的工具</p></blockquote><pre class="language-text"><code>yarn add babylon babel-traverse babel-core babel-preset-env  
</code></pre><p>接下来我们将这些工具引入文件中</p><pre class="language-js"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> babylon <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'babylon'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> traverse <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'babel-traverse'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> transformFromAst <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'babel-core'</span><span class="token punctuation">)</span>
</code></pre><p>首先，我们先来实现如何使用 <code>Babel</code> 转换代码</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">readCode</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 读取文件内容</span>
  <span class="token keyword">const</span> content <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>
  <span class="token comment">// 生成 AST</span>
  <span class="token keyword">const</span> ast <span class="token operator">=</span> babylon<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    sourceType<span class="token punctuation">:</span> <span class="token string">'module'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 寻找当前文件的依赖关系</span>
  <span class="token keyword">const</span> dependencies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    ImportDeclaration<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> node <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      dependencies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>source<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 通过 AST 将代码转为 ES5</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> code <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">transformFromAst</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    presets<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'env'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    filePath<span class="token punctuation">,</span>
    dependencies<span class="token punctuation">,</span>
    code
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><ul><li>首先我们传入一个文件路径参数，然后通过 <code>fs</code> 将文件中的内容读取出来</li><li>接下来我们通过 <code>babylon</code> 解析代码获取 <code>AST</code>，目的是为了分析代码中是否还引入了别的文件</li><li>通过 <code>dependencies</code> 来存储文件中的依赖，然后再将 <code>AST</code> 转换为 <code>ES5</code> 代码</li><li>最后函数返回了一个对象，对象中包含了当前文件路径、当前文件依赖和当前文件转换后的代码</li></ul><blockquote><p>接下来我们需要实现一个函数，这个函数的功能有以下几点</p></blockquote><ul><li>调用 <code>readCode</code> 函数，传入入口文件</li><li>分析入口文件的依赖</li><li>识别 <code>JS</code> 和 <code>CSS</code> 文件</li></ul><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getDependencies</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 读取入口文件</span>
  <span class="token keyword">const</span> entryObject <span class="token operator">=</span> <span class="token function">readCode</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span>
  <span class="token keyword">const</span> dependencies <span class="token operator">=</span> <span class="token punctuation">[</span>entryObject<span class="token punctuation">]</span>
  <span class="token comment">// 遍历所有文件依赖关系</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> asset <span class="token keyword">of</span> dependencies<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获得文件目录</span>
    <span class="token keyword">const</span> dirname <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>asset<span class="token punctuation">.</span>filePath<span class="token punctuation">)</span>
    <span class="token comment">// 遍历当前文件依赖关系</span>
    asset<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>relativePath <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获得绝对路径</span>
      <span class="token keyword">const</span> absolutePath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>dirname<span class="token punctuation">,</span> relativePath<span class="token punctuation">)</span>
      <span class="token comment">// CSS 文件逻辑就是将代码插入到 `style` 标签中</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/\.css$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>absolutePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> content <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>absolutePath<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>
        <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token string">`
          const style = document.createElement('style')
          style.innerText = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\\r\\n/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
          document.head.appendChild(style)
        `</span></span>
        dependencies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          filePath<span class="token punctuation">:</span> absolutePath<span class="token punctuation">,</span>
          relativePath<span class="token punctuation">,</span>
          dependencies<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
          code
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// JS 代码需要继续查找是否有依赖关系</span>
        <span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">readCode</span><span class="token punctuation">(</span>absolutePath<span class="token punctuation">)</span>
        child<span class="token punctuation">.</span>relativePath <span class="token operator">=</span> relativePath
        dependencies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dependencies
<span class="token punctuation">}</span>
</code></pre><ul><li>首先我们读取入口文件，然后创建一个数组，该数组的目的是存储代码中涉及到的所有文件</li><li>接下来我们遍历这个数组，一开始这个数组中只有入口文件，在遍历的过程中，如果入口文件有依赖其他的文件，那么就会被 <code>push</code> 到这个数组中</li><li>在遍历的过程中，我们先获得该文件对应的目录，然后遍历当前文件的依赖关系</li><li>在遍历当前文件依赖关系的过程中，首先生成依赖文件的绝对路径，然后判断当前文件是 <code>CSS</code> 文件还是 <code>JS</code> 文件</li><li>如果是 <code>CSS</code> 文件的话，我们就不能用 <code>Babel</code> 去编译了，只需要读取 <code>CSS</code> 文件中的代码，然后创建一个 <code>style</code> 标签，将代码插入进标签并且放入 <code>head</code> 中即可</li><li>如果是 <code>JS</code> 文件的话，我们还需要分析 <code>JS</code> 文件是否还有别的依赖关系</li><li>最后将读取文件后的对象 <code>push</code> 进数组中</li><li>现在我们已经获取到了所有的依赖文件，接下来就是实现打包的功能了</li></ul><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bundle</span><span class="token punctuation">(</span>dependencies<span class="token punctuation">,</span> entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> modules <span class="token operator">=</span> <span class="token string">''</span>
  <span class="token comment">// 构建函数参数，生成的结构为</span>
  <span class="token comment">// { './entry.js': function(module, exports, require) { 代码 } }</span>
  dependencies<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>dep <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> filePath <span class="token operator">=</span> dep<span class="token punctuation">.</span>relativePath <span class="token operator">||</span> entry
    modules <span class="token operator">+=</span> <span class="token template-string"><span class="token string">`'</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>filePath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">': (
      function (module, exports, require) { </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dep<span class="token punctuation">.</span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> }
    ),`</span></span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 构建 require 函数，目的是为了获取模块暴露出来的内容</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token template-string"><span class="token string">`
    (function(modules) {
      function require(id) {
        const module = { exports : {} }
        modules[id](module, module.exports, require)
        return module.exports
      }
      require('</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>entry<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">')
    })({</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>modules<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">})
  `</span></span>
  <span class="token comment">// 当生成的内容写入到文件中</span>
  fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span><span class="token string">'./bundle.js'</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>这段代码需要结合着 <code>Babel</code> 转换后的代码来看，这样大家就能理解为什么需要这样写了</p></blockquote><pre class="language-js"><code><span class="token comment">// entry.js</span>
<span class="token keyword">var</span> _a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> _a2 <span class="token operator">=</span> <span class="token function">_interopRequireDefault</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">_interopRequireDefault</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>__esModule <span class="token operator">?</span> obj <span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> obj <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_a2<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span>
<span class="token comment">// a.js</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>exports<span class="token punctuation">,</span> <span class="token string">'__esModule'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
exports<span class="token punctuation">.</span><span class="token keyword">default</span> <span class="token operator">=</span> a
</code></pre><blockquote><p><code>Babel</code> 将我们 <code>ES6</code>的模块化代码转换为了 <code>CommonJS</code>的代码，但是浏览器是不支持 <code>CommonJS</code> 的，所以如果这段代码需要在浏览器环境下运行的话，我们需要自己实现 <code>CommonJS</code> 相关的代码，这就是 <code>bundle</code> 函数做的大部分事情。</p></blockquote><p><strong>接下来我们再来逐行解析 bundle 函数</strong></p><ul><li>首先遍历所有依赖文件，构建出一个函数参数对象</li><li>对象的属性就是当前文件的相对路径，属性值是一个函数，函数体是当前文件下的代码，函数接受三个参数 <code>module</code>、<code>exports</code>、 <code>require</code><ul><li><code>module</code> 参数对应 <code>CommonJS</code> 中的 <code>module</code></li><li><code>exports</code> 参数对应 <code>CommonJS</code> 中的 <code>module.export</code></li><li><code>require</code> 参数对应我们自己创建的 <code>require</code> 函数</li></ul></li><li>接下来就是构造一个使用参数的函数了，函数做的事情很简单，就是内部创建一个 <code>require</code>函数，然后调用 <code>require(entry)</code>，也就是 <code>require('./entry.js')</code>，这样就会从函数参数中找到 <code>./entry.js</code> 对应的函数并执行，最后将导出的内容通过 <code>module.export</code> 的方式让外部获取到</li><li>最后再将打包出来的内容写入到单独的文件中</li></ul><blockquote><p>如果你对于上面的实现还有疑惑的话，可以阅读下打包后的部分简化代码</p></blockquote><pre class="language-js"><code><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>modules<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">require</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 构造一个 CommonJS 导出代码</span>
    <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token punctuation">{</span> exports<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span>
    <span class="token comment">// 去参数中获取文件对应的函数并执行</span>
    modules<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span>
    <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports
  <span class="token punctuation">}</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./entry.js'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token string">'./entry.js'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里继续通过构造的 require 去找到 a.js 文件对应的函数</span>
    <span class="token keyword">var</span> _a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_a2<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">'./a.js'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token comment">// 将 require 函数中的变量 module 变成了这样的结构</span>
    <span class="token comment">// module.exports = 1</span>
    <span class="token comment">// 这样就能在外部取到导出的内容了</span>
    exports<span class="token punctuation">.</span><span class="token keyword">default</span> <span class="token operator">=</span> a
  <span class="token punctuation">}</span>
  <span class="token comment">// 省略</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><blockquote><p>虽然实现这个工具只写了不到 <code>100</code> 行的代码，但是打包工具的核心原理就是这些了</p></blockquote><ul><li>找出入口文件所有的依赖关系</li><li>然后通过构建 <code>CommonJS</code> 代码来获取 <code>exports</code> 导出的内容</li></ul><h2 id="_27-mvvm-虚拟dom-前端路由"><a href="#_27-mvvm-虚拟dom-前端路由" aria-hidden="true" class="header-anchor">#</a> 27 MVVM/虚拟DOM/前端路由</h2><h3 id="_27-1-mvvm"><a href="#_27-1-mvvm" aria-hidden="true" class="header-anchor">#</a> 27.1 MVVM</h3><blockquote><p>涉及面试题：什么是 <code>MVVM</code>？比之 <code>MVC</code> 有什么区别？</p></blockquote><p><strong>首先先来说下 View 和 Model</strong></p><ul><li><code>View</code> 很简单，就是用户看到的视图</li><li><code>Model</code> 同样很简单，一般就是本地数据和数据库中的数据</li></ul><blockquote><p>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</p></blockquote><blockquote><p>传统的 <code>MVC</code> 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/20/167cad938817eb7e" alt></p><ul><li>但是 <code>MVC</code> 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</li><li>在 <code>MVVM</code> 架构中，引入了 <code>ViewModel</code> 的概念。<code>ViewModel</code> 只关心数据和业务的处理，不关心 <code>View</code> 如何处理数据，在这种情况下，<code>View</code>和 <code>Model</code> 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 <code>ViewModel</code> 中，让多个 <code>View</code> 复用这个 <code>ViewModel</code>。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167ced454926a458" alt></p><ul><li>以 <code>Vue</code> 框架来举例，<code>ViewModel</code> 就是组件的实例。<code>View</code> 就是模板，<code>Model</code> 的话在引入 <code>Vuex</code> 的情况下是完全可以和组件分离的。</li><li>除了以上三个部分，其实在 <code>MVVM</code> 中还引入了一个隐式的 <code>Binder</code> 层，实现了 <code>View</code> 和 <code>ViewModel</code> 的绑定</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167cf01bd8430243" alt></p><ul><li>同样以 <code>Vue</code> 框架来举例，这个隐式的 <code>Binder</code> 层就是 <code>Vue</code> 通过解析模板中的插值和指令从而实现 <code>View</code> 与 <code>ViewModel</code> 的绑定。</li><li>对于 <code>MVVM</code>来说，其实最重要的并不是通过双向绑定或者其他的方式将 <code>View</code> 与 <code>ViewModel</code> 绑定起来，而是通过 <code>ViewModel</code> 将视图中的状态和用户的行为分离出一个抽象，这才是 <code>MVVM</code> 的精髓</li></ul><h3 id="_27-2-virtual-dom"><a href="#_27-2-virtual-dom" aria-hidden="true" class="header-anchor">#</a> 27.2 Virtual DOM</h3><blockquote><p>涉及面试题：什么是 <code>Virtual DOM</code>？为什么 <code>Virtual DOM</code>比原生 <code>DOM</code> 快？</p></blockquote><ul><li>大家都知道操作 <code>DOM</code> 是很慢的，为什么慢的原因以及在「浏览器渲染原理」章节中说过，这里就不再赘述了- 那么相较于 <code>DOM</code>来说，操作 <code>JS</code> 对象会快很多，并且我们也可以通过 <code>JS</code>来模拟 <code>DOM</code></li></ul><pre class="language-js"><code><span class="token keyword">const</span> ul <span class="token operator">=</span> <span class="token punctuation">{</span>
  tag<span class="token punctuation">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">'list'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    tag<span class="token punctuation">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span>
    children<span class="token punctuation">:</span> <span class="token string">'1'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>上述代码对应的 <code>DOM</code> 就是</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>list<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre><ul><li>那么既然 <code>DOM</code> 可以通过 <code>JS</code> 对象来模拟，反之也可以通过 <code>JS</code> 对象来渲染出对应的 <code>DOM</code>。当然了，通过 <code>JS</code> 来模拟 <code>DOM</code> 并且渲染对应的 <code>DOM</code> 只是第一步，难点在于如何判断新旧两个 <code>JS</code> 对象的最小差异并且实现局部更新 <code>DOM</code></li></ul><blockquote><p>首先 <code>DOM</code> 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 <code>O(n ^ 3)</code>，这个复杂度肯定是不能接受的。于是 <code>React</code> 团队优化了算法，实现了 <code>O(n)</code> 的复杂度来对比差异。 实现 <code>O(n)</code> 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 <code>DOM</code> 元素。 所以判断差异的算法就分为了两步</p></blockquote><ul><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li><li>一旦节点有子元素，就去判断子元素是否有不同</li></ul><blockquote><p>在第一步算法中我们需要判断新旧节点的 <code>tagName</code> 是否相同，如果不相同的话就代表节点被替换了。如果没有更改 <code>tagName</code> 的话，就需要判断是否有子元素，有的话就进行第二步算法。</p></blockquote><blockquote><p>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。</p></blockquote><p>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p><pre class="language-js"><code><span class="token comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment">// 这里替换上面的 li</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
</code></pre><blockquote><p>从上述例子中，我们一眼就可以看出先前的 <code>ul</code> 中的第三个<code>li</code>被移除了，四五替换了位置。</p></blockquote><blockquote><p>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了 <code>key</code> 这个属性，想必大家在 <code>Vue</code> 或者 <code>React</code> 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。</p></blockquote><ul><li>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。</li><li>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 <code>DOM</code>，实现性能的最优化。</li></ul><blockquote><p>当然了 <code>Virtual DOM</code> 提高性能是其中一个优势，其实最大的优势还是在于：</p></blockquote><ul><li>将 <code>Virtual DOM</code>作为一个兼容层，让我们还能对接非 <code>Web</code> 端的系统，实现跨端开发。</li><li>同样的，通过 <code>Virtual DOM</code>我们可以渲染到其他的平台，比如实现 <code>SSR</code>、同构渲染等等。</li><li>实现组件的高度抽象化</li></ul><h3 id="_27-3-路由原理"><a href="#_27-3-路由原理" aria-hidden="true" class="header-anchor">#</a> 27.3 路由原理</h3><blockquote><p>涉及面试题：前端路由原理？两种实现方式有什么区别？</p></blockquote><blockquote><p>前端路由实现起来其实很简单，本质就是监听 <code>URL</code> 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式</p></blockquote><ul><li><code>Hash</code> 模式</li><li><code>History</code> 模式</li></ul><p><strong>1. Hash 模式</strong></p><blockquote><p><code>www.test.com/#/</code> 就是 <code>Hash URL</code>，当 <code>#</code> 后面的哈希值发生变化时，可以通过 <code>hashchange</code> 事件来监听到 <code>URL</code> 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 <code>URL</code> 请求永远是 <code>www.test.com</code></p></blockquote><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 具体逻辑</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><blockquote><p><code>Hash</code> 模式相对来说更简单，并且兼容性也更好</p></blockquote><p><strong>2. History 模式</strong></p><blockquote><p><code>History</code> 模式是 <code>HTML5</code> 新推出的功能，主要使用 <code>history.pushState</code> 和 <code>history.replaceState</code> 改变 <code>URL</code></p></blockquote><ul><li>通过 <code>History</code> 模式改变 <code>URL</code> 同样不会引起页面的刷新，只会更新浏览器的历史记录。</li></ul><pre class="language-js"><code><span class="token comment">// 新增历史记录</span>
history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">)</span>
<span class="token comment">// 替换当前历史记录</span>
history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">)</span>
</code></pre><blockquote><p>当用户做出浏览器动作时，比如点击后退按钮时会触发 <code>popState</code> 事件</p></blockquote><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'popstate'</span><span class="token punctuation">,</span> e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// e.state 就是 pushState(stateObject) 中的 stateObject</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>state<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p><strong>两种模式对比</strong></p><ul><li><code>Hash</code>模式只可以更改 <code>#</code> 后面的内容，<code>History</code> 模式可以通过 <code>API</code> 设置任意的同源 <code>URL</code></li><li><code>History</code> 模式可以通过 <code>API</code> 添加任意类型的数据到历史记录中，<code>Hash</code> 模式只能更改哈希值，也就是字符串</li><li><code>Hash</code> 模式无需后端配置，并且兼容性好。<code>History</code> 模式在用户手动输入地址或者刷新页面的时候会发起 <code>URL</code> 请求，后端需要配置 <code>index.html</code> 页面用于匹配不到静态资源的时候</li></ul><h3 id="_27-4-vue-和-react-之间的区别"><a href="#_27-4-vue-和-react-之间的区别" aria-hidden="true" class="header-anchor">#</a> 27.4 Vue 和 React 之间的区别</h3><ul><li><code>Vue</code> 的表单可以使用 <code>v-model</code> 支持双向绑定，相比于 <code>React</code> 来说开发上更加方便，当然了 <code>v-model</code> 其实就是个语法糖，本质上和 <code>React</code> 写表单的方式没什么区别</li><li>改变数据方式不同，<code>Vue</code> 修改状态相比来说要简单许多，<code>React</code> 需要使用 <code>setState</code> 来改变状态，并且使用这个 <code>API</code> 也有一些坑点。并且 <code>Vue</code> 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 <code>React</code> 还是需要用户手动去优化这方面的问题。</li><li><code>React 16</code>以后，有些钩子函数会执行多次，这是因为引入 <code>Fiber</code> 的原因</li><li><code>React</code> 需要使用 <code>JSX</code>，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 <code>JS</code> 来控制页面，更加的灵活。<code>Vue</code> 使用了模板语法，相比于 <code>JSX</code> 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 <code>render</code> 函数就能在浏览器中运行。</li><li>在生态上来说，两者其实没多大的差距，当然 <code>React</code>的用户是远远高于<code>Vue</code> 的</li></ul><h2 id="_28-vue常考知识点"><a href="#_28-vue常考知识点" aria-hidden="true" class="header-anchor">#</a> 28 Vue常考知识点</h2><h3 id="_28-1-生命周期钩子函数"><a href="#_28-1-生命周期钩子函数" aria-hidden="true" class="header-anchor">#</a> 28.1 生命周期钩子函数</h3><ul><li>在 <code>beforeCreate</code> 钩子函数调用的时候，是获取不到 <code>props</code> 或者 <code>data</code> 中的数据的，因为这些数据的初始化都在 <code>initState</code> 中。</li><li>然后会执行 <code>created</code> 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</li><li>接下来会先执行 <code>beforeMount</code> 钩子函数，开始创建 <code>VDOM</code>，最后执行 <code>mounted</code> 钩子，并将 <code>VDOM</code>渲染为真实 <code>DOM</code> 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</li><li>接下来是数据更新时会调用的钩子函数 <code>beforeUpdate</code> 和 <code>updated</code>，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</li><li>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code>。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</li><li>最后就是销毁组件的钩子函数 <code>beforeDestroy</code> 和 <code>destroyed</code>。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 <code>destroyed</code> 钩子函数</li></ul><h3 id="_28-2-组件通信"><a href="#_28-2-组件通信" aria-hidden="true" class="header-anchor">#</a> 28.2 组件通信</h3><blockquote><p>组件通信一般分为以下几种情况：</p></blockquote><ul><li>父子组件通信</li><li>兄弟组件通信</li><li>跨多层级组件通信</li></ul><blockquote><p>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</p></blockquote><p><strong>1. 父子通信</strong></p><ul><li>父组件通过 <code>props</code> 传递数据给子组件，子组件通过 <code>emit</code> 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</li><li>这种父子通信方式也就是典型的单向数据流，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>，而是必须通过发送事件的方式告知父组件修改数据。</li><li>另外这两种方式还可以使用语法糖 <code>v-model</code> 来直接实现，因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。这种语法糖的方式是典型的双向绑定，常用于 <code>UI</code> 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</li><li>当然我们还可以通过访问 <code>$parent</code> 或者 <code>$children</code> 对象来访问组件实例中的方法和数据。</li><li>另外如果你使用 Vue 2.3 及以上版本的话还可以使用 <code>$listeners</code> 和 <code>.sync</code> 这两个属性。</li><li><code>$listeners</code> 属性会将父组件中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器传递给子组件，子组件可以通过访问 <code>$listeners</code> 来自定义监听器。</li><li><code>.sync</code> 属性是个语法糖，可以很简单的实现子组件与父组件通信</li></ul><pre class="language-html"><code><span class="token comment">&lt;!--父组件中--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value.sync</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!--以上写法等同于--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>v =&gt; value = v<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comp</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!--子组件中--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'update:value'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><p><strong>2. 兄弟组件通信</strong></p><blockquote><p>对于这种情况可以通过查找父组件中的子组件实现，也就是 <code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p></blockquote><p><strong>3. 跨多层次组件通信</strong></p><blockquote><p>对于这种情况可以使用 <code>Vue 2.2</code> 新增的 <code>API provide / inject</code>，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p></blockquote><p>假设有父组件 <code>A</code>，然后有一个跨多层级的子组件 <code>B</code></p><pre class="language-js"><code><span class="token comment">// 父组件 A</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  provide<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 子组件 B</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  inject<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 无论跨几层都能获得父组件的 data 属性</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// =&gt; 1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>终极办法解决一切通信问题</strong></p><blockquote><p>只要你不怕麻烦，可以使用 <code>Vuex</code> 或者 <code>Event Bus</code> 解决上述所有的通信情况。</p></blockquote><h3 id="_28-3-extend-能做什么"><a href="#_28-3-extend-能做什么" aria-hidden="true" class="header-anchor">#</a> 28.3 extend 能做什么</h3><blockquote><p>这个 <code>API</code> 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p></blockquote><pre class="language-js"><code><span class="token comment">// 创建组件构造器</span>
<span class="token keyword">let</span> Component <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token punctuation">:</span> <span class="token string">'&lt;div&gt;test&lt;/div&gt;'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 挂载到 #app 上</span>
<span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span class="token comment">// 除了上面的方式，还可以用来扩展已有的组件</span>
<span class="token keyword">let</span> SuperComponent <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">SuperComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">SuperComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre><h3 id="_28-4-mixin-和-mixins-区别"><a href="#_28-4-mixin-和-mixins-区别" aria-hidden="true" class="header-anchor">#</a> 28.4 mixin 和 mixins 区别</h3><blockquote><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的</p></blockquote><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...逻辑</span>
        <span class="token comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><ul><li>虽然文档不建议我们在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</li><li><code>mixins</code> 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。</li><li>另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 文档。</li></ul><h3 id="_28-5-computed-和-watch-区别"><a href="#_28-5-computed-和-watch-区别" aria-hidden="true" class="header-anchor">#</a> 28.5 computed 和 watch 区别</h3><ul><li><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容。</li><li><code>watch</code> 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</li><li>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 <code>computed</code>，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 <code>watch</code>。</li><li>另外 <code>computer</code> 和 <code>watch</code> 还都支持对象的写法，这种方式知道的人并不多。</li></ul><pre class="language-js"><code>vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'obj'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 深度遍历</span>
    deep<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 立即触发</span>
    immediate<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 执行的函数</span>
    handler<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    aPlus<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// this.aPlus 时触发</span>
      <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token comment">// this.aPlus = 1 时触发</span>
      <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> v <span class="token operator">-</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h3 id="_28-6-keep-alive-组件有什么作用"><a href="#_28-6-keep-alive-组件有什么作用" aria-hidden="true" class="header-anchor">#</a> 28.6 keep-alive 组件有什么作用</h3><ul><li>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 <code>keep-alive</code> 组件包裹需要保存的组件。</li><li>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</li></ul><h3 id="_28-7-v-show-与-v-if-区别"><a href="#_28-7-v-show-与-v-if-区别" aria-hidden="true" class="header-anchor">#</a> 28.7 v-show 与 v-if 区别</h3><ul><li><code>v-show</code> 只是在 <code>display: none</code> 和 <code>display: block</code> 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 <code>CSS</code>，<code>DOM</code> 还是一直保留着的。所以总的来说 <code>v-show</code> 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</li><li><code>v-if</code> 的话就得说到 <code>Vue</code> 底层的编译了。当属性初始为 <code>false</code> 时，组件就不会被渲染，直到条件为 <code>true</code>，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</li><li>并且基于 <code>v-if</code> 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</li></ul><h3 id="_28-8-组件中-data-什么时候可以使用对象"><a href="#_28-8-组件中-data-什么时候可以使用对象" aria-hidden="true" class="header-anchor">#</a> 28.8 组件中 data 什么时候可以使用对象</h3><blockquote><p>这道题目其实更多考的是 JS 功底。</p></blockquote><ul><li>组件复用时所有组件实例都会共享 <code>data</code>，如果 <code>data</code> 是对象的话，就会造成一个组件修改 <code>data</code> 以后会影响到其他所有组件，所以需要将 <code>data</code> 写成函数，每次用到就调用一次函数获得新的数据。</li><li>当我们使用 <code>new Vue()</code> 的方式的时候，无论我们将 <code>data</code> 设置为对象还是函数都是可以的，因为 <code>new Vue()</code> 的方式是生成一个根组件，该组件不会复用，也就不存在共享 <code>data</code> 的情况了</li></ul><blockquote><p>以下是进阶部分</p></blockquote><h3 id="_28-9-响应式原理"><a href="#_28-9-响应式原理" aria-hidden="true" class="header-anchor">#</a> 28.9 响应式原理</h3><blockquote><p><code>Vue</code> 内部使用了 <code>Object.defineProperty()</code> 来实现数据响应式，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件</p></blockquote><pre class="language-js"><code><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'poetries'</span> <span class="token punctuation">}</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">let</span> name <span class="token operator">=</span> data<span class="token punctuation">.</span>name <span class="token comment">// -&gt; get value</span>
data<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yyy'</span> <span class="token comment">// -&gt; change value</span>

<span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断类型</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 递归子属性</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 可枚举</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 可配置</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 自定义函数</span>
    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get value'</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> val
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'change value'</span><span class="token punctuation">)</span>
      val <span class="token operator">=</span> newVal
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，从能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集</p></blockquote><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    {{name}}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><ul><li>在解析如上模板代码时，遇到 <code></code> 就会进行依赖收集。</li><li>接下来我们先来实现一个 <code>Dep</code> 类，用于解耦属性的依赖收集和派发更新操作</li></ul><pre class="language-js"><code><span class="token comment">// 通过 Dep 解耦属性的依赖和更新操作</span>
<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 添加依赖</span>
  <span class="token function">addSub</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 更新</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>sub <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 全局属性，通过该属性配置 Watcher</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre><blockquote><p>以上的代码实现很简单，当需要依赖收集的时候调用 <code>addSub</code>，当需要派发更新的时候调用 <code>notify</code>。</p></blockquote><blockquote><p>接下来我们先来简单的了解下 <code>Vue</code>组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 <code>Object.defineProperty()</code>，然后实例化 <code>Watcher</code>，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。</p></blockquote><p>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将 Dep.target 指向自己</span>
    <span class="token comment">// 然后触发属性的 getter 添加监听</span>
    <span class="token comment">// 最后将 Dep.target 置空</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb
    <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获得新值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span>
    <span class="token comment">// 调用 update 方法更新 Dom</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>以上就是 <code>Watcher</code>的简单实现，在执行构造函数的时候将 <code>Dep.target</code>指向自身，从而使得收集到了对应的 <code>Watcher</code>，在派发更新的时候取出对应的 <code>Watcher</code> 然后执行 <code>update</code> 函数。</p></blockquote><p>接下来，需要对<code>defineReactive</code> 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 递归子属性</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
  <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get value'</span><span class="token punctuation">)</span>
      <span class="token comment">// 将 Watcher 添加到订阅</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> val
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'change value'</span><span class="token punctuation">)</span>
      val <span class="token operator">=</span> newVal
      <span class="token comment">// 执行 watcher 的 update 方法</span>
      dp<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 <code>getter</code> 来实现依赖收集。</p></blockquote><p>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了</p><pre class="language-js"><code><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'poetries'</span> <span class="token punctuation">}</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> value
<span class="token punctuation">}</span>
<span class="token comment">// 模拟解析到 `{{name}}` 触发的操作</span>
<span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
<span class="token comment">// update Dom innerText</span>
data<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yyy'</span>
</code></pre><h4 id="_28-9-1-object-defineproperty-的缺陷"><a href="#_28-9-1-object-defineproperty-的缺陷" aria-hidden="true" class="header-anchor">#</a> 28.9.1 Object.defineProperty 的缺陷</h4><ul><li>以上已经分析完了 <code>Vue</code> 的响应式原理，接下来说一点 <code>Object.defineProperty</code> 中的缺陷。</li><li>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为<code>Object.defineProperty</code> 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 <code>Vue</code> 内部通过重写函数的方式解决了这个问题。</li><li>对于第一个问题，<code>Vue</code> 提供了一个 <code>API</code> 解决</li></ul><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>target<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token punctuation">:</span> any<span class="token punctuation">,</span> val<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> any <span class="token punctuation">{</span>
  <span class="token comment">// 判断是否为数组且下标是否有效</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 splice 函数触发派发更新</span>
    <span class="token comment">// 该函数已被重写</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 判断 key 是否已经存在</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token comment">// 如果对象不是响应式对象，就赋值返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 进行双向绑定</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  <span class="token comment">// 手动派发更新</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre><blockquote><p>对于数组而言，<code>Vue</code>内部重写了以下函数实现派发更新</p></blockquote><pre class="language-js"><code><span class="token comment">// 获得数组原型</span>
<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>
<span class="token comment">// 重写以下函数</span>
<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存原生函数</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token comment">// 重写函数</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 先调用原生函数获得结果</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">let</span> inserted
    <span class="token comment">// 调用以下几个函数时，监听新数据</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token punctuation">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token punctuation">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token punctuation">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
    <span class="token comment">// 手动派发更新</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h4 id="_28-9-2-编译过程"><a href="#_28-9-2-编译过程" aria-hidden="true" class="header-anchor">#</a> 28.9.2 编译过程</h4><blockquote><p>想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？</p></blockquote><ul><li>首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。<code>Vue</code> 会通过编译器将模板通过几个阶段最终编译为 <code>render</code> 函数，然后通过执行 <code>render</code> 函数生成 <code>Virtual DOM</code> 最终映射为真实 <code>DOM</code>。</li><li>接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。<strong>这个过程其中又分为三个阶段</strong>，分别为：</li></ul><blockquote><ul><li>将模板解析为 <code>AST</code></li><li>优化 <code>AST</code></li><li>将 <code>AST</code>转换为 <code>render</code>函数</li></ul></blockquote><p>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 <code>AST</code>对象</p><pre class="language-js"><code><span class="token punctuation">{</span>
    <span class="token comment">// 类型</span>
    type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token comment">// 标签</span>
    tag<span class="token punctuation">,</span>
    <span class="token comment">// 属性列表</span>
    attrsList<span class="token punctuation">:</span> attrs<span class="token punctuation">,</span>
    <span class="token comment">// 属性映射</span>
    attrsMap<span class="token punctuation">:</span> <span class="token function">makeAttrsMap</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// 父节点</span>
    parent<span class="token punctuation">,</span>
    <span class="token comment">// 子节点</span>
    children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><ul><li>然后会根据这个最基本的 AST 对象中的属性，进一步扩展 <code>AST</code>。</li><li>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 <code>HTML5 Content Model</code>规范等等问题。</li><li>接下来就是优化 AST 的阶段。在当前版本下，<code>Vue</code> 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 <code>Virtual DOM</code>，跳过对比算法的功能。在下一个大版本中，<code>Vue</code> 会在优化 <code>AST</code> 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。</li><li>最后一个阶段就是通过 <code>AST</code> 生成 <code>render</code> 函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 <code>AST</code>，根据不同的条件生成不同的代码罢了。</li></ul><h4 id="_28-9-3-nexttick-原理分析"><a href="#_28-9-3-nexttick-原理分析" aria-hidden="true" class="header-anchor">#</a> 28.9.3 NextTick 原理分析</h4><blockquote><p><code>nextTick</code> 可以让我们在下次 <code>DOM</code> 更新循环结束之后执行延迟回调，用于获得更新后的 <code>DOM</code>。</p></blockquote><ul><li>在 <code>Vue 2.4</code> 之前都是使用的 <code>microtasks</code>，但是<code>microtasks</code> 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 <code>macrotasks</code> 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 <code>microtasks</code>，但在特殊情况下会使用 <code>macrotasks</code>，比如 <code>v-on</code>。</li><li>对于实现 <code>macrotasks</code> ，会先判断是否能使用 <code>setImmediate</code> ，不能的话降级为 <code>MessageChannel</code> ，以上都不行的话就使用 <code>setTimeout</code></li></ul><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">macroTimerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
  <span class="token keyword">typeof</span> MessageChannel <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span>
  <span class="token punctuation">(</span><span class="token function">isNative</span><span class="token punctuation">(</span>MessageChannel<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token comment">// PhantomJS</span>
    MessageChannel<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object MessageChannelConstructor]'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> port <span class="token operator">=</span> channel<span class="token punctuation">.</span>port2
  channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> flushCallbacks
  <span class="token function-variable function">macroTimerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">macroTimerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>以上代码很简单，就是判断能不能使用相应的<code>API</code></p></blockquote><h2 id="_29-react常考知识点"><a href="#_29-react常考知识点" aria-hidden="true" class="header-anchor">#</a> 29 React常考知识点</h2><h3 id="_29-1-生命周期"><a href="#_29-1-生命周期" aria-hidden="true" class="header-anchor">#</a> 29.1 生命周期</h3><blockquote><p>在 <code>V16</code> 版本中引入了 <code>Fiber</code> 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 <code>2</code> 个 <code>API</code> 来解决问题</p></blockquote><blockquote><p>在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 <code>state</code>，那么调用栈可能会很长</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/6/25/164358b0310f476c" alt></p><ul><li>调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。<code>Fiber</code> 就是为了解决该问题而生</li><li><code>Fiber</code> 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/25/164358f89595d56f" alt></p><ul><li>对于如何区别优先级，<code>React</code> 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 <code>16 ms</code> 必须渲染一次保证不卡顿的情况下，<code>React</code> 会每 <code>16 ms</code>（以内） 暂停一下更新，返回来继续渲染动画</li><li>对于异步渲染，现在渲染有两个阶段：<code>reconciliation</code> 和 <code>commit</code> 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</li></ul><p><strong>1. Reconciliation 阶段</strong></p><ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li></ul><p><strong>2. Commit 阶段</strong></p><ul><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul><blockquote><p>因为 <code>Reconciliation</code> 阶段是可以被打断的，所以 <code>Reconciliation</code> 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 <code>Bug</code>。由此对于 <code>Reconciliation</code> 阶段调用的几个函数，除了 <code>shouldComponentUpdate</code> 以外，其他都应该避免去使用，并且 <code>V16</code> 中也引入了新的 <code>API</code> 来解决这个问题。</p></blockquote><blockquote><p><code>getDerivedStateFromProps</code> 用于替换 <code>componentWillReceiveProps</code> ，该函数会在初始化和 <code>update</code> 时被调用</p></blockquote><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// Initialize state in constructor,</span>
  <span class="token comment">// Or with a property initializer.</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevState<span class="token punctuation">.</span>someMirroredValue <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>someValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        derivedData<span class="token punctuation">:</span> <span class="token function">computeDerivedState</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">,</span>
        someMirroredValue<span class="token punctuation">:</span> nextProps<span class="token punctuation">.</span>someValue
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Return null to indicate no change to state.</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p><code>getSnapshotBeforeUpdate</code> 用于替换 <code>componentWillUpdate</code> ，该函数会在 <code>update</code> 后 <code>DOM</code> 更新前被调用，用于读取最新的 <code>DOM</code> 数据</p></blockquote><blockquote><p>更多详情 http://blog.poetries.top/2018/11/18/react-lifecircle</p></blockquote><h3 id="_29-2-setstate"><a href="#_29-2-setstate" aria-hidden="true" class="header-anchor">#</a> 29.2 setState</h3><ul><li><code>setState</code> 在 <code>React</code> 中是经常使用的一个 <code>API</code>，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 <code>API</code> 是异步的。</li><li>首先  <code>setState</code>   的调用并不会马上引起   <code>state</code>  的改变，并且如果你一次调用了多个   <code>setState</code>   ，那么结果可能并不如你期待的一样。</li></ul><pre class="language-js"><code><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化 `count` 为 0</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// -&gt; 0</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// -&gt; 0</span>
<span class="token punctuation">}</span>
</code></pre><ul><li>第一，两次的打印都为 <code>0</code>，因为 <code>setState</code> 是个异步 <code>API</code>，只有同步代码运行完毕才会执行。<code>setState</code> 异步的原因我认为在于，<code>setState</code> 可能会导致 <code>DOM</code> 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</li><li>第一，两次的打印都为 <code>0</code>，因为 <code>setState</code> 是个异步 API，只有同步代码运行完毕才会执行。<code>setState</code> 异步的原因我认为在于，<code>setState</code> 可能会导致 <code>DOM</code> 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</li></ul><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>  
  <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre><blockquote><p>当然你也可以通过以下方式来实现调用三次 <code>setState</code>使得 <code>count</code> 为 <code>3</code></p></blockquote><pre class="language-js"><code><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>如果你想在每次调用 <code>setState</code> 后获得正确的 <code>state</code>，可以通过如下代码实现</p></blockquote><pre class="language-js"><code><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>更多详情 http://blog.poetries.top/2018/12/20/react-setState</p></blockquote><h3 id="_29-3-性能优化"><a href="#_29-3-性能优化" aria-hidden="true" class="header-anchor">#</a> 29.3 性能优化</h3><ul><li>在 <code>shouldComponentUpdate</code> 函数中我们可以通过返回布尔值来决定当前组件是否需要更新。这层代码逻辑可以是简单地浅比较一下当前 <code>state</code> 和之前的 <code>state</code> 是否相同，也可以是判断某个值更新了才触发组件更新。一般来说不推荐完整地对比当前 <code>state</code> 和之前的 <code>state</code> 是否相同，因为组件更新触发可能会很频繁，这样的完整对比性能开销会有点大，可能会造成得不偿失的情况。</li><li>当然如果真的想完整对比当前 <code>state</code> 和之前的 <code>state</code> 是否相同，并且不影响性能也是行得通的，可以通过 <code>immutable</code> 或者 <code>immer</code> 这些库来生成不可变对象。这类库对于操作大规模的数据来说会提升不错的性能，并且一旦改变数据就会生成一个新的对象，对比前后 <code>state</code> 是否一致也就方便多了，同时也很推荐阅读下 <code>immer</code> 的源码实现</li><li>另外如果只是单纯的浅比较一下，可以直接使用 <code>PureComponent</code>，底层就是实现了浅比较 <code>state</code></li></ul><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        PureComponent
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>这时候你可能会考虑到函数组件就不能使用这种方式了，如果你使用 <code>16.6.0</code> 之后的版本的话，可以使用 <code>React.memo</code> 来实现相同的功能</p></blockquote><pre class="language-js"><code><span class="token keyword">const</span> Test <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        PureComponent
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><blockquote><p>通过这种方式我们就可以既实现了 <code>shouldComponentUpdate</code> 的浅比较，又能够使用函数组件</p></blockquote><h3 id="_29-4-通信"><a href="#_29-4-通信" aria-hidden="true" class="header-anchor">#</a> 29.4 通信</h3><p><strong>1. 父子通信</strong></p><ul><li>父组件通过 <code>props</code> 传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。</li><li>这种父子通信方式也就是典型的单向数据流，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>， 而是必须通过调用父组件函数的方式告知父组件修改数据。</li></ul><p><strong>2. 兄弟组件通信</strong></p><blockquote><p>对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件</p></blockquote><p><strong>3. 跨多层次组件通信</strong></p><blockquote><p>如果你使用 <code>16.3</code> 以上版本的话，对于这种情况可以使用 <code>Context API</code></p></blockquote><pre class="language-js"><code><span class="token comment">// 创建 Context，可以在开始就传入值</span>
<span class="token keyword">const</span> StateContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token comment">// value 就是传入 Context 中的值</span>
      <span class="token operator">&lt;</span>StateContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token string">'yck'</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Child <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>StateContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>
        <span class="token comment">// 取出值</span>
        <span class="token punctuation">{</span>context <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
          name is <span class="token punctuation">{</span> context <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>4. 任意组件</strong></p><blockquote><p>这种方式可以通过 <code>Redux</code> 或者 <code>Event Bus</code> 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p></blockquote><h2 id="_30-监控"><a href="#_30-监控" aria-hidden="true" class="header-anchor">#</a> 30 监控</h2><blockquote><p>更新中...</p></blockquote><h2 id="_31-tcp-udp"><a href="#_31-tcp-udp" aria-hidden="true" class="header-anchor">#</a> 31 TCP/UDP</h2><h3 id="_31-1-udp"><a href="#_31-1-udp" aria-hidden="true" class="header-anchor">#</a> 31.1 UDP</h3><blockquote><p>网络协议是每个前端工程师都必须要掌握的知识，我们将先来学习传输层中的两个协议：<code>UDP</code> 以及<code>TCP</code>。对于大部分工程师来说最常用的协议也就是这两个了，并且面试中经常会提问的也是关于这两个协议的区别</p></blockquote><blockquote><p>常考面试题：<code>UDP</code> 与 <code>TCP</code> 的区别是什么？</p></blockquote><p>首先 <code>UDP</code> 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 <code>UDP</code>协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且<code>UDP</code> 协议也没有任何控制流量的算法，总的来说 <code>UDP</code> 相较于 <code>TCP</code> 更加的轻便</p><p><strong>1. 面向无连接</strong></p><ul><li>首先<code>UDP</code> 是不需要和 <code>TCP</code> 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。</li><li>并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</li></ul><blockquote><p>具体来说就是：</p></blockquote><ul><li>在发送端，应用层将数据传递给传输层的 <code>UDP</code> 协议，<code>UDP</code> 只会给数据增加一个 <code>UDP</code> 头标识下是 <code>UDP</code> 协议，然后就传递给网络层了
在接收端，网络层将数据传递给传输层，<code>UDP</code> 只去除 <code>IP</code> 报文头就传递给应用层，不会任何拼接操作</li></ul><p><strong>2. 不可靠性</strong></p><ul><li>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</li><li>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</li><li>再者网络环境时好时坏，但是 <code>UDP</code> 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 <code>UDP</code> 而不是 <code>TCP</code></li></ul><p><strong>3. 高效</strong></p><ul><li>虽然 <code>UDP</code> 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 <code>TCP</code> 那么复杂了，需要保证数据不丢失且有序到达。</li><li>因此 <code>UDP</code> 的头部开销小，只有八字节，相比 <code>TCP</code> 的至少二十字节要少得多，在传输数据报文时是很高效的。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/163195b245ceb89c" alt></p><blockquote><p><code>UDP</code> 头部包含了以下几个数据</p></blockquote><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口
整个数据报文的长度</li><li>整个数据报文的检验和（<code>IPv4</code> 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p><strong>4. 传输方式</strong></p><blockquote><p><code>UDP</code> 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 <code>UDP</code> 提供了单播，多播，广播的功能。</p></blockquote><p><strong>5. 适合使用的场景</strong></p><blockquote><p><code>UDP</code>虽然对比 <code>TCP</code> 有很多缺点，但是正是因为这些缺点造就了它高效的特性，在很多实时性要求高的地方都可以看到 <code>UDP</code> 的身影。</p></blockquote><p><strong>5.1 直播</strong></p><ul><li>想必大家都看过直播吧，大家可以考虑下如果直播使用了基于 TCP 的协议会发生什么事情？</li></ul><blockquote><ul><li><code>TCP</code> 会严格控制传输的正确性，一旦有某一个数据对端没有收到，就会停止下来直到对端收到这个数据。这种问题在网络条件不错的情况下可能并不会发生什么事情，但是在网络情况差的时候就会变成画面卡住，然后再继续播放下一帧的情况。</li><li>但是对于直播来说，用户肯定关注的是最新的画面，而不是因为网络条件差而丢失的老旧画面，所以 <code>TCP</code> 在这种情况下无用武之地，只会降低用户体验。</li></ul></blockquote><p><strong>5.2 王者荣耀</strong></p><ul><li>首先对于王者荣耀来说，用户体量是相当大的，如果使用 <code>TCP</code> 连接的话，就可能会出现服务器不够用的情况，因为每台服务器可供支撑的 <code>TCP</code> 连接数量是有限制的。</li><li>再者，因为 <code>TCP</code> 会严格控制传输的正确性，如果因为用户网络条件不好就造成页面卡顿然后再传输旧的游戏画面是肯定不能接受的，毕竟对于这类实时性要求很高的游戏来说，最新的游戏画面才是最需要的，而不是老旧的画面，否则角色都不知道死多少次了。</li></ul><h3 id="_31-2-tcp"><a href="#_31-2-tcp" aria-hidden="true" class="header-anchor">#</a> 31.2 TCP</h3><blockquote><p>常考面试题：<code>UDP</code> 与 <code>TCP</code> 的区别是什么？</p></blockquote><blockquote><p><code>TCP</code> 基本是和 <code>UDP</code> 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 <code>UDP</code> 来说不那么的高效</p></blockquote><p><strong>1. 头部</strong></p><blockquote><p>从这个图上我们就可以发现 <code>TCP</code> 头部比 <code>UDP</code> 头部复杂的多</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631be45b084e4bc" alt></p><blockquote><p>对于 <code>TCP</code> 头部来说，以下几个字段是很重要的</p></blockquote><ul><li><code>Sequence number</code>，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li><li><code>Acknowledgement Number</code>，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li><li><code>Window Size</code>，窗口大小，表示还能接收多少字节的数据，用于流量控制</li><li><strong>标识符</strong><ul><li><code>URG=1</code>：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li><li><code>ACK=1</code>：该字段为一表示确认号字段有效。此外，<code>TCP</code> 还规定在连接建立后传送的所有报文段都必须把 <code>ACK</code> 置为一。</li><li><code>PSH=1</code>：该字段为一表示接收端应该立即将数据 <code>push</code> 给应用层，而不是等到缓冲区满后再提交。</li><li><code>RST=1</code>：该字段为一表示当前 <code>TCP</code> 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li><li><code>SYN=1</code>：当<code>SYN=1</code>，<code>ACK=0</code>时，表示当前报文段是一个连接请求报文。当  <code>SYN=1</code>，<code>ACK=1</code>时，表示当前报文段是一个同意建立连接的应答报文。</li><li><code>FIN=1</code>：该字段为一表示此报文段是一个释放连接的请求报文。</li></ul></li></ul><p><strong>2. 状态机</strong></p><blockquote><p><code>TCP</code> 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631bef9e3c60035" alt></p><blockquote><p>在这之前需要了解一个重要的性能指标 <code>RTT</code>。该指标表示发送端发送数据到接收到对端数据所需的往返时间</p></blockquote><p><strong>2.1. 建立连接三次握手</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631bf1e79b3cd42" alt></p><ul><li>首先假设主动发起请求的一端称为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，<code>TCP</code> 连接建立完后都能发送和接收数据，所以 <code>TCP</code> 是一个全双工的协议。</li><li>起初，两端都为 <code>CLOSED</code> 状态。在通信开始前，双方都会创建 <code>TCB</code>。 服务器创建完 <code>TCB</code> 后便进入 <code>LISTEN</code> 状态，此时开始等待客户端发送数据</li></ul><p><strong>第一次握手</strong></p><blockquote><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 <code>SYN-SENT</code> 状态</p></blockquote><p><strong>第二次握手</strong></p><blockquote><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 <code>SYN-RECEIVED</code> 状态</p></blockquote><p><strong>第三次握手</strong></p><ul><li>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 <code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code> 状态，此时连接建立成功。</li><li>PS：第三次握手中可以包含数据，通过快速打开（<code>TFO</code>）技术就可以实现这一功能。其实只要涉及到握手的协议，都可以使用类似 <code>TFO</code> 的方式，客户端和服务端存储相同的 <code>cookie</code>，下次握手时发出 <code>cookie</code> 达到减少 <code>RTT</code> 的目的。</li></ul><blockquote><p>常考面试题：为什么 <code>TCP</code> 建立连接需要三次握手，明明两次就可以建立起连接</p></blockquote><ul><li>因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</li><li>可以想象如下场景。客户端发送了一个连接请求 <code>A</code>，但是因为网络原因造成了超时，这时 <code>TCP</code> 会启动超时重传的机制再次发送一个连接请求 <code>B</code>。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。</li></ul><blockquote><p>假设这时候连接请求 <code>A</code> 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 <code>TCP</code> 连接，从而应答了该请求并进入 <code>ESTABLISHED</code> 状态。但是客户端其实是 <code>CLOSED</code> 的状态，那么就会导致服务端一直等待，造成资源的浪费。</p></blockquote><blockquote><p>PS：在建立连接中，任意一端掉线，<code>TCP</code> 都会重发 <code>SYN</code> 包，一般会重试五次，在建立连接中可能会遇到 <code>SYN Flood</code> 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求</p></blockquote><p><strong>2.2. 断开链接四次握手</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/2/1631fb807f2c6c1b" alt></p><blockquote><p><code>TCP</code> 是全双工的，在断开连接时两端都需要发送 <code>FIN</code> 和 <code>ACK</code></p></blockquote><p><strong>第一次握手</strong></p><blockquote><p>若客户端 <code>A</code> 认为数据发送完成，则它需要向服务端 <code>B</code> 发送连接释放请求。</p></blockquote><p><strong>第二次握手</strong></p><blockquote><p><code>B</code> 收到连接释放请求后，会告诉应用层要释放 <code>TCP</code> 链接。然后会发送 <code>ACK</code> 包，并进入 <code>CLOSE_WAIT</code>状态，此时表明 <code>A</code> 到 <code>B</code> 的连接已经释放，不再接收 <code>A</code> 发的数据了。但是因为 <code>TCP</code> 连接是双向的，所以 <code>B</code> 仍旧可以发送数据给 <code>A</code></p></blockquote><p><strong>3. ARQ 协议</strong></p><blockquote><p><code>ARQ</code> 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，<code>ARQ</code> 协议包含停止等待 <code>ARQ</code> 和连续 <code>ARQ</code> 两种协议。</p></blockquote><p><strong>停止等待 ARQ</strong></p><p><strong>正常传输过程</strong></p><blockquote><p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p></blockquote><p><strong>报文丢失或出错</strong></p><ul><li>在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢失的数据直到对端响应，所以需要每次都备份发送的数据。</li><li>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 <code>A</code> 端重传。</li><li>PS：一般定时器设定的时间都会大于一个 <code>RTT</code> 的平均时间。</li></ul><p><strong>第三次握手</strong></p><ul><li><code>B</code> 如果此时还有没发完的数据会继续发送，完毕后会向 <code>A</code> 发送连接释放请求，然后 <code>B</code> 便进入 <code>LAST-ACK</code> 状态。</li><li>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 <code>ACK</code> 包的发送。</li></ul><p><strong>第四次握手</strong></p><blockquote><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p></blockquote><ul><li>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</li><li>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</li></ul><p><strong>ACK 超时或丢失</strong></p><ul><li>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</li><li>在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</li><li>从上面的描述中大家肯定可以发现这肯定不是一个高效的方式。假设在良好的网络环境中，每次发送数据都需要等待片刻肯定是不能接受的。那么既然我们不能接受这个不那么高效的协议，就来继续学习相对高效的协议吧。</li></ul><p><strong>连续 ARQ</strong></p><blockquote><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p></blockquote><p><strong>累计确认</strong></p><blockquote><p>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标志位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。</p></blockquote><blockquote><p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接收到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样就会造成发送端重复发送数据的情况</p></blockquote><p><strong>4. 滑动窗口</strong></p><ul><li>上面小节中讲到了发送窗口。在 <code>TCP</code> 中，两端其实都维护着窗口：分别为发送端窗口和接收端窗口。</li><li>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/5/1632f25c587ffd54" alt></p><ul><li>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</li><li>当发送端接收到应答报文后，会随之将窗口进行滑动</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/5/1632f25cca99c8f4" alt></p><blockquote><p>滑动窗口是一个很重要的概念，它帮助 TCP 实现了流量控制的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还一直发送数据的情况</p></blockquote><p><strong>Zero 窗口</strong></p><blockquote><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 <code>persistent timer</code> 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 <code>TCP</code> 链接</p></blockquote><p><strong>5. 拥塞处理</strong></p><ul><li>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</li><li>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复</li></ul><p><strong>慢开始算法</strong></p><blockquote><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。想必大家都下载过资源，每当我们开始下载的时候都会发现下载速度是慢慢提升的，而不是一蹴而就直接拉满带宽</p></blockquote><p><strong>慢开始算法步骤具体如下</strong></p><ul><li>连接初始设置拥塞窗口（Congestion Window） 为 <code>1 MSS</code>（一个分段的最大数据量）</li><li>每过一个 <code>RTT</code> 就将窗口大小乘二</li><li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li></ul><p><strong>拥塞避免算法</strong></p><ul><li>拥塞避免算法相比简单点，每过一个 <code>RTT</code> 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</li><li>在传输过程中可能定时器超时的情况，这时候 <code>TCP</code> 会认为网络拥塞了，会马上进行以下步骤：</li></ul><ol><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 <code>1 MSS</code></li><li>启动拥塞避免算法</li></ol><p><strong>快速重传</strong></p><blockquote><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 <code>ACK</code>，无需等待定时器超时而是直接启动快速重传算法。具体算法分为两种：</p></blockquote><p><strong>TCP Taho 实现如下</strong></p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 1 MSS</li><li>重新开始慢开始算法</li><li><code>TCP Reno</code> 实现如下</li></ul><p><strong>拥塞窗口减半</strong></p><ul><li>将阈值设为当前拥塞窗口</li><li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了</li><li>使用拥塞避免算法</li></ul><p><strong>TCP New Ren 改进后的快恢复</strong></p><ul><li>TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</li><li>在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</li></ul><blockquote><p>假如我有一个分段数据是 <code>1 ~ 10</code> 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p></blockquote><h2 id="_32-http-tls"><a href="#_32-http-tls" aria-hidden="true" class="header-anchor">#</a> 32 HTTP/TLS</h2><h3 id="_32-1-http-请求中的内容"><a href="#_32-1-http-请求中的内容" aria-hidden="true" class="header-anchor">#</a> 32.1 HTTP 请求中的内容</h3><blockquote><p><code>HTTP</code> 请求由三部分构成，分别为：</p></blockquote><ul><li>请求行</li><li>首部</li><li>实体</li></ul><blockquote><ul><li>请求行大概长这样 <code>GET /images/logo.gif HTTP/1.1</code>，基本由请求方法、<code>URL</code>、协议版本组成，这其中值得一说的就是请求方法了。</li><li>请求方法分为很多种，最常用的也就是 <code>Get</code> 和 <code>Post</code> 了。虽然请求方法有很多，但是更多的是传达一个语义，而不是说 <code>Post</code> 能做的事情 <code>Get</code> 就不能做了。如果你愿意，都使用 <code>Get</code> 请求或者 <code>Post</code> 请求都是可以的</li></ul></blockquote><blockquote><p>常考面试题：Post 和 Get 的区别？</p></blockquote><ul><li>首先先引入副作用和幂等的概念。</li><li>副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</li><li>幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。因为前者是多了一个账号（资源），后者只是更新同一个资源。</li><li>在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。</li></ul><blockquote><ul><li><code>Get</code> 请求能缓存，<code>Post</code> 不能</li><li><code>Post</code> 相对 <code>Get</code> 安全一点点，因为<code>Get</code> 请求都包含在 <code>URL</code> 里（当然你想写到 <code>body</code> 里也是可以的），且会被浏览器保存历史纪录。<code>Post</code> 不会，但是在抓包的情况下都是一样的。</li><li><code>URL</code>有长度限制，会影响 <code>Get</code> 请求，但是这个长度限制是浏览器规定的，不是 <code>RFC</code> 规定的</li><li><code>Post</code> 支持更多的编码类型且不对数据类型限制</li></ul></blockquote><p><strong>1. 首部</strong></p><blockquote><p>首部分为请求首部和响应首部，并且部分首部两种通用，接下来我们就来学习一部分的常用首部。</p></blockquote><p><strong>1.1 通用首部</strong></p><table><thead><tr><th>通用字段</th><th>作用</th></tr></thead><tbody><tr><td><code>Cache-Control</code></td><td>控制缓存的行为</td></tr><tr><td><code>Connection</code></td><td>浏览器想要优先使用的连接类型，比如 <code>keep-alive</code></td></tr><tr><td><code>Date</code></td><td>创建报文时间</td></tr><tr><td><code>Pragma</code></td><td>报文指令</td></tr><tr><td><code>Via</code></td><td>代理服务器相关信息</td></tr><tr><td><code>Transfer-Encoding</code></td><td>传输编码方式</td></tr><tr><td><code>Upgrade</code></td><td>要求客户端升级协议</td></tr><tr><td><code>Warning</code></td><td>在内容中可能存在错误</td></tr></tbody></table><p><strong>1.2 请求首部</strong></p><table><thead><tr><th>请求首部</th><th>作用</th></tr></thead><tbody><tr><td><code>Accept</code></td><td>能正确接收的媒体类型</td></tr><tr><td><code>Accept-Charset</code></td><td>能正确接收的字符集</td></tr><tr><td><code>Accept-Encoding</code></td><td>能正确接收的编码格式列表</td></tr><tr><td><code>Accept-Language</code></td><td>能正确接收的语言列表</td></tr><tr><td><code>Expect</code></td><td>期待服务端的指定行为</td></tr><tr><td><code>From</code></td><td>请求方邮箱地址</td></tr><tr><td><code>Host</code></td><td>服务器的域名</td></tr><tr><td><code>If-Match</code></td><td>两端资源标记比较</td></tr><tr><td><code>If-Modified-Since</code></td><td>本地资源未修改返回 <code>304</code>（比较时间）</td></tr><tr><td><code>If-None-Match</code></td><td>本地资源未修改返回 <code>304</code>（比较标记）</td></tr><tr><td><code>User-Agent</code></td><td>客户端信息</td></tr><tr><td><code>Max-Forwards</code></td><td>限制可被代理及网关转发的次数</td></tr><tr><td><code>Proxy-Authorization</code></td><td>向代理服务器发送验证信息</td></tr><tr><td><code>Range</code></td><td>请求某个内容的一部分</td></tr><tr><td><code>Referer</code></td><td>表示浏览器所访问的前一个页面</td></tr><tr><td><code>TE</code></td><td>传输编码方式</td></tr></tbody></table><p><strong>1.3 响应首部</strong></p><table><thead><tr><th>响应首部</th><th>作用</th></tr></thead><tbody><tr><td><code>Accept-Ranges</code></td><td>是否支持某些种类的范围</td></tr><tr><td><code>Age</code></td><td>资源在代理缓存中存在的时间</td></tr><tr><td><code>ETag</code></td><td>资源标识</td></tr><tr><td><code>Location</code></td><td>客户端重定向到某个 <code>URL</code></td></tr><tr><td><code>Proxy-Authenticate</code></td><td>向代理服务器发送验证信息</td></tr><tr><td><code>Server</code></td><td>服务器名字</td></tr><tr><td><code>WWW-Authenticate</code></td><td>获取资源需要的验证信息</td></tr></tbody></table><p><strong>1.4 实体首部</strong></p><table><thead><tr><th>实体首部</th><th>作用</th></tr></thead><tbody><tr><td><code>Allow</code></td><td>资源的正确请求方式</td></tr><tr><td><code>Content-Encoding</code></td><td>内容的编码格式</td></tr><tr><td><code>Content-Language</code></td><td>内容使用的语言</td></tr><tr><td><code>Content-Length</code></td><td><code>request body</code> 长度</td></tr><tr><td><code>Content-Location</code></td><td>返回数据的备用地址</td></tr><tr><td><code>Content-MD5</code></td><td><code>Base64</code>加密格式的内容 <code>MD5</code>检验值</td></tr><tr><td><code>Content-Range</code></td><td>内容的位置范围</td></tr><tr><td><code>Content-Type</code></td><td>内容的媒体类型</td></tr><tr><td><code>Expires</code></td><td>内容的过期时间</td></tr><tr><td><code>Last_modified</code></td><td>内容的最后修改时间</td></tr></tbody></table><p><strong>2. 常见状态码</strong></p><blockquote><p>状态码表示了响应的一个状态，可以让我们清晰的了解到这一次请求是成功还是失败，如果失败的话，是什么原因导致的，当然状态码也是用于传达语义的。如果胡乱使用状态码，那么它存在的意义就没有了</p></blockquote><p><strong>2XX 成功</strong></p><ul><li><code>200 OK</code>，表示从客户端发来的请求在服务器端被正确处理</li><li><code>204 No content</code>，表示请求成功，但响应报文不含实体的主体部分</li><li><code>205 Reset Content</code>，表示请求成功，但响应报文不含实体的主体部分，但是与 <code>204</code> 响应不同在于要求请求方重置内容</li><li><code>206 Partial Content</code>，进行范围请求</li></ul><p><strong>3XX 重定向</strong></p><ul><li><code>301 moved permanently</code>，永久性重定向，表示资源已被分配了新的 URL</li><li><code>302 found</code>，临时性重定向，表示资源临时被分配了新的 <code>URL</code></li><li><code>303 see other</code>，表示资源存在着另一个 <code>URL</code>，应使用 <code>GET</code> 方法获取资源</li><li><code>304 not modified</code>，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li><code>307 temporary redirect</code>，临时重定向，和<code>302</code>含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><p><strong>4XX 客户端错误</strong></p><ul><li><code>400 bad request</code>，请求报文存在语法错误</li><li><code>401 unauthorized</code>，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li><code>403 forbidden</code>，表示对请求资源的访问被服务器拒绝</li><li><code>404 not found</code>，表示在服务器上没有找到请求的资源</li></ul><p><strong>5XX 服务器错误</strong></p><ul><li><code>500 internal sever error</code>，表示服务器端在执行请求时发生了错误</li><li><code>501 Not Implemented</code>，表示服务器不支持当前请求所需要的某个功能</li><li><code>503 service unavailable</code>，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h3 id="_32-2-tls"><a href="#_32-2-tls" aria-hidden="true" class="header-anchor">#</a> 32.2 TLS</h3><ul><li><code>HTTPS</code> 还是通过了 <code>HTTP</code> 来传输信息，但是信息通过 <code>TLS</code> 协议进行了加密。</li><li><code>TLS</code> 协议位于传输层之上，应用层之下。首次进行 <code>TLS</code> 协议传输需要两个 <code>RTT</code> ，接下来可以通过 <code>Session Resumption</code> 减少到一个 <code>RTT</code>。</li><li>在 <code>TLS</code> 中使用了两种加密技术，分别为：对称加密和非对称加密。</li></ul><p><strong>对称加密</strong></p><ul><li>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</li><li>这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。</li></ul><p><strong>非对称加密</strong></p><ul><li>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</li><li>这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。</li></ul><blockquote><p>简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。</p></blockquote><p>TLS 握手过程如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/1635260126b3a10c" alt></p><ul><li>客户端发送一个随机值以及需要的协议和加密方式。</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li><li>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</li></ul><blockquote><p>PS：以上说明的都是 <code>TLS 1.2</code> 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了</p></blockquote><h2 id="_33-http2-0"><a href="#_33-http2-0" aria-hidden="true" class="header-anchor">#</a> 33 HTTP2.0</h2><blockquote><ul><li><code>HTTP/2</code> 很好的解决了当下最常用的 <code>HTTP/1</code> 所存在的一些性能问题，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。</li><li>虽然 <code>HTTP/2</code> 已经解决了很多问题，但是并不代表它已经是完美的了，<code>HTTP/3</code> 就是为了解决 <code>HTTP/2</code> 所存在的一些问题而被推出来的。</li></ul></blockquote><h3 id="_33-1-http-2"><a href="#_33-1-http-2" aria-hidden="true" class="header-anchor">#</a> 33.1 HTTP/2</h3><ul><li><code>HTTP/2</code> 相比于 <code>HTTP/1</code>，可以说是大幅度提高了网页的性能。</li><li>在 <code>HTTP/1</code> 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</li><li>在 <code>HTTP/2</code> 中引入了多路复用的技术，这个技术可以只通过一个 <code>TCP</code> 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 <code>TCP</code> 连接都需要慢慢提升传输速度。</li></ul><blockquote><p>大家可以通过 <a href="https://http2.akamai.com/demo" target="_blank" rel="noopener noreferrer">该链接</a> 感受下 HTTP/2 比 HTTP/1 到底快了多少</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542ca61eaff17" alt></p><blockquote><p>在 <code>HTTP/1</code> 中，因为队头阻塞的原因，你会发现发送请求是长这样的</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542c96df8563d" alt></p><blockquote><p>在 <code>HTTP/2</code> 中，因为可以复用同一个 <code>TCP</code> 连接，你会发现发送请求是长这样的</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542c9d3128c7a" alt></p><h3 id="_33-2-二进制传输"><a href="#_33-2-二进制传输" aria-hidden="true" class="header-anchor">#</a> 33.2 二进制传输</h3><blockquote><p><code>HTTP/2</code> 中所有加强性能的核心点在于此。在之前的 <code>HTTP</code> 版本中，我们是通过文本的方式传输数据。在 <code>HTTP/2</code> 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163543c25e5e9f23" alt></p><h3 id="_33-3-多路复用"><a href="#_33-3-多路复用" aria-hidden="true" class="header-anchor">#</a> 33.3 多路复用</h3><ul><li>在 <code>HTTP/2</code> 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</li><li>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</li><li>多路复用，就是在一个 <code>TCP</code> 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 <code>HTTP</code> 旧版本中的队头阻塞问题，极大的提高传输性能。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/1635442531d3e5ee" alt></p><h3 id="_33-4-header-压缩"><a href="#_33-4-header-压缩" aria-hidden="true" class="header-anchor">#</a> 33.4 Header 压缩</h3><ul><li>在 <code>HTTP/1</code> 中，我们使用文本的形式传输 <code>header</code>，在 <code>header</code> 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</li><li>在 <code>HTTP / 2</code>中，使用了 <code>HPACK</code> 压缩格式对传输的 <code>header</code> 进行编码，减少了 <code>header</code> 的大小。并在两端维护了索引表，用于记录出现过的 <code>header</code> ，后面在传输过程中就可以传输已经记录过的 <code>header</code> 的键名，对端收到数据后就可以通过键名找到对应的值。</li></ul><h3 id="_33-5-服务端-push"><a href="#_33-5-服务端-push" aria-hidden="true" class="header-anchor">#</a> 33.5 服务端 Push</h3><ul><li>在 <code>HTTP/2</code> 中，服务端可以在客户端某个请求后，主动推送其他资源。</li><li>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 <code>push</code> 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 <code>prefetch</code></li></ul><h3 id="_33-6-http-3"><a href="#_33-6-http-3" aria-hidden="true" class="header-anchor">#</a> 33.6  HTTP/3</h3><ul><li>虽然 <code>HTTP/2</code> 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 <code>TCP</code> 协议的问题。</li><li>因为 <code>HTTP/2</code> 使用了多路复用，一般来说同一域名下只需要使用一个 <code>TCP</code> 连接。当这个连接中出现了丢包的情况，那就会导致 <code>HTTP/2</code> 的表现情况反倒不如 <code>HTTP/1</code> 了。</li><li>因为在出现丢包的情况下，整个 <code>TCP</code> 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 <code>HTTP/1</code> 来说，可以开启多个 <code>TCP</code> 连接，出现这种情况反到只会影响其中一个连接，剩余的 <code>TCP</code> 连接还可以正常传输数据。</li><li>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</li><li>基于这个原因，Google 就更起炉灶搞了一个基于 <code>UDP</code> 协议的 <code>QUIC</code> 协议，并且使用在了 <code>HTTP/3</code> 上，当然 <code>HTTP/3</code> 之前名为 <code>HTTP-over-QUIC</code>，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 <code>QUIC</code>，接下来我们就来学习关于这个协议的内容。</li></ul><p><strong>QUIC</strong></p><blockquote><p>之前我们学习过 UDP 协议的内容，知道这个协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。这里我们就挑选几个重要的功能学习下这个协议的内容。</p></blockquote><p><strong>多路复用</strong></p><blockquote><p>虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p></blockquote><ul><li>并且 <code>QUIC</code> 在移动端的表现也会比 <code>TCP</code> 好。因为 <code>TCP</code> 是基于 <code>IP</code> 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 <code>QUIC</code> 是通过 <code>ID</code>** 的方式去识别一个连接，不管你网络环境如何变化，只要 <code>ID</code> 不变，就能迅速重连上。</li></ul><p><strong>0-RTT</strong></p><blockquote><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p></blockquote><p><strong>纠错机制</strong></p><ul><li>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</li><li>当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。</li><li>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了</li></ul><h2 id="_34-设计模式"><a href="#_34-设计模式" aria-hidden="true" class="header-anchor">#</a> 34 设计模式</h2><blockquote><p>更新中...</p></blockquote><h2 id="_35-常见数据结构"><a href="#_35-常见数据结构" aria-hidden="true" class="header-anchor">#</a> 35 常见数据结构</h2><blockquote><p>更新中...</p></blockquote><h2 id="_37-常考算法题解析"><a href="#_37-常考算法题解析" aria-hidden="true" class="header-anchor">#</a> 37 常考算法题解析</h2><blockquote><p>更新中...</p></blockquote><h2 id="_38-css常考面试题解析"><a href="#_38-css常考面试题解析" aria-hidden="true" class="header-anchor">#</a> 38 css常考面试题解析</h2><blockquote><p>更新中...</p></blockquote></div><div class="content edit-link"><a href="https://github.com/poetries/FE-Interview-Questions/edit/dev/docs/excellent/README.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/FE-Interview-Questions/computed-base/" class="prev">
          第四部分：计算机基础
        </a></span><span class="next"><a href="/FE-Interview-Questions/simply/">
          第六部分：精简版
        </a> →
      </span></p></div></div></div></div>
    <script src="/FE-Interview-Questions/assets/js/2.64fabc8e.js" defer></script><script src="/FE-Interview-Questions/assets/js/app.c4dcc72c.js" defer></script>
  </body>
</html>
